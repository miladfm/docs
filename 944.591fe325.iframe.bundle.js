/*! For license information please see 944.591fe325.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkcoco_kits=self.webpackChunkcoco_kits||[]).push([[944],{"./node_modules/.pnpm/@angular+core@17.3.11_rxjs@7.8.1_zone.js@0.14.7/node_modules/@angular/core/fesm2022/core.mjs":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{nWp:()=>Attribute,Ngq:()=>ChangeDetectionStrategy,gRc:()=>ChangeDetectorRef,uAl:()=>Component,Ocv:()=>DEFAULT_CURRENCY_CODE,abz:()=>DestroyRef,WLR:()=>Directive,aKT:()=>ElementRef,bkB:()=>EventEmitter,xri:()=>Host,y_5:()=>Inject,_qm:()=>Injectable,nKC:()=>InjectionToken,zZn:()=>Injector,pde:()=>Input,_q3:()=>IterableDiffers,MKu:()=>KeyValueDiffers,xe9:()=>LOCALE_ID,UQu:()=>NgModule,Vns:()=>NgModuleRef$1,SKi:()=>NgZone,Xx1:()=>Optional,Agw:()=>PLATFORM_ID,nT_:()=>Pipe,sFG:()=>Renderer2,czy:()=>RendererStyleFlags2,C4Q:()=>TemplateRef,RxE:()=>Version,c1b:()=>ViewContainerRef,Af3:()=>assertInInjectionContext,L39:()=>booleanAttribute,EWP:()=>computed,w6W:()=>createNgModule,QZP:()=>effect,WQX:()=>inject,hFB:()=>input,Udg:()=>numberAttribute,vPA:()=>signal,O8t:()=>untracked,GGh:()=>IMAGE_CONFIG,PUk:()=>IMAGE_CONFIG_DEFAULTS,KH2:()=>LocaleDataIndex,wOt:()=>RuntimeError,H5H:()=>findLocaleData,Zy3:()=>formatRuntimeError,mq5:()=>getLocalePluralCase,jNT:()=>isPromise,zjR:()=>isSubscribable,ngT:()=>performanceMarkFeature,rrr:()=>setClassMetadata,Tbb:()=>stringify,rcV:()=>unwrapSafeValue,GFd:()=>ɵɵInputTransformsFeature,OA$:()=>ɵɵNgOnChangesFeature,FsC:()=>ɵɵdefineDirective,jDH:()=>ɵɵdefineInjectable,G2t:()=>ɵɵdefineInjector,$C:()=>ɵɵdefineNgModule,EJ8:()=>ɵɵdefinePipe,rXU:()=>ɵɵdirectiveInject,KVO:()=>ɵɵinject,kS0:()=>ɵɵinjectAttribute,xc7:()=>ɵɵstyleProp});var asyncToGenerator=__webpack_require__("./node_modules/.pnpm/@babel+runtime@7.24.5/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");function defaultEquals(a,b){return Object.is(a,b)}let activeConsumer=null,inNotificationPhase=!1,epoch=1;const SIGNAL=Symbol("SIGNAL");function setActiveConsumer(consumer){const prev=activeConsumer;return activeConsumer=consumer,prev}function getActiveConsumer(){return activeConsumer}const REACTIVE_NODE={version:0,lastCleanEpoch:0,dirty:!1,producerNode:void 0,producerLastReadVersion:void 0,producerIndexOfThis:void 0,nextProducerIndex:0,liveConsumerNode:void 0,liveConsumerIndexOfThis:void 0,consumerAllowSignalWrites:!1,consumerIsAlwaysLive:!1,producerMustRecompute:()=>!1,producerRecomputeValue:()=>{},consumerMarkedDirty:()=>{},consumerOnSignalRead:()=>{}};function producerAccessed(node){if(inNotificationPhase)throw new Error("undefined"!=typeof ngDevMode&&ngDevMode?"Assertion error: signal read during notification phase":"");if(null===activeConsumer)return;activeConsumer.consumerOnSignalRead(node);const idx=activeConsumer.nextProducerIndex++;if(assertConsumerNode(activeConsumer),idx<activeConsumer.producerNode.length&&activeConsumer.producerNode[idx]!==node&&consumerIsLive(activeConsumer)){producerRemoveLiveConsumerAtIndex(activeConsumer.producerNode[idx],activeConsumer.producerIndexOfThis[idx])}activeConsumer.producerNode[idx]!==node&&(activeConsumer.producerNode[idx]=node,activeConsumer.producerIndexOfThis[idx]=consumerIsLive(activeConsumer)?producerAddLiveConsumer(node,activeConsumer,idx):0),activeConsumer.producerLastReadVersion[idx]=node.version}function producerUpdateValueVersion(node){if((!consumerIsLive(node)||node.dirty)&&(node.dirty||node.lastCleanEpoch!==epoch)){if(!node.producerMustRecompute(node)&&!consumerPollProducersForChange(node))return node.dirty=!1,void(node.lastCleanEpoch=epoch);node.producerRecomputeValue(node),node.dirty=!1,node.lastCleanEpoch=epoch}}function producerNotifyConsumers(node){if(void 0===node.liveConsumerNode)return;const prev=inNotificationPhase;inNotificationPhase=!0;try{for(const consumer of node.liveConsumerNode)consumer.dirty||consumerMarkDirty(consumer)}finally{inNotificationPhase=prev}}function producerUpdatesAllowed(){return!1!==activeConsumer?.consumerAllowSignalWrites}function consumerMarkDirty(node){node.dirty=!0,producerNotifyConsumers(node),node.consumerMarkedDirty?.(node)}function consumerBeforeComputation(node){return node&&(node.nextProducerIndex=0),setActiveConsumer(node)}function consumerAfterComputation(node,prevConsumer){if(setActiveConsumer(prevConsumer),node&&void 0!==node.producerNode&&void 0!==node.producerIndexOfThis&&void 0!==node.producerLastReadVersion){if(consumerIsLive(node))for(let i=node.nextProducerIndex;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);for(;node.producerNode.length>node.nextProducerIndex;)node.producerNode.pop(),node.producerLastReadVersion.pop(),node.producerIndexOfThis.pop()}}function consumerPollProducersForChange(node){assertConsumerNode(node);for(let i=0;i<node.producerNode.length;i++){const producer=node.producerNode[i],seenVersion=node.producerLastReadVersion[i];if(seenVersion!==producer.version)return!0;if(producerUpdateValueVersion(producer),seenVersion!==producer.version)return!0}return!1}function consumerDestroy(node){if(assertConsumerNode(node),consumerIsLive(node))for(let i=0;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);node.producerNode.length=node.producerLastReadVersion.length=node.producerIndexOfThis.length=0,node.liveConsumerNode&&(node.liveConsumerNode.length=node.liveConsumerIndexOfThis.length=0)}function producerAddLiveConsumer(node,consumer,indexOfThis){if(assertProducerNode(node),assertConsumerNode(node),0===node.liveConsumerNode.length)for(let i=0;i<node.producerNode.length;i++)node.producerIndexOfThis[i]=producerAddLiveConsumer(node.producerNode[i],node,i);return node.liveConsumerIndexOfThis.push(indexOfThis),node.liveConsumerNode.push(consumer)-1}function producerRemoveLiveConsumerAtIndex(node,idx){if(assertProducerNode(node),assertConsumerNode(node),"undefined"!=typeof ngDevMode&&ngDevMode&&idx>=node.liveConsumerNode.length)throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);if(1===node.liveConsumerNode.length)for(let i=0;i<node.producerNode.length;i++)producerRemoveLiveConsumerAtIndex(node.producerNode[i],node.producerIndexOfThis[i]);const lastIdx=node.liveConsumerNode.length-1;if(node.liveConsumerNode[idx]=node.liveConsumerNode[lastIdx],node.liveConsumerIndexOfThis[idx]=node.liveConsumerIndexOfThis[lastIdx],node.liveConsumerNode.length--,node.liveConsumerIndexOfThis.length--,idx<node.liveConsumerNode.length){const idxProducer=node.liveConsumerIndexOfThis[idx],consumer=node.liveConsumerNode[idx];assertConsumerNode(consumer),consumer.producerIndexOfThis[idxProducer]=idx}}function consumerIsLive(node){return node.consumerIsAlwaysLive||(node?.liveConsumerNode?.length??0)>0}function assertConsumerNode(node){node.producerNode??=[],node.producerIndexOfThis??=[],node.producerLastReadVersion??=[]}function assertProducerNode(node){node.liveConsumerNode??=[],node.liveConsumerIndexOfThis??=[]}function createComputed(computation){const node=Object.create(COMPUTED_NODE);node.computation=computation;const computed=()=>{if(producerUpdateValueVersion(node),producerAccessed(node),node.value===ERRORED)throw node.error;return node.value};return computed[SIGNAL]=node,computed}const UNSET=Symbol("UNSET"),COMPUTING=Symbol("COMPUTING"),ERRORED=Symbol("ERRORED"),COMPUTED_NODE=(()=>({...REACTIVE_NODE,value:UNSET,dirty:!0,error:null,equal:defaultEquals,producerMustRecompute:node=>node.value===UNSET||node.value===COMPUTING,producerRecomputeValue(node){if(node.value===COMPUTING)throw new Error("Detected cycle in computations.");const oldValue=node.value;node.value=COMPUTING;const prevConsumer=consumerBeforeComputation(node);let newValue;try{newValue=node.computation()}catch(err){newValue=ERRORED,node.error=err}finally{consumerAfterComputation(node,prevConsumer)}oldValue!==UNSET&&oldValue!==ERRORED&&newValue!==ERRORED&&node.equal(oldValue,newValue)?node.value=oldValue:(node.value=newValue,node.version++)}}))();let throwInvalidWriteToSignalErrorFn=function defaultThrowError(){throw new Error};function throwInvalidWriteToSignalError(){throwInvalidWriteToSignalErrorFn()}let postSignalSetFn=null;function signalSetFn(node,newValue){producerUpdatesAllowed()||throwInvalidWriteToSignalError(),node.equal(node.value,newValue)||(node.value=newValue,function signalValueChanged(node){node.version++,function producerIncrementEpoch(){epoch++}(),producerNotifyConsumers(node),postSignalSetFn?.()}(node))}const SIGNAL_NODE=(()=>({...REACTIVE_NODE,equal:defaultEquals,value:void 0}))();function createWatch(fn,schedule,allowSignalWrites){const node=Object.create(WATCH_NODE);allowSignalWrites&&(node.consumerAllowSignalWrites=!0),node.fn=fn,node.schedule=schedule;const registerOnCleanup=cleanupFn=>{node.cleanupFn=cleanupFn};return node.ref={notify:()=>consumerMarkDirty(node),run:()=>{if(null===node.fn)return;if(function isInNotificationPhase(){return inNotificationPhase}())throw new Error("Schedulers cannot synchronously execute watches while scheduling.");if(node.dirty=!1,node.hasRun&&!consumerPollProducersForChange(node))return;node.hasRun=!0;const prevConsumer=consumerBeforeComputation(node);try{node.cleanupFn(),node.cleanupFn=NOOP_CLEANUP_FN,node.fn(registerOnCleanup)}finally{consumerAfterComputation(node,prevConsumer)}},cleanup:()=>node.cleanupFn(),destroy:()=>function destroyWatchNode(node){(function isWatchNodeDestroyed(node){return null===node.fn&&null===node.schedule})(node)||(consumerDestroy(node),node.cleanupFn(),node.fn=null,node.schedule=null,node.cleanupFn=NOOP_CLEANUP_FN)}(node),[SIGNAL]:node},node.ref}const NOOP_CLEANUP_FN=()=>{},WATCH_NODE=(()=>({...REACTIVE_NODE,consumerIsAlwaysLive:!0,consumerAllowSignalWrites:!1,consumerMarkedDirty:node=>{null!==node.schedule&&node.schedule(node.ref)},hasRun:!1,cleanupFn:NOOP_CLEANUP_FN}))();var Subject=__webpack_require__("./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js"),Subscription=__webpack_require__("./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscription.js"),BehaviorSubject=__webpack_require__("./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js"),map=__webpack_require__("./node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js");const ERROR_DETAILS_PAGE_BASE_URL="https://angular.io/errors",XSS_SECURITY_URL="https://g.co/ng/security#xss";class RuntimeError extends Error{constructor(code,message){super(formatRuntimeError(code,message)),this.code=code}}function formatRuntimeError(code,message){const fullCode=`NG0${Math.abs(code)}`;let errorMessage=`${fullCode}${message?": "+message:""}`;if(ngDevMode&&code<0){const addPeriodSeparator=!errorMessage.match(/[.,;!?\n]$/);errorMessage=`${errorMessage}${addPeriodSeparator?".":""} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`}return errorMessage}const REQUIRED_UNSET_VALUE=Symbol("InputSignalNode#UNSET"),INPUT_SIGNAL_NODE=(()=>({...SIGNAL_NODE,transformFn:void 0,applyValueToInputSignal(node,value){signalSetFn(node,value)}}))();function createInputSignal(initialValue,options){const node=Object.create(INPUT_SIGNAL_NODE);function inputValueFn(){if(producerAccessed(node),node.value===REQUIRED_UNSET_VALUE)throw new RuntimeError(-950,ngDevMode&&"Input is required but no value is available yet.");return node.value}return node.value=initialValue,node.transformFn=options?.transform,inputValueFn[SIGNAL]=node,ngDevMode&&(inputValueFn.toString=()=>`[Input Signal: ${inputValueFn()}]`),inputValueFn}function noSideEffects(fn){return{toString:fn}.toString()}const ANNOTATIONS="__annotations__",PARAMETERS="__parameters__",PROP_METADATA="__prop__metadata__";function makeDecorator(name,props,parentClass,additionalProcessing,typeFn){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function DecoratorFactory(...args){if(this instanceof DecoratorFactory)return metaCtor.call(this,...args),this;const annotationInstance=new DecoratorFactory(...args);return function TypeDecorator(cls){typeFn&&typeFn(cls,...args);return(cls.hasOwnProperty(ANNOTATIONS)?cls[ANNOTATIONS]:Object.defineProperty(cls,ANNOTATIONS,{value:[]})[ANNOTATIONS]).push(annotationInstance),additionalProcessing&&additionalProcessing(cls),cls}}return parentClass&&(DecoratorFactory.prototype=Object.create(parentClass.prototype)),DecoratorFactory.prototype.ngMetadataName=name,DecoratorFactory.annotationCls=DecoratorFactory,DecoratorFactory}))}function makeMetadataCtor(props){return function ctor(...args){if(props){const values=props(...args);for(const propName in values)this[propName]=values[propName]}}}function makeParamDecorator(name,props,parentClass){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function ParamDecoratorFactory(...args){if(this instanceof ParamDecoratorFactory)return metaCtor.apply(this,args),this;const annotationInstance=new ParamDecoratorFactory(...args);return ParamDecorator.annotation=annotationInstance,ParamDecorator;function ParamDecorator(cls,unusedKey,index){const parameters=cls.hasOwnProperty(PARAMETERS)?cls[PARAMETERS]:Object.defineProperty(cls,PARAMETERS,{value:[]})[PARAMETERS];for(;parameters.length<=index;)parameters.push(null);return(parameters[index]=parameters[index]||[]).push(annotationInstance),cls}}return parentClass&&(ParamDecoratorFactory.prototype=Object.create(parentClass.prototype)),ParamDecoratorFactory.prototype.ngMetadataName=name,ParamDecoratorFactory.annotationCls=ParamDecoratorFactory,ParamDecoratorFactory}))}function makePropDecorator(name,props,parentClass,additionalProcessing){return noSideEffects((()=>{const metaCtor=makeMetadataCtor(props);function PropDecoratorFactory(...args){if(this instanceof PropDecoratorFactory)return metaCtor.apply(this,args),this;const decoratorInstance=new PropDecoratorFactory(...args);return function PropDecorator(target,name){if(void 0===target)throw new Error("Standard Angular field decorators are not supported in JIT mode.");const constructor=target.constructor,meta=constructor.hasOwnProperty(PROP_METADATA)?constructor[PROP_METADATA]:Object.defineProperty(constructor,PROP_METADATA,{value:{}})[PROP_METADATA];meta[name]=meta.hasOwnProperty(name)&&meta[name]||[],meta[name].unshift(decoratorInstance),additionalProcessing&&additionalProcessing(target,name,...args)}}return parentClass&&(PropDecoratorFactory.prototype=Object.create(parentClass.prototype)),PropDecoratorFactory.prototype.ngMetadataName=name,PropDecoratorFactory.annotationCls=PropDecoratorFactory,PropDecoratorFactory}))}const _global=globalThis;function initNgDevMode(){return!("undefined"!=typeof ngDevMode&&!ngDevMode)&&("object"==typeof ngDevMode&&0!==Object.keys(ngDevMode).length||function ngDevModeResetPerfCounters(){const locationString="undefined"!=typeof location?location.toString():"",newCounters={namedConstructors:-1!=locationString.indexOf("ngDevMode=namedConstructors"),firstCreatePass:0,tNode:0,tView:0,rendererCreateTextNode:0,rendererSetText:0,rendererCreateElement:0,rendererAddEventListener:0,rendererSetAttribute:0,rendererRemoveAttribute:0,rendererSetProperty:0,rendererSetClassName:0,rendererAddClass:0,rendererRemoveClass:0,rendererSetStyle:0,rendererRemoveStyle:0,rendererDestroy:0,rendererDestroyNode:0,rendererMoveNode:0,rendererRemoveNode:0,rendererAppendChild:0,rendererInsertBefore:0,rendererCreateComment:0,hydratedNodes:0,hydratedComponents:0,dehydratedViewsRemoved:0,dehydratedViewsCleanupRuns:0,componentsSkippedHydration:0};return-1===locationString.indexOf("ngDevMode=false")?("object"!=typeof _global.ngDevMode&&(_global.ngDevMode={}),Object.assign(_global.ngDevMode,newCounters)):_global.ngDevMode=!1,newCounters}(),"undefined"!=typeof ngDevMode&&!!ngDevMode)}function getClosureSafeProperty(objWithPropertyToExtract){for(let key in objWithPropertyToExtract)if(objWithPropertyToExtract[key]===getClosureSafeProperty)return key;throw Error("Could not find renamed property on target object.")}function fillProperties(target,source){for(const key in source)source.hasOwnProperty(key)&&!target.hasOwnProperty(key)&&(target[key]=source[key])}function stringify(token){if("string"==typeof token)return token;if(Array.isArray(token))return"["+token.map(stringify).join(", ")+"]";if(null==token)return""+token;if(token.overriddenName)return`${token.overriddenName}`;if(token.name)return`${token.name}`;const res=token.toString();if(null==res)return""+res;const newLineIndex=res.indexOf("\n");return-1===newLineIndex?res:res.substring(0,newLineIndex)}function concatStringsWithSpace(before,after){return null==before||""===before?null===after?"":after:null==after||""===after?before:before+" "+after}const __forward_ref__=getClosureSafeProperty({__forward_ref__:getClosureSafeProperty});function forwardRef(forwardRefFn){return forwardRefFn.__forward_ref__=forwardRef,forwardRefFn.toString=function(){return stringify(this())},forwardRefFn}function resolveForwardRef(type){return isForwardRef(type)?type():type}function isForwardRef(fn){return"function"==typeof fn&&fn.hasOwnProperty(__forward_ref__)&&fn.__forward_ref__===forwardRef}function assertNumber(actual,msg){"number"!=typeof actual&&throwError(msg,typeof actual,"number","===")}function assertNumberInRange(actual,minInclusive,maxInclusive){assertNumber(actual,"Expected a number"),assertLessThanOrEqual(actual,maxInclusive,"Expected number to be less than or equal to"),assertGreaterThanOrEqual(actual,minInclusive,"Expected number to be greater than or equal to")}function assertString(actual,msg){"string"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"string","===")}function assertFunction(actual,msg){"function"!=typeof actual&&throwError(msg,null===actual?"null":typeof actual,"function","===")}function assertEqual(actual,expected,msg){actual!=expected&&throwError(msg,actual,expected,"==")}function assertNotEqual(actual,expected,msg){actual==expected&&throwError(msg,actual,expected,"!=")}function assertSame(actual,expected,msg){actual!==expected&&throwError(msg,actual,expected,"===")}function assertNotSame(actual,expected,msg){actual===expected&&throwError(msg,actual,expected,"!==")}function assertLessThan(actual,expected,msg){actual<expected||throwError(msg,actual,expected,"<")}function assertLessThanOrEqual(actual,expected,msg){actual<=expected||throwError(msg,actual,expected,"<=")}function assertGreaterThan(actual,expected,msg){actual>expected||throwError(msg,actual,expected,">")}function assertGreaterThanOrEqual(actual,expected,msg){actual>=expected||throwError(msg,actual,expected,">=")}function assertDefined(actual,msg){null==actual&&throwError(msg,actual,null,"!=")}function throwError(msg,actual,expected,comparison){throw new Error(`ASSERTION ERROR: ${msg}`+(null==comparison?"":` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`))}function assertDomNode(node){node instanceof Node||throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`)}function assertIndexInRange(arr,index){assertDefined(arr,"Array must be defined.");const maxLen=arr.length;(index<0||index>=maxLen)&&throwError(`Index expected to be less than ${maxLen} but got ${index}`)}function assertOneOf(value,...validValues){if(-1!==validValues.indexOf(value))return!0;throwError(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`)}function assertNotReactive(fn){null!==getActiveConsumer()&&throwError(`${fn}() should never be called in a reactive context.`)}function ɵɵdefineInjectable(opts){return{token:opts.token,providedIn:opts.providedIn||null,factory:opts.factory,value:void 0}}function ɵɵdefineInjector(options){return{providers:options.providers||[],imports:options.imports||[]}}function getInjectableDef(type){return getOwnDefinition(type,NG_PROV_DEF)||getOwnDefinition(type,NG_INJECTABLE_DEF)}function getOwnDefinition(type,field){return type.hasOwnProperty(field)?type[field]:null}function getInjectorDef(type){return type&&(type.hasOwnProperty(NG_INJ_DEF)||type.hasOwnProperty(NG_INJECTOR_DEF))?type[NG_INJ_DEF]:null}const NG_PROV_DEF=getClosureSafeProperty({ɵprov:getClosureSafeProperty}),NG_INJ_DEF=getClosureSafeProperty({ɵinj:getClosureSafeProperty}),NG_INJECTABLE_DEF=getClosureSafeProperty({ngInjectableDef:getClosureSafeProperty}),NG_INJECTOR_DEF=getClosureSafeProperty({ngInjectorDef:getClosureSafeProperty});class InjectionToken{constructor(_desc,options){this._desc=_desc,this.ngMetadataName="InjectionToken",this.ɵprov=void 0,"number"==typeof options?(("undefined"==typeof ngDevMode||ngDevMode)&&assertLessThan(options,0,"Only negative numbers are supported here"),this.__NG_ELEMENT_ID__=options):void 0!==options&&(this.ɵprov=ɵɵdefineInjectable({token:this,providedIn:options.providedIn||"root",factory:options.factory}))}get multi(){return this}toString(){return`InjectionToken ${this._desc}`}}let _injectorProfilerContext;function getInjectorProfilerContext(){return!ngDevMode&&throwError("getInjectorProfilerContext should never be called in production mode"),_injectorProfilerContext}function setInjectorProfilerContext(context){!ngDevMode&&throwError("setInjectorProfilerContext should never be called in production mode");const previous=_injectorProfilerContext;return _injectorProfilerContext=context,previous}let injectorProfilerCallback=null;const setInjectorProfiler=injectorProfiler=>{!ngDevMode&&throwError("setInjectorProfiler should never be called in production mode"),injectorProfilerCallback=injectorProfiler};function injectorProfiler(event){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),null!=injectorProfilerCallback&&injectorProfilerCallback(event)}function emitProviderConfiguredEvent(eventProvider,isViewProvider=!1){let token;!ngDevMode&&throwError("Injector profiler should never be called in production mode"),token="function"==typeof eventProvider||eventProvider instanceof InjectionToken?eventProvider:resolveForwardRef(eventProvider.provide);let provider=eventProvider;eventProvider instanceof InjectionToken&&(provider=eventProvider.ɵprov||eventProvider),injectorProfiler({type:2,context:getInjectorProfilerContext(),providerRecord:{token,provider,isViewProvider}})}function emitInstanceCreatedByInjectorEvent(instance){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:1,context:getInjectorProfilerContext(),instance:{value:instance}})}function emitInjectEvent(token,value,flags){!ngDevMode&&throwError("Injector profiler should never be called in production mode"),injectorProfiler({type:0,context:getInjectorProfilerContext(),service:{token,value,flags}})}function runInInjectorProfilerContext(injector,token,callback){!ngDevMode&&throwError("runInInjectorProfilerContext should never be called in production mode");const prevInjectContext=setInjectorProfilerContext({injector,token});try{callback()}finally{setInjectorProfilerContext(prevInjectContext)}}function isEnvironmentProviders(value){return value&&!!value.ɵproviders}const NG_COMP_DEF=getClosureSafeProperty({ɵcmp:getClosureSafeProperty}),NG_DIR_DEF=getClosureSafeProperty({ɵdir:getClosureSafeProperty}),NG_PIPE_DEF=getClosureSafeProperty({ɵpipe:getClosureSafeProperty}),NG_MOD_DEF=getClosureSafeProperty({ɵmod:getClosureSafeProperty}),NG_FACTORY_DEF=getClosureSafeProperty({ɵfac:getClosureSafeProperty}),NG_ELEMENT_ID=getClosureSafeProperty({__NG_ELEMENT_ID__:getClosureSafeProperty}),NG_ENV_ID=getClosureSafeProperty({__NG_ENV_ID__:getClosureSafeProperty});function renderStringify(value){return"string"==typeof value?value:null==value?"":String(value)}function stringifyForError(value){return"function"==typeof value?value.name||value.toString():"object"==typeof value&&null!=value&&"function"==typeof value.type?value.type.name||value.type.toString():renderStringify(value)}function throwCyclicDependencyError(token,path){const depPath=path?`. Dependency path: ${path.join(" > ")} > ${token}`:"";throw new RuntimeError(-200,ngDevMode?`Circular dependency in DI detected for ${token}${depPath}`:token)}function throwMixedMultiProviderError(){throw new Error("Cannot mix multi providers and regular providers")}function throwInvalidProviderError(ngModuleType,providers,provider){if(ngModuleType&&providers){const providerDetail=providers.map((v=>v==provider?"?"+provider+"?":"..."));throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(", ")}]`)}throw isEnvironmentProviders(provider)?provider.ɵfromNgModule?new RuntimeError(207,"Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers."):new RuntimeError(207,"Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers."):new Error("Invalid provider")}function throwProviderNotFoundError(token,injectorName){const errorMessage=ngDevMode&&`No provider for ${stringifyForError(token)} found${injectorName?` in ${injectorName}`:""}`;throw new RuntimeError(-201,errorMessage)}var InjectFlags;let _injectImplementation;function getInjectImplementation(){return _injectImplementation}function setInjectImplementation(impl){const previous=_injectImplementation;return _injectImplementation=impl,previous}function injectRootLimpMode(token,notFoundValue,flags){const injectableDef=getInjectableDef(token);return injectableDef&&"root"==injectableDef.providedIn?void 0===injectableDef.value?injectableDef.value=injectableDef.factory():injectableDef.value:flags&InjectFlags.Optional?null:void 0!==notFoundValue?notFoundValue:void throwProviderNotFoundError(token,"Injector")}!function(InjectFlags){InjectFlags[InjectFlags.Default=0]="Default",InjectFlags[InjectFlags.Host=1]="Host",InjectFlags[InjectFlags.Self=2]="Self",InjectFlags[InjectFlags.SkipSelf=4]="SkipSelf",InjectFlags[InjectFlags.Optional=8]="Optional"}(InjectFlags||(InjectFlags={}));const THROW_IF_NOT_FOUND={},DI_DECORATOR_FLAG="__NG_DI_FLAG__",NEW_LINE=/\n/gm,NO_NEW_LINE="ɵ";let _currentInjector;function setCurrentInjector(injector){const former=_currentInjector;return _currentInjector=injector,former}function injectInjectorOnly(token,flags=InjectFlags.Default){if(void 0===_currentInjector)throw new RuntimeError(-203,ngDevMode&&"inject() must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`.");if(null===_currentInjector)return injectRootLimpMode(token,void 0,flags);{const value=_currentInjector.get(token,flags&InjectFlags.Optional?null:void 0,flags);return ngDevMode&&emitInjectEvent(token,value,flags),value}}function ɵɵinject(token,flags=InjectFlags.Default){return(getInjectImplementation()||injectInjectorOnly)(resolveForwardRef(token),flags)}function ɵɵinvalidFactoryDep(index){throw new RuntimeError(202,ngDevMode&&`This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`)}function inject(token,flags=InjectFlags.Default){return ɵɵinject(token,convertToBitFlags(flags))}function convertToBitFlags(flags){return void 0===flags||"number"==typeof flags?flags:(flags.optional&&8)|(flags.host&&1)|(flags.self&&2)|(flags.skipSelf&&4)}function injectArgs(types){const args=[];for(let i=0;i<types.length;i++){const arg=resolveForwardRef(types[i]);if(Array.isArray(arg)){if(0===arg.length)throw new RuntimeError(900,ngDevMode&&"Arguments array must have arguments.");let type,flags=InjectFlags.Default;for(let j=0;j<arg.length;j++){const meta=arg[j],flag=meta[DI_DECORATOR_FLAG];"number"==typeof flag?-1===flag?type=meta.token:flags|=flag:type=meta}args.push(ɵɵinject(type,flags))}else args.push(ɵɵinject(arg))}return args}function attachInjectFlag(decorator,flag){return decorator[DI_DECORATOR_FLAG]=flag,decorator.prototype[DI_DECORATOR_FLAG]=flag,decorator}function catchInjectorError(e,token,injectorErrorName,source){const tokenPath=e.ngTempTokenPath;throw token.__source&&tokenPath.unshift(token.__source),e.message=function formatError(text,obj,injectorErrorName,source=null){text=text&&"\n"===text.charAt(0)&&text.charAt(1)==NO_NEW_LINE?text.slice(2):text;let context=stringify(obj);if(Array.isArray(obj))context=obj.map(stringify).join(" -> ");else if("object"==typeof obj){let parts=[];for(let key in obj)if(obj.hasOwnProperty(key)){let value=obj[key];parts.push(key+":"+("string"==typeof value?JSON.stringify(value):stringify(value)))}context=`{${parts.join(", ")}}`}return`${injectorErrorName}${source?"("+source+")":""}[${context}]: ${text.replace(NEW_LINE,"\n  ")}`}("\n"+e.message,tokenPath,injectorErrorName,source),e.ngTokenPath=tokenPath,e.ngTempTokenPath=null,e}const Inject=attachInjectFlag(makeParamDecorator("Inject",(token=>({token}))),-1),Optional=attachInjectFlag(makeParamDecorator("Optional"),8),Self=attachInjectFlag(makeParamDecorator("Self"),2),SkipSelf=attachInjectFlag(makeParamDecorator("SkipSelf"),4),Host=attachInjectFlag(makeParamDecorator("Host"),1);function getFactoryDef(type,throwNotFound){const hasFactoryDef=type.hasOwnProperty(NG_FACTORY_DEF);if(!hasFactoryDef&&!0===throwNotFound&&ngDevMode)throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);return hasFactoryDef?type[NG_FACTORY_DEF]:null}function flatten(list){return list.flat(Number.POSITIVE_INFINITY)}function deepForEach(input,fn){input.forEach((value=>Array.isArray(value)?deepForEach(value,fn):fn(value)))}function addToArray(arr,index,value){index>=arr.length?arr.push(value):arr.splice(index,0,value)}function removeFromArray(arr,index){return index>=arr.length-1?arr.pop():arr.splice(index,1)[0]}function newArray(size,value){const list=[];for(let i=0;i<size;i++)list.push(value);return list}function arraySplice(array,index,count){const length=array.length-count;for(;index<length;)array[index]=array[index+count],index++;for(;count--;)array.pop()}function arrayInsert2(array,index,value1,value2){ngDevMode&&assertLessThanOrEqual(index,array.length,"Can't insert past array end.");let end=array.length;if(end==index)array.push(value1,value2);else if(1===end)array.push(value2,array[0]),array[0]=value1;else{for(end--,array.push(array[end-1],array[end]);end>index;){const previousEnd=end-2;array[end]=array[previousEnd],end--}array[index]=value1,array[index+1]=value2}}function keyValueArraySet(keyValueArray,key,value){let index=keyValueArrayIndexOf(keyValueArray,key);return index>=0?keyValueArray[1|index]=value:(index=~index,arrayInsert2(keyValueArray,index,key,value)),index}function keyValueArrayGet(keyValueArray,key){const index=keyValueArrayIndexOf(keyValueArray,key);if(index>=0)return keyValueArray[1|index]}function keyValueArrayIndexOf(keyValueArray,key){return _arrayIndexOfSorted(keyValueArray,key,1)}function _arrayIndexOfSorted(array,value,shift){ngDevMode&&assertEqual(Array.isArray(array),!0,"Expecting an array");let start=0,end=array.length>>shift;for(;end!==start;){const middle=start+(end-start>>1),current=array[middle<<shift];if(value===current)return middle<<shift;current>value?end=middle:start=middle+1}return~(end<<shift)}const EMPTY_OBJ={},EMPTY_ARRAY=[];("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode()&&(Object.freeze(EMPTY_OBJ),Object.freeze(EMPTY_ARRAY));const ENVIRONMENT_INITIALIZER=new InjectionToken(ngDevMode?"ENVIRONMENT_INITIALIZER":""),INJECTOR$1=new InjectionToken(ngDevMode?"INJECTOR":"",-1),INJECTOR_DEF_TYPES=new InjectionToken(ngDevMode?"INJECTOR_DEF_TYPES":"");class NullInjector{get(token,notFoundValue=THROW_IF_NOT_FOUND){if(notFoundValue===THROW_IF_NOT_FOUND){const error=new Error(`NullInjectorError: No provider for ${stringify(token)}!`);throw error.name="NullInjectorError",error}return notFoundValue}}var ChangeDetectionStrategy,ViewEncapsulation$1,InputFlags;function classIndexOf(className,classToSearch,startingIndex){ngDevMode&&assertNotEqual(classToSearch,"",'can not look for "" string.');let end=className.length;for(;;){const foundIndex=className.indexOf(classToSearch,startingIndex);if(-1===foundIndex)return foundIndex;if(0===foundIndex||className.charCodeAt(foundIndex-1)<=32){const length=classToSearch.length;if(foundIndex+length===end||className.charCodeAt(foundIndex+length)<=32)return foundIndex}startingIndex=foundIndex+1}}function setUpAttributes(renderer,native,attrs){let i=0;for(;i<attrs.length;){const value=attrs[i];if("number"==typeof value){if(0!==value)break;i++;const namespaceURI=attrs[i++],attrName=attrs[i++],attrVal=attrs[i++];ngDevMode&&ngDevMode.rendererSetAttribute++,renderer.setAttribute(native,attrName,attrVal,namespaceURI)}else{const attrName=value,attrVal=attrs[++i];ngDevMode&&ngDevMode.rendererSetAttribute++,isAnimationProp(attrName)?renderer.setProperty(native,attrName,attrVal):renderer.setAttribute(native,attrName,attrVal),i++}}return i}function isNameOnlyAttributeMarker(marker){return 3===marker||4===marker||6===marker}function isAnimationProp(name){return 64===name.charCodeAt(0)}function mergeHostAttrs(dst,src){if(null===src||0===src.length);else if(null===dst||0===dst.length)dst=src.slice();else{let srcMarker=-1;for(let i=0;i<src.length;i++){const item=src[i];"number"==typeof item?srcMarker=item:0===srcMarker||mergeHostAttribute(dst,srcMarker,item,null,-1===srcMarker||2===srcMarker?src[++i]:null)}}return dst}function mergeHostAttribute(dst,marker,key1,key2,value){let i=0,markerInsertPosition=dst.length;if(-1===marker)markerInsertPosition=-1;else for(;i<dst.length;){const dstValue=dst[i++];if("number"==typeof dstValue){if(dstValue===marker){markerInsertPosition=-1;break}if(dstValue>marker){markerInsertPosition=i-1;break}}}for(;i<dst.length;){const item=dst[i];if("number"==typeof item)break;if(item===key1){if(null===key2)return void(null!==value&&(dst[i+1]=value));if(key2===dst[i+1])return void(dst[i+2]=value)}i++,null!==key2&&i++,null!==value&&i++}-1!==markerInsertPosition&&(dst.splice(markerInsertPosition,0,marker),i=markerInsertPosition+1),dst.splice(i++,0,key1),null!==key2&&dst.splice(i++,0,key2),null!==value&&dst.splice(i++,0,value)}!function(ChangeDetectionStrategy){ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush=0]="OnPush",ChangeDetectionStrategy[ChangeDetectionStrategy.Default=1]="Default"}(ChangeDetectionStrategy||(ChangeDetectionStrategy={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation$1||(ViewEncapsulation$1={})),function(InputFlags){InputFlags[InputFlags.None=0]="None",InputFlags[InputFlags.SignalBased=1]="SignalBased",InputFlags[InputFlags.HasDecoratorInputTransform=2]="HasDecoratorInputTransform"}(InputFlags||(InputFlags={}));const NG_TEMPLATE_SELECTOR="ng-template";function isCssClassMatching(tNode,attrs,cssClassToMatch,isProjectionMode){ngDevMode&&assertEqual(cssClassToMatch,cssClassToMatch.toLowerCase(),"Class name expected to be lowercase.");let i=0;if(isProjectionMode){for(;i<attrs.length&&"string"==typeof attrs[i];i+=2)if("class"===attrs[i]&&-1!==classIndexOf(attrs[i+1].toLowerCase(),cssClassToMatch,0))return!0}else if(isInlineTemplate(tNode))return!1;if(i=attrs.indexOf(1,i),i>-1){let item;for(;++i<attrs.length&&"string"==typeof(item=attrs[i]);)if(item.toLowerCase()===cssClassToMatch)return!0}return!1}function isInlineTemplate(tNode){return 4===tNode.type&&tNode.value!==NG_TEMPLATE_SELECTOR}function hasTagAndTypeMatch(tNode,currentSelector,isProjectionMode){return currentSelector===(4!==tNode.type||isProjectionMode?tNode.value:NG_TEMPLATE_SELECTOR)}function isNodeMatchingSelector(tNode,selector,isProjectionMode){ngDevMode&&assertDefined(selector[0],"Selector should have a tag name");let mode=4;const nodeAttrs=tNode.attrs,nameOnlyMarkerIdx=null!==nodeAttrs?function getNameOnlyMarkerIndex(nodeAttrs){for(let i=0;i<nodeAttrs.length;i++){if(isNameOnlyAttributeMarker(nodeAttrs[i]))return i}return nodeAttrs.length}(nodeAttrs):0;let skipToNextSelector=!1;for(let i=0;i<selector.length;i++){const current=selector[i];if("number"!=typeof current){if(!skipToNextSelector)if(4&mode){if(mode=2|1&mode,""!==current&&!hasTagAndTypeMatch(tNode,current,isProjectionMode)||""===current&&1===selector.length){if(isPositive(mode))return!1;skipToNextSelector=!0}}else if(8&mode){if(null===nodeAttrs||!isCssClassMatching(tNode,nodeAttrs,current,isProjectionMode)){if(isPositive(mode))return!1;skipToNextSelector=!0}}else{const selectorAttrValue=selector[++i],attrIndexInNode=findAttrIndexInNode(current,nodeAttrs,isInlineTemplate(tNode),isProjectionMode);if(-1===attrIndexInNode){if(isPositive(mode))return!1;skipToNextSelector=!0;continue}if(""!==selectorAttrValue){let nodeAttrValue;if(attrIndexInNode>nameOnlyMarkerIdx?nodeAttrValue="":(ngDevMode&&assertNotEqual(nodeAttrs[attrIndexInNode],0,"We do not match directives on namespaced attributes"),nodeAttrValue=nodeAttrs[attrIndexInNode+1].toLowerCase()),2&mode&&selectorAttrValue!==nodeAttrValue){if(isPositive(mode))return!1;skipToNextSelector=!0}}}}else{if(!skipToNextSelector&&!isPositive(mode)&&!isPositive(current))return!1;if(skipToNextSelector&&isPositive(current))continue;skipToNextSelector=!1,mode=current|1&mode}}return isPositive(mode)||skipToNextSelector}function isPositive(mode){return!(1&mode)}function findAttrIndexInNode(name,attrs,isInlineTemplate,isProjectionMode){if(null===attrs)return-1;let i=0;if(isProjectionMode||!isInlineTemplate){let bindingsMode=!1;for(;i<attrs.length;){const maybeAttrName=attrs[i];if(maybeAttrName===name)return i;if(3===maybeAttrName||6===maybeAttrName)bindingsMode=!0;else{if(1===maybeAttrName||2===maybeAttrName){let value=attrs[++i];for(;"string"==typeof value;)value=attrs[++i];continue}if(4===maybeAttrName)break;if(0===maybeAttrName){i+=4;continue}}i+=bindingsMode?1:2}return-1}return function matchTemplateAttribute(attrs,name){let i=attrs.indexOf(4);if(i>-1)for(i++;i<attrs.length;){const attr=attrs[i];if("number"==typeof attr)return-1;if(attr===name)return i;i++}return-1}(attrs,name)}function isNodeMatchingSelectorList(tNode,selector,isProjectionMode=!1){for(let i=0;i<selector.length;i++)if(isNodeMatchingSelector(tNode,selector[i],isProjectionMode))return!0;return!1}function isSelectorInSelectorList(selector,list){selectorListLoop:for(let i=0;i<list.length;i++){const currentSelectorInList=list[i];if(selector.length===currentSelectorInList.length){for(let j=0;j<selector.length;j++)if(selector[j]!==currentSelectorInList[j])continue selectorListLoop;return!0}}return!1}function maybeWrapInNotSelector(isNegativeMode,chunk){return isNegativeMode?":not("+chunk.trim()+")":chunk}function stringifyCSSSelector(selector){let result=selector[0],i=1,mode=2,currentChunk="",isNegativeMode=!1;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)if(2&mode){const attrValue=selector[++i];currentChunk+="["+valueOrMarker+(attrValue.length>0?'="'+attrValue+'"':"")+"]"}else 8&mode?currentChunk+="."+valueOrMarker:4&mode&&(currentChunk+=" "+valueOrMarker);else""===currentChunk||isPositive(valueOrMarker)||(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk),currentChunk=""),mode=valueOrMarker,isNegativeMode=isNegativeMode||!isPositive(mode);i++}return""!==currentChunk&&(result+=maybeWrapInNotSelector(isNegativeMode,currentChunk)),result}function stringifyCSSSelectorList(selectorList){return selectorList.map(stringifyCSSSelector).join(",")}function ɵɵdefineComponent(componentDefinition){return noSideEffects((()=>{("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode();const baseDef=getNgDirectiveDef(componentDefinition),def={...baseDef,decls:componentDefinition.decls,vars:componentDefinition.vars,template:componentDefinition.template,consts:componentDefinition.consts||null,ngContentSelectors:componentDefinition.ngContentSelectors,onPush:componentDefinition.changeDetection===ChangeDetectionStrategy.OnPush,directiveDefs:null,pipeDefs:null,dependencies:baseDef.standalone&&componentDefinition.dependencies||null,getStandaloneInjector:null,signals:componentDefinition.signals??!1,data:componentDefinition.data||{},encapsulation:componentDefinition.encapsulation||ViewEncapsulation$1.Emulated,styles:componentDefinition.styles||EMPTY_ARRAY,_:null,schemas:componentDefinition.schemas||null,tView:null,id:""};initFeatures(def);const dependencies=componentDefinition.dependencies;return def.directiveDefs=extractDefListOrFactory(dependencies,!1),def.pipeDefs=extractDefListOrFactory(dependencies,!0),def.id=function getComponentId(componentDef){let hash=0;const hashSelectors=[componentDef.selectors,componentDef.ngContentSelectors,componentDef.hostVars,componentDef.hostAttrs,componentDef.consts,componentDef.vars,componentDef.decls,componentDef.encapsulation,componentDef.standalone,componentDef.signals,componentDef.exportAs,JSON.stringify(componentDef.inputs),JSON.stringify(componentDef.outputs),Object.getOwnPropertyNames(componentDef.type.prototype),!!componentDef.contentQueries,!!componentDef.viewQuery].join("|");for(const char of hashSelectors)hash=Math.imul(31,hash)+char.charCodeAt(0)|0;hash+=2147483648;const compId="c"+hash;if("undefined"==typeof ngDevMode||ngDevMode)if(GENERATED_COMP_IDS.has(compId)){const previousCompDefType=GENERATED_COMP_IDS.get(compId);previousCompDefType!==componentDef.type&&console.warn(formatRuntimeError(-912,`Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`))}else GENERATED_COMP_IDS.set(compId,componentDef.type);return compId}(def),def}))}function extractDirectiveDef(type){return getComponentDef(type)||getDirectiveDef(type)}function nonNull(value){return null!==value}function ɵɵdefineNgModule(def){return noSideEffects((()=>({type:def.type,bootstrap:def.bootstrap||EMPTY_ARRAY,declarations:def.declarations||EMPTY_ARRAY,imports:def.imports||EMPTY_ARRAY,exports:def.exports||EMPTY_ARRAY,transitiveCompileScopes:null,schemas:def.schemas||null,id:def.id||null})))}function parseAndConvertBindingsForDefinition(obj,declaredInputs){if(null==obj)return EMPTY_OBJ;const newLookup={};for(const minifiedKey in obj)if(obj.hasOwnProperty(minifiedKey)){const value=obj[minifiedKey];let publicName,declaredName,inputFlags=InputFlags.None;Array.isArray(value)?(inputFlags=value[0],publicName=value[1],declaredName=value[2]??publicName):(publicName=value,declaredName=value),declaredInputs?(newLookup[publicName]=inputFlags!==InputFlags.None?[minifiedKey,inputFlags]:minifiedKey,declaredInputs[publicName]=declaredName):newLookup[publicName]=minifiedKey}return newLookup}function ɵɵdefineDirective(directiveDefinition){return noSideEffects((()=>{const def=getNgDirectiveDef(directiveDefinition);return initFeatures(def),def}))}function ɵɵdefinePipe(pipeDef){return{type:pipeDef.type,name:pipeDef.name,factory:null,pure:!1!==pipeDef.pure,standalone:!0===pipeDef.standalone,onDestroy:pipeDef.type.prototype.ngOnDestroy||null}}function getComponentDef(type){return type[NG_COMP_DEF]||null}function getDirectiveDef(type){return type[NG_DIR_DEF]||null}function getPipeDef$1(type){return type[NG_PIPE_DEF]||null}function isStandalone(type){const def=getComponentDef(type)||getDirectiveDef(type)||getPipeDef$1(type);return null!==def&&def.standalone}function getNgModuleDef(type,throwNotFound){const ngModuleDef=type[NG_MOD_DEF]||null;if(!ngModuleDef&&!0===throwNotFound)throw new Error(`Type ${stringify(type)} does not have 'ɵmod' property.`);return ngModuleDef}function getNgDirectiveDef(directiveDefinition){const declaredInputs={};return{type:directiveDefinition.type,providersResolver:null,factory:null,hostBindings:directiveDefinition.hostBindings||null,hostVars:directiveDefinition.hostVars||0,hostAttrs:directiveDefinition.hostAttrs||null,contentQueries:directiveDefinition.contentQueries||null,declaredInputs,inputTransforms:null,inputConfig:directiveDefinition.inputs||EMPTY_OBJ,exportAs:directiveDefinition.exportAs||null,standalone:!0===directiveDefinition.standalone,signals:!0===directiveDefinition.signals,selectors:directiveDefinition.selectors||EMPTY_ARRAY,viewQuery:directiveDefinition.viewQuery||null,features:directiveDefinition.features||null,setInput:null,findHostDirectiveDefs:null,hostDirectives:null,inputs:parseAndConvertBindingsForDefinition(directiveDefinition.inputs,declaredInputs),outputs:parseAndConvertBindingsForDefinition(directiveDefinition.outputs),debugInfo:null}}function initFeatures(definition){definition.features?.forEach((fn=>fn(definition)))}function extractDefListOrFactory(dependencies,pipeDef){if(!dependencies)return null;const defExtractor=pipeDef?getPipeDef$1:extractDirectiveDef;return()=>("function"==typeof dependencies?dependencies():dependencies).map((dep=>defExtractor(dep))).filter(nonNull)}const GENERATED_COMP_IDS=new Map;function importProvidersFrom(...sources){return{ɵproviders:internalImportProvidersFrom(!0,sources),ɵfromNgModule:!0}}function internalImportProvidersFrom(checkForStandaloneCmp,...sources){const providersOut=[],dedup=new Set;let injectorTypesWithProviders;const collectProviders=provider=>{providersOut.push(provider)};return deepForEach(sources,(source=>{if(("undefined"==typeof ngDevMode||ngDevMode)&&checkForStandaloneCmp){const cmpDef=getComponentDef(source);if(cmpDef?.standalone)throw new RuntimeError(800,`Importing providers supports NgModule or ModuleWithProviders but got a standalone component "${stringifyForError(source)}"`)}const internalSource=source;walkProviderTree(internalSource,collectProviders,[],dedup)&&(injectorTypesWithProviders||=[],injectorTypesWithProviders.push(internalSource))})),void 0!==injectorTypesWithProviders&&processInjectorTypesWithProviders(injectorTypesWithProviders,collectProviders),providersOut}function processInjectorTypesWithProviders(typesWithProviders,visitor){for(let i=0;i<typesWithProviders.length;i++){const{ngModule,providers}=typesWithProviders[i];deepForEachProvider(providers,(provider=>{ngDevMode&&validateProvider(provider,providers||EMPTY_ARRAY,ngModule),visitor(provider,ngModule)}))}}function walkProviderTree(container,visitor,parents,dedup){if(!(container=resolveForwardRef(container)))return!1;let defType=null,injDef=getInjectorDef(container);const cmpDef=!injDef&&getComponentDef(container);if(injDef||cmpDef){if(cmpDef&&!cmpDef.standalone)return!1;defType=container}else{const ngModule=container.ngModule;if(injDef=getInjectorDef(ngModule),!injDef)return!1;defType=ngModule}if(ngDevMode&&-1!==parents.indexOf(defType)){throwCyclicDependencyError(stringify(defType),parents.map(stringify))}const isDuplicate=dedup.has(defType);if(cmpDef){if(isDuplicate)return!1;if(dedup.add(defType),cmpDef.dependencies){const deps="function"==typeof cmpDef.dependencies?cmpDef.dependencies():cmpDef.dependencies;for(const dep of deps)walkProviderTree(dep,visitor,parents,dedup)}}else{if(!injDef)return!1;{if(null!=injDef.imports&&!isDuplicate){let importTypesWithProviders;ngDevMode&&parents.push(defType),dedup.add(defType);try{deepForEach(injDef.imports,(imported=>{walkProviderTree(imported,visitor,parents,dedup)&&(importTypesWithProviders||=[],importTypesWithProviders.push(imported))}))}finally{ngDevMode&&parents.pop()}void 0!==importTypesWithProviders&&processInjectorTypesWithProviders(importTypesWithProviders,visitor)}if(!isDuplicate){const factory=getFactoryDef(defType)||(()=>new defType);visitor({provide:defType,useFactory:factory,deps:EMPTY_ARRAY},defType),visitor({provide:INJECTOR_DEF_TYPES,useValue:defType,multi:!0},defType),visitor({provide:ENVIRONMENT_INITIALIZER,useValue:()=>ɵɵinject(defType),multi:!0},defType)}const defProviders=injDef.providers;if(null!=defProviders&&!isDuplicate){const injectorType=container;deepForEachProvider(defProviders,(provider=>{ngDevMode&&validateProvider(provider,defProviders,injectorType),visitor(provider,injectorType)}))}}}return defType!==container&&void 0!==container.providers}function validateProvider(provider,providers,containerType){if(isTypeProvider(provider)||isValueProvider(provider)||isFactoryProvider(provider)||isExistingProvider(provider))return;resolveForwardRef(provider&&(provider.useClass||provider.provide))||throwInvalidProviderError(containerType,providers,provider)}function deepForEachProvider(providers,fn){for(let provider of providers)isEnvironmentProviders(provider)&&(provider=provider.ɵproviders),Array.isArray(provider)?deepForEachProvider(provider,fn):fn(provider)}const USE_VALUE$1=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isValueProvider(value){return null!==value&&"object"==typeof value&&USE_VALUE$1 in value}function isExistingProvider(value){return!(!value||!value.useExisting)}function isFactoryProvider(value){return!(!value||!value.useFactory)}function isTypeProvider(value){return"function"==typeof value}const INJECTOR_SCOPE=new InjectionToken(ngDevMode?"Set Injector scope.":""),NOT_YET={},CIRCULAR={};let NULL_INJECTOR;function getNullInjector(){return void 0===NULL_INJECTOR&&(NULL_INJECTOR=new NullInjector),NULL_INJECTOR}class EnvironmentInjector{}class R3Injector extends EnvironmentInjector{get destroyed(){return this._destroyed}constructor(providers,parent,source,scopes){super(),this.parent=parent,this.source=source,this.scopes=scopes,this.records=new Map,this._ngOnDestroyHooks=new Set,this._onDestroyHooks=[],this._destroyed=!1,forEachSingleProvider(providers,(provider=>this.processProvider(provider))),this.records.set(INJECTOR$1,makeRecord(void 0,this)),scopes.has("environment")&&this.records.set(EnvironmentInjector,makeRecord(void 0,this));const record=this.records.get(INJECTOR_SCOPE);null!=record&&"string"==typeof record.value&&this.scopes.add(record.value),this.injectorDefTypes=new Set(this.get(INJECTOR_DEF_TYPES,EMPTY_ARRAY,InjectFlags.Self))}destroy(){this.assertNotDestroyed(),this._destroyed=!0;const prevConsumer=setActiveConsumer(null);try{for(const service of this._ngOnDestroyHooks)service.ngOnDestroy();const onDestroyHooks=this._onDestroyHooks;this._onDestroyHooks=[];for(const hook of onDestroyHooks)hook()}finally{this.records.clear(),this._ngOnDestroyHooks.clear(),this.injectorDefTypes.clear(),setActiveConsumer(prevConsumer)}}onDestroy(callback){return this.assertNotDestroyed(),this._onDestroyHooks.push(callback),()=>this.removeOnDestroy(callback)}runInContext(fn){this.assertNotDestroyed();const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{return fn()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}get(token,notFoundValue=THROW_IF_NOT_FOUND,flags=InjectFlags.Default){if(this.assertNotDestroyed(),token.hasOwnProperty(NG_ENV_ID))return token[NG_ENV_ID](this);let prevInjectContext;flags=convertToBitFlags(flags),ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token}));const previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);try{if(!(flags&InjectFlags.SkipSelf)){let record=this.records.get(token);if(void 0===record){const def=function couldBeInjectableType(value){return"function"==typeof value||"object"==typeof value&&value instanceof InjectionToken}(token)&&getInjectableDef(token);def&&this.injectableDefInScope(def)?(ngDevMode&&runInInjectorProfilerContext(this,token,(()=>{emitProviderConfiguredEvent(token)})),record=makeRecord(injectableDefOrInjectorDefFactory(token),NOT_YET)):record=null,this.records.set(token,record)}if(null!=record)return this.hydrate(token,record)}const nextInjector=flags&InjectFlags.Self?getNullInjector():this.parent;return notFoundValue=flags&InjectFlags.Optional&&notFoundValue===THROW_IF_NOT_FOUND?null:notFoundValue,nextInjector.get(token,notFoundValue)}catch(e){if("NullInjectorError"===e.name){if((e.ngTempTokenPath=e.ngTempTokenPath||[]).unshift(stringify(token)),previousInjector)throw e;return catchInjectorError(e,token,"R3InjectorError",this.source)}throw e}finally{setInjectImplementation(previousInjectImplementation),setCurrentInjector(previousInjector),ngDevMode&&setInjectorProfilerContext(prevInjectContext)}}resolveInjectorInitializers(){const prevConsumer=setActiveConsumer(null),previousInjector=setCurrentInjector(this),previousInjectImplementation=setInjectImplementation(void 0);let prevInjectContext;ngDevMode&&(prevInjectContext=setInjectorProfilerContext({injector:this,token:null}));try{const initializers=this.get(ENVIRONMENT_INITIALIZER,EMPTY_ARRAY,InjectFlags.Self);if(ngDevMode&&!Array.isArray(initializers))throw new RuntimeError(-209,`Unexpected type of the \`ENVIRONMENT_INITIALIZER\` token value (expected an array, but got ${typeof initializers}). Please check that the \`ENVIRONMENT_INITIALIZER\` token is configured as a \`multi: true\` provider.`);for(const initializer of initializers)initializer()}finally{setCurrentInjector(previousInjector),setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(prevInjectContext),setActiveConsumer(prevConsumer)}}toString(){const tokens=[],records=this.records;for(const token of records.keys())tokens.push(stringify(token));return`R3Injector[${tokens.join(", ")}]`}assertNotDestroyed(){if(this._destroyed)throw new RuntimeError(205,ngDevMode&&"Injector has already been destroyed.")}processProvider(provider){let token=isTypeProvider(provider=resolveForwardRef(provider))?provider:resolveForwardRef(provider&&provider.provide);const record=function providerToRecord(provider){if(isValueProvider(provider))return makeRecord(void 0,provider.useValue);return makeRecord(providerToFactory(provider),NOT_YET)}(provider);if(ngDevMode&&runInInjectorProfilerContext(this,token,(()=>{isValueProvider(provider)&&emitInstanceCreatedByInjectorEvent(provider.useValue),emitProviderConfiguredEvent(provider)})),isTypeProvider(provider)||!0!==provider.multi){if(ngDevMode){const existing=this.records.get(token);existing&&void 0!==existing.multi&&throwMixedMultiProviderError()}}else{let multiRecord=this.records.get(token);multiRecord?ngDevMode&&void 0===multiRecord.multi&&throwMixedMultiProviderError():(multiRecord=makeRecord(void 0,NOT_YET,!0),multiRecord.factory=()=>injectArgs(multiRecord.multi),this.records.set(token,multiRecord)),token=provider,multiRecord.multi.push(provider)}this.records.set(token,record)}hydrate(token,record){const prevConsumer=setActiveConsumer(null);try{return ngDevMode&&record.value===CIRCULAR?throwCyclicDependencyError(stringify(token)):record.value===NOT_YET&&(record.value=CIRCULAR,ngDevMode?runInInjectorProfilerContext(this,token,(()=>{record.value=record.factory(),emitInstanceCreatedByInjectorEvent(record.value)})):record.value=record.factory()),"object"==typeof record.value&&record.value&&function hasOnDestroy(value){return null!==value&&"object"==typeof value&&"function"==typeof value.ngOnDestroy}(record.value)&&this._ngOnDestroyHooks.add(record.value),record.value}finally{setActiveConsumer(prevConsumer)}}injectableDefInScope(def){if(!def.providedIn)return!1;const providedIn=resolveForwardRef(def.providedIn);return"string"==typeof providedIn?"any"===providedIn||this.scopes.has(providedIn):this.injectorDefTypes.has(providedIn)}removeOnDestroy(callback){const destroyCBIdx=this._onDestroyHooks.indexOf(callback);-1!==destroyCBIdx&&this._onDestroyHooks.splice(destroyCBIdx,1)}}function injectableDefOrInjectorDefFactory(token){const injectableDef=getInjectableDef(token),factory=null!==injectableDef?injectableDef.factory:getFactoryDef(token);if(null!==factory)return factory;if(token instanceof InjectionToken)throw new RuntimeError(204,ngDevMode&&`Token ${stringify(token)} is missing a ɵprov definition.`);if(token instanceof Function)return function getUndecoratedInjectableFactory(token){const paramLength=token.length;if(paramLength>0)throw new RuntimeError(204,ngDevMode&&`Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength,"?").join(", ")}).`);const inheritedInjectableDef=function getInheritedInjectableDef(type){const def=type&&(type[NG_PROV_DEF]||type[NG_INJECTABLE_DEF]);return def?(ngDevMode&&console.warn(`DEPRECATED: DI is instantiating a token "${type.name}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${type.name}" class.`),def):null}(token);return null!==inheritedInjectableDef?()=>inheritedInjectableDef.factory(token):()=>new token}(token);throw new RuntimeError(204,ngDevMode&&"unreachable")}function providerToFactory(provider,ngModuleType,providers){let factory;if(ngDevMode&&isEnvironmentProviders(provider)&&throwInvalidProviderError(void 0,providers,provider),isTypeProvider(provider)){const unwrappedProvider=resolveForwardRef(provider);return getFactoryDef(unwrappedProvider)||injectableDefOrInjectorDefFactory(unwrappedProvider)}if(isValueProvider(provider))factory=()=>resolveForwardRef(provider.useValue);else if(isFactoryProvider(provider))factory=()=>provider.useFactory(...injectArgs(provider.deps||[]));else if(isExistingProvider(provider))factory=()=>ɵɵinject(resolveForwardRef(provider.useExisting));else{const classRef=resolveForwardRef(provider&&(provider.useClass||provider.provide));if(ngDevMode&&!classRef&&throwInvalidProviderError(ngModuleType,providers,provider),!function hasDeps(value){return!!value.deps}(provider))return getFactoryDef(classRef)||injectableDefOrInjectorDefFactory(classRef);factory=()=>new classRef(...injectArgs(provider.deps))}return factory}function makeRecord(factory,value,multi=!1){return{factory,value,multi:multi?[]:void 0}}function forEachSingleProvider(providers,fn){for(const provider of providers)Array.isArray(provider)?forEachSingleProvider(provider,fn):provider&&isEnvironmentProviders(provider)?forEachSingleProvider(provider.ɵproviders,fn):fn(provider)}function isInInjectionContext(){return void 0!==getInjectImplementation()||null!=function getCurrentInjector(){return _currentInjector}()}function assertInInjectionContext(debugFn){if(!isInInjectionContext())throw new RuntimeError(-203,ngDevMode&&debugFn.name+"() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`")}var FactoryTarget,R3TemplateDependencyKind,ViewEncapsulation;function getCompilerFacade(request){const globalNg=_global.ng;if(globalNg&&globalNg.ɵcompilerFacade)return globalNg.ɵcompilerFacade;if("undefined"==typeof ngDevMode||ngDevMode){console.error(`JIT compilation failed for ${request.kind}`,request.type);let message=`The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;throw 1===request.usage?(message+=`The ${request.kind} is part of a library that has been partially compiled.\n`,message+="However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n",message+="\n",message+="Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n"):message+="JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n",message+="Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n",message+="or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.",new Error(message)}throw new Error("JIT compiler unavailable")}!function(FactoryTarget){FactoryTarget[FactoryTarget.Directive=0]="Directive",FactoryTarget[FactoryTarget.Component=1]="Component",FactoryTarget[FactoryTarget.Injectable=2]="Injectable",FactoryTarget[FactoryTarget.Pipe=3]="Pipe",FactoryTarget[FactoryTarget.NgModule=4]="NgModule"}(FactoryTarget||(FactoryTarget={})),function(R3TemplateDependencyKind){R3TemplateDependencyKind[R3TemplateDependencyKind.Directive=0]="Directive",R3TemplateDependencyKind[R3TemplateDependencyKind.Pipe=1]="Pipe",R3TemplateDependencyKind[R3TemplateDependencyKind.NgModule=2]="NgModule"}(R3TemplateDependencyKind||(R3TemplateDependencyKind={})),function(ViewEncapsulation){ViewEncapsulation[ViewEncapsulation.Emulated=0]="Emulated",ViewEncapsulation[ViewEncapsulation.None=2]="None",ViewEncapsulation[ViewEncapsulation.ShadowDom=3]="ShadowDom"}(ViewEncapsulation||(ViewEncapsulation={}));const angularCoreDiEnv={ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵinject,ɵɵinvalidFactoryDep,resolveForwardRef},Type=Function;function isType(v){return"function"==typeof v}const ES5_DELEGATE_CTOR=/^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|(?:[^()]+\(\[\],)?[^()]+\(arguments\).*)\)/,ES2015_INHERITED_CLASS=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,ES2015_INHERITED_CLASS_WITH_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR=/^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{[^}]*super\(\.\.\.arguments\)/;class ReflectionCapabilities{constructor(reflect){this._reflect=reflect||_global.Reflect}factory(t){return(...args)=>new t(...args)}_zipTypesAndAnnotations(paramTypes,paramAnnotations){let result;result=newArray(void 0===paramTypes?paramAnnotations.length:paramTypes.length);for(let i=0;i<result.length;i++)void 0===paramTypes?result[i]=[]:paramTypes[i]&&paramTypes[i]!=Object?result[i]=[paramTypes[i]]:result[i]=[],paramAnnotations&&null!=paramAnnotations[i]&&(result[i]=result[i].concat(paramAnnotations[i]));return result}_ownParameters(type,parentCtor){if(function isDelegateCtor(typeStr){return ES5_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr)||ES2015_INHERITED_CLASS.test(typeStr)&&!ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)}(type.toString()))return null;if(type.parameters&&type.parameters!==parentCtor.parameters)return type.parameters;const tsickleCtorParams=type.ctorParameters;if(tsickleCtorParams&&tsickleCtorParams!==parentCtor.ctorParameters){const ctorParameters="function"==typeof tsickleCtorParams?tsickleCtorParams():tsickleCtorParams,paramTypes=ctorParameters.map((ctorParam=>ctorParam&&ctorParam.type)),paramAnnotations=ctorParameters.map((ctorParam=>ctorParam&&convertTsickleDecoratorIntoMetadata(ctorParam.decorators)));return this._zipTypesAndAnnotations(paramTypes,paramAnnotations)}const paramAnnotations=type.hasOwnProperty(PARAMETERS)&&type[PARAMETERS],paramTypes=this._reflect&&this._reflect.getOwnMetadata&&this._reflect.getOwnMetadata("design:paramtypes",type);return paramTypes||paramAnnotations?this._zipTypesAndAnnotations(paramTypes,paramAnnotations):newArray(type.length)}parameters(type){if(!isType(type))return[];const parentCtor=getParentCtor(type);let parameters=this._ownParameters(type,parentCtor);return parameters||parentCtor===Object||(parameters=this.parameters(parentCtor)),parameters||[]}_ownAnnotations(typeOrFunc,parentCtor){if(typeOrFunc.annotations&&typeOrFunc.annotations!==parentCtor.annotations){let annotations=typeOrFunc.annotations;return"function"==typeof annotations&&annotations.annotations&&(annotations=annotations.annotations),annotations}return typeOrFunc.decorators&&typeOrFunc.decorators!==parentCtor.decorators?convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators):typeOrFunc.hasOwnProperty(ANNOTATIONS)?typeOrFunc[ANNOTATIONS]:null}annotations(typeOrFunc){if(!isType(typeOrFunc))return[];const parentCtor=getParentCtor(typeOrFunc),ownAnnotations=this._ownAnnotations(typeOrFunc,parentCtor)||[];return(parentCtor!==Object?this.annotations(parentCtor):[]).concat(ownAnnotations)}_ownPropMetadata(typeOrFunc,parentCtor){if(typeOrFunc.propMetadata&&typeOrFunc.propMetadata!==parentCtor.propMetadata){let propMetadata=typeOrFunc.propMetadata;return"function"==typeof propMetadata&&propMetadata.propMetadata&&(propMetadata=propMetadata.propMetadata),propMetadata}if(typeOrFunc.propDecorators&&typeOrFunc.propDecorators!==parentCtor.propDecorators){const propDecorators=typeOrFunc.propDecorators,propMetadata={};return Object.keys(propDecorators).forEach((prop=>{propMetadata[prop]=convertTsickleDecoratorIntoMetadata(propDecorators[prop])})),propMetadata}return typeOrFunc.hasOwnProperty(PROP_METADATA)?typeOrFunc[PROP_METADATA]:null}propMetadata(typeOrFunc){if(!isType(typeOrFunc))return{};const parentCtor=getParentCtor(typeOrFunc),propMetadata={};if(parentCtor!==Object){const parentPropMetadata=this.propMetadata(parentCtor);Object.keys(parentPropMetadata).forEach((propName=>{propMetadata[propName]=parentPropMetadata[propName]}))}const ownPropMetadata=this._ownPropMetadata(typeOrFunc,parentCtor);return ownPropMetadata&&Object.keys(ownPropMetadata).forEach((propName=>{const decorators=[];propMetadata.hasOwnProperty(propName)&&decorators.push(...propMetadata[propName]),decorators.push(...ownPropMetadata[propName]),propMetadata[propName]=decorators})),propMetadata}ownPropMetadata(typeOrFunc){return isType(typeOrFunc)&&this._ownPropMetadata(typeOrFunc,getParentCtor(typeOrFunc))||{}}hasLifecycleHook(type,lcProperty){return type instanceof Type&&lcProperty in type.prototype}}function convertTsickleDecoratorIntoMetadata(decoratorInvocations){return decoratorInvocations?decoratorInvocations.map((decoratorInvocation=>new(0,decoratorInvocation.type.annotationCls)(...decoratorInvocation.args?decoratorInvocation.args:[]))):[]}function getParentCtor(ctor){const parentProto=ctor.prototype?Object.getPrototypeOf(ctor.prototype):null;return(parentProto?parentProto.constructor:null)||Object}const HOST=0,TVIEW=1,FLAGS=2,PARENT=3,NEXT=4,T_HOST=5,HYDRATION=6,CLEANUP=7,CONTEXT=8,INJECTOR=9,ENVIRONMENT=10,RENDERER=11,CHILD_HEAD=12,CHILD_TAIL=13,DECLARATION_VIEW=14,DECLARATION_COMPONENT_VIEW=15,DECLARATION_LCONTAINER=16,PREORDER_HOOK_FLAGS=17,QUERIES=18,ID=19,EMBEDDED_VIEW_INJECTOR=20,ON_DESTROY_HOOKS=21,EFFECTS_TO_SCHEDULE=22,REACTIVE_TEMPLATE_CONSUMER=23,HEADER_OFFSET=25,TYPE=1,NATIVE=7,MOVED_VIEWS=9,CONTAINER_HEADER_OFFSET=10;var LContainerFlags;function isLView(value){return Array.isArray(value)&&"object"==typeof value[TYPE]}function isLContainer(value){return Array.isArray(value)&&!0===value[TYPE]}function isContentQueryHost(tNode){return!!(4&tNode.flags)}function isComponentHost(tNode){return tNode.componentOffset>-1}function isDirectiveHost(tNode){return!(1&~tNode.flags)}function isComponentDef(def){return!!def.template}function isRootView(target){return!!(512&target[FLAGS])}function isDestroyed(lView){return!(256&~lView[FLAGS])}function assertTNodeForLView(tNode,lView){assertTNodeForTView(tNode,lView[TVIEW])}function assertTNodeForTView(tNode,tView){assertTNode(tNode);const tData=tView.data;for(let i=HEADER_OFFSET;i<tData.length;i++)if(tData[i]===tNode)return;throwError("This TNode does not belong to this TView.")}function assertTNode(tNode){assertDefined(tNode,"TNode must be defined"),tNode&&"object"==typeof tNode&&tNode.hasOwnProperty("directiveStylingLast")||throwError("Not of type TNode, got: "+tNode)}function assertTIcu(tIcu){assertDefined(tIcu,"Expected TIcu to be defined"),"number"!=typeof tIcu.currentCaseLViewIndex&&throwError("Object is not of TIcu type.")}function assertHasParent(tNode){assertDefined(tNode,"currentTNode should exist!"),assertDefined(tNode.parent,"currentTNode should have a parent")}function assertLContainer(value){assertDefined(value,"LContainer must be defined"),assertEqual(isLContainer(value),!0,"Expecting LContainer")}function assertLViewOrUndefined(value){value&&assertEqual(isLView(value),!0,"Expecting LView or undefined or null")}function assertLView(value){assertDefined(value,"LView must be defined"),assertEqual(isLView(value),!0,"Expecting LView")}function assertFirstCreatePass(tView,errMessage){assertEqual(tView.firstCreatePass,!0,errMessage||"Should only be called in first create pass.")}function assertFirstUpdatePass(tView,errMessage){assertEqual(tView.firstUpdatePass,!0,errMessage||"Should only be called in first update pass.")}function assertIndexInDeclRange(tView,index){assertBetween(HEADER_OFFSET,tView.bindingStartIndex,index)}function assertIndexInExpandoRange(lView,index){assertBetween(lView[1].expandoStartIndex,lView.length,index)}function assertBetween(lower,upper,index){lower<=index&&index<upper||throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`)}function assertParentView(lView,errMessage){assertDefined(lView,errMessage||"Component views should always have a parent view (component's host view)")}function assertNoDuplicateDirectives(directives){if(directives.length<2)return;const seenDirectives=new Set;for(const current of directives){if(seenDirectives.has(current))throw new RuntimeError(309,`Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);seenDirectives.add(current)}}function assertNodeInjector(lView,injectorIndex){assertIndexInExpandoRange(lView,injectorIndex),assertIndexInExpandoRange(lView,injectorIndex+8),assertNumber(lView[injectorIndex+0],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+1],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+2],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+3],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+4],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+5],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+6],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+7],"injectorIndex should point to a bloom filter"),assertNumber(lView[injectorIndex+8],"injectorIndex should point to parent injector")}!function(LContainerFlags){LContainerFlags[LContainerFlags.None=0]="None",LContainerFlags[LContainerFlags.HasTransplantedViews=2]="HasTransplantedViews"}(LContainerFlags||(LContainerFlags={}));class SimpleChange{constructor(previousValue,currentValue,firstChange){this.previousValue=previousValue,this.currentValue=currentValue,this.firstChange=firstChange}isFirstChange(){return this.firstChange}}function applyValueToInputField(instance,inputSignalNode,privateName,value){null!==inputSignalNode?inputSignalNode.applyValueToInputSignal(inputSignalNode,value):instance[privateName]=value}function ɵɵNgOnChangesFeature(){return NgOnChangesFeatureImpl}function NgOnChangesFeatureImpl(definition){return definition.type.prototype.ngOnChanges&&(definition.setInput=ngOnChangesSetInput),rememberChangeHistoryAndInvokeOnChangesHook}function rememberChangeHistoryAndInvokeOnChangesHook(){const simpleChangesStore=getSimpleChangesStore(this),current=simpleChangesStore?.current;if(current){const previous=simpleChangesStore.previous;if(previous===EMPTY_OBJ)simpleChangesStore.previous=current;else for(let key in current)previous[key]=current[key];simpleChangesStore.current=null,this.ngOnChanges(current)}}function ngOnChangesSetInput(instance,inputSignalNode,value,publicName,privateName){const declaredName=this.declaredInputs[publicName];ngDevMode&&assertString(declaredName,"Name of input in ngOnChanges has to be a string");const simpleChangesStore=getSimpleChangesStore(instance)||function setSimpleChangesStore(instance,store){return instance[SIMPLE_CHANGES_STORE]=store}(instance,{previous:EMPTY_OBJ,current:null}),current=simpleChangesStore.current||(simpleChangesStore.current={}),previous=simpleChangesStore.previous,previousChange=previous[declaredName];current[declaredName]=new SimpleChange(previousChange&&previousChange.currentValue,value,previous===EMPTY_OBJ),applyValueToInputField(instance,inputSignalNode,privateName,value)}ɵɵNgOnChangesFeature.ngInherit=!0;const SIMPLE_CHANGES_STORE="__ngSimpleChanges__";function getSimpleChangesStore(instance){return instance[SIMPLE_CHANGES_STORE]||null}let profilerCallback=null;const profiler=function(event,instance,hookOrListener){null!=profilerCallback&&profilerCallback(event,instance,hookOrListener)};let _ensureDirtyViewsAreAlwaysReachable=!1;function unwrapRNode(value){for(;Array.isArray(value);)value=value[HOST];return value}function unwrapLView(value){for(;Array.isArray(value);){if("object"==typeof value[TYPE])return value;value=value[HOST]}return null}function getNativeByIndex(index,lView){return ngDevMode&&assertIndexInRange(lView,index),ngDevMode&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"Expected to be past HEADER_OFFSET"),unwrapRNode(lView[index])}function getNativeByTNode(tNode,lView){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertIndexInRange(lView,tNode.index);return unwrapRNode(lView[tNode.index])}function getTNode(tView,index){ngDevMode&&assertGreaterThan(index,-1,"wrong index for TNode"),ngDevMode&&assertLessThan(index,tView.data.length,"wrong index for TNode");const tNode=tView.data[index];return ngDevMode&&null!==tNode&&assertTNode(tNode),tNode}function load(view,index){return ngDevMode&&assertIndexInRange(view,index),view[index]}function getComponentLViewByIndex(nodeIndex,hostView){ngDevMode&&assertIndexInRange(hostView,nodeIndex);const slotValue=hostView[nodeIndex];return isLView(slotValue)?slotValue:slotValue[HOST]}function isCreationMode(view){return!(4&~view[FLAGS])}function viewAttachedToChangeDetector(view){return!(128&~view[FLAGS])}function getConstant(consts,index){return null==index?null:(ngDevMode&&assertIndexInRange(consts,index),consts[index])}function resetPreOrderHookFlags(lView){lView[PREORDER_HOOK_FLAGS]=0}function markViewForRefresh(lView){1024&lView[FLAGS]||(lView[FLAGS]|=1024,viewAttachedToChangeDetector(lView)&&markAncestorsForTraversal(lView))}function walkUpViews(nestingLevel,currentView){for(;nestingLevel>0;)ngDevMode&&assertDefined(currentView[DECLARATION_VIEW],"Declaration view should be defined if nesting level is greater than 0."),currentView=currentView[DECLARATION_VIEW],nestingLevel--;return currentView}function requiresRefreshOrTraversal(lView){return!!(9216&lView[FLAGS]||lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty)}function updateAncestorTraversalFlagsOnAttach(lView){lView[ENVIRONMENT].changeDetectionScheduler?.notify(1),requiresRefreshOrTraversal(lView)?markAncestorsForTraversal(lView):64&lView[FLAGS]&&(!function getEnsureDirtyViewsAreAlwaysReachable(){return _ensureDirtyViewsAreAlwaysReachable}()?lView[ENVIRONMENT].changeDetectionScheduler?.notify():(lView[FLAGS]|=1024,markAncestorsForTraversal(lView)))}function markAncestorsForTraversal(lView){lView[ENVIRONMENT].changeDetectionScheduler?.notify();let parent=getLViewParent(lView);for(;null!==parent&&!(8192&parent[FLAGS])&&(parent[FLAGS]|=8192,viewAttachedToChangeDetector(parent));)parent=getLViewParent(parent)}function storeLViewOnDestroy(lView,onDestroyCallback){if(!(256&~lView[FLAGS]))throw new RuntimeError(911,ngDevMode&&"View has already been destroyed.");null===lView[ON_DESTROY_HOOKS]&&(lView[ON_DESTROY_HOOKS]=[]),lView[ON_DESTROY_HOOKS].push(onDestroyCallback)}function removeLViewOnDestroy(lView,onDestroyCallback){if(null===lView[ON_DESTROY_HOOKS])return;const destroyCBIdx=lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);-1!==destroyCBIdx&&lView[ON_DESTROY_HOOKS].splice(destroyCBIdx,1)}function getLViewParent(lView){ngDevMode&&assertLView(lView);const parent=lView[PARENT];return isLContainer(parent)?parent[PARENT]:parent}const instructionState={lFrame:createLFrame(null),bindingsEnabled:!0,skipHydrationRootTNode:null};let _isInCheckNoChangesMode=!1;function getBindingsEnabled(){return instructionState.bindingsEnabled}function isInSkipHydrationBlock$1(){return null!==instructionState.skipHydrationRootTNode}function ɵɵenableBindings(){instructionState.bindingsEnabled=!0}function ɵɵdisableBindings(){instructionState.bindingsEnabled=!1}function getLView(){return instructionState.lFrame.lView}function getTView(){return instructionState.lFrame.tView}function ɵɵrestoreView(viewToRestore){return instructionState.lFrame.contextLView=viewToRestore,viewToRestore[CONTEXT]}function ɵɵresetView(value){return instructionState.lFrame.contextLView=null,value}function getCurrentTNode(){let currentTNode=getCurrentTNodePlaceholderOk();for(;null!==currentTNode&&64===currentTNode.type;)currentTNode=currentTNode.parent;return currentTNode}function getCurrentTNodePlaceholderOk(){return instructionState.lFrame.currentTNode}function getCurrentParentTNode(){const lFrame=instructionState.lFrame,currentTNode=lFrame.currentTNode;return lFrame.isParent?currentTNode:currentTNode.parent}function setCurrentTNode(tNode,isParent){ngDevMode&&tNode&&assertTNodeForTView(tNode,instructionState.lFrame.tView);const lFrame=instructionState.lFrame;lFrame.currentTNode=tNode,lFrame.isParent=isParent}function isCurrentTNodeParent(){return instructionState.lFrame.isParent}function setCurrentTNodeAsNotParent(){instructionState.lFrame.isParent=!1}function isInCheckNoChangesMode(){return!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode}function setIsInCheckNoChangesMode(mode){!ngDevMode&&throwError("Must never be called in production mode"),_isInCheckNoChangesMode=mode}function getBindingRoot(){const lFrame=instructionState.lFrame;let index=lFrame.bindingRootIndex;return-1===index&&(index=lFrame.bindingRootIndex=lFrame.tView.bindingStartIndex),index}function getBindingIndex(){return instructionState.lFrame.bindingIndex}function setBindingIndex(value){return instructionState.lFrame.bindingIndex=value}function nextBindingIndex(){return instructionState.lFrame.bindingIndex++}function incrementBindingIndex(count){const lFrame=instructionState.lFrame,index=lFrame.bindingIndex;return lFrame.bindingIndex=lFrame.bindingIndex+count,index}function setInI18nBlock(isInI18nBlock){instructionState.lFrame.inI18n=isInI18nBlock}function setBindingRootForHostBindings(bindingRootIndex,currentDirectiveIndex){const lFrame=instructionState.lFrame;lFrame.bindingIndex=lFrame.bindingRootIndex=bindingRootIndex,setCurrentDirectiveIndex(currentDirectiveIndex)}function setCurrentDirectiveIndex(currentDirectiveIndex){instructionState.lFrame.currentDirectiveIndex=currentDirectiveIndex}function getCurrentDirectiveDef(tData){const currentDirectiveIndex=instructionState.lFrame.currentDirectiveIndex;return-1===currentDirectiveIndex?null:tData[currentDirectiveIndex]}function getCurrentQueryIndex(){return instructionState.lFrame.currentQueryIndex}function setCurrentQueryIndex(value){instructionState.lFrame.currentQueryIndex=value}function getDeclarationTNode(lView){const tView=lView[TVIEW];return 2===tView.type?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tView.type?lView[T_HOST]:null}function enterDI(lView,tNode,flags){if(ngDevMode&&assertLViewOrUndefined(lView),flags&InjectFlags.SkipSelf){ngDevMode&&assertTNodeForTView(tNode,lView[TVIEW]);let parentTNode=tNode,parentLView=lView;for(;!(ngDevMode&&assertDefined(parentTNode,"Parent TNode should be defined"),parentTNode=parentTNode.parent,null!==parentTNode||flags&InjectFlags.Host||(parentTNode=getDeclarationTNode(parentLView),null===parentTNode)||(ngDevMode&&assertDefined(parentLView,"Parent LView should be defined"),parentLView=parentLView[DECLARATION_VIEW],10&parentTNode.type)););if(null===parentTNode)return!1;tNode=parentTNode,lView=parentLView}ngDevMode&&assertTNodeForLView(tNode,lView);const lFrame=instructionState.lFrame=allocLFrame();return lFrame.currentTNode=tNode,lFrame.lView=lView,!0}function enterView(newView){ngDevMode&&assertNotEqual(newView[0],newView[1],"????"),ngDevMode&&assertLViewOrUndefined(newView);const newLFrame=allocLFrame();ngDevMode&&(assertEqual(newLFrame.isParent,!0,"Expected clean LFrame"),assertEqual(newLFrame.lView,null,"Expected clean LFrame"),assertEqual(newLFrame.tView,null,"Expected clean LFrame"),assertEqual(newLFrame.selectedIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.elementDepthCount,0,"Expected clean LFrame"),assertEqual(newLFrame.currentDirectiveIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentNamespace,null,"Expected clean LFrame"),assertEqual(newLFrame.bindingRootIndex,-1,"Expected clean LFrame"),assertEqual(newLFrame.currentQueryIndex,0,"Expected clean LFrame"));const tView=newView[TVIEW];instructionState.lFrame=newLFrame,ngDevMode&&tView.firstChild&&assertTNodeForTView(tView.firstChild,tView),newLFrame.currentTNode=tView.firstChild,newLFrame.lView=newView,newLFrame.tView=tView,newLFrame.contextLView=newView,newLFrame.bindingIndex=tView.bindingStartIndex,newLFrame.inI18n=!1}function allocLFrame(){const currentLFrame=instructionState.lFrame,childLFrame=null===currentLFrame?null:currentLFrame.child;return null===childLFrame?createLFrame(currentLFrame):childLFrame}function createLFrame(parent){const lFrame={currentTNode:null,isParent:!0,lView:null,tView:null,selectedIndex:-1,contextLView:null,elementDepthCount:0,currentNamespace:null,currentDirectiveIndex:-1,bindingRootIndex:-1,bindingIndex:-1,currentQueryIndex:0,parent,child:null,inI18n:!1};return null!==parent&&(parent.child=lFrame),lFrame}function leaveViewLight(){const oldLFrame=instructionState.lFrame;return instructionState.lFrame=oldLFrame.parent,oldLFrame.currentTNode=null,oldLFrame.lView=null,oldLFrame}const leaveDI=leaveViewLight;function leaveView(){const oldLFrame=leaveViewLight();oldLFrame.isParent=!0,oldLFrame.tView=null,oldLFrame.selectedIndex=-1,oldLFrame.contextLView=null,oldLFrame.elementDepthCount=0,oldLFrame.currentDirectiveIndex=-1,oldLFrame.currentNamespace=null,oldLFrame.bindingRootIndex=-1,oldLFrame.bindingIndex=-1,oldLFrame.currentQueryIndex=0}function getSelectedIndex(){return instructionState.lFrame.selectedIndex}function setSelectedIndex(index){ngDevMode&&-1!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"Index must be past HEADER_OFFSET (or -1)."),ngDevMode&&assertLessThan(index,instructionState.lFrame.lView.length,"Can't set index passed end of LView"),instructionState.lFrame.selectedIndex=index}function getSelectedTNode(){const lFrame=instructionState.lFrame;return getTNode(lFrame.tView,lFrame.selectedIndex)}function ɵɵnamespaceSVG(){instructionState.lFrame.currentNamespace="svg"}function ɵɵnamespaceMathML(){instructionState.lFrame.currentNamespace="math"}function ɵɵnamespaceHTML(){!function namespaceHTMLInternal(){instructionState.lFrame.currentNamespace=null}()}function getNamespace$1(){return instructionState.lFrame.currentNamespace}let _wasLastNodeCreated=!0;function wasLastNodeCreated(){return _wasLastNodeCreated}function lastNodeWasCreated(flag){_wasLastNodeCreated=flag}function registerPostOrderHooks(tView,tNode){ngDevMode&&assertFirstCreatePass(tView);for(let i=tNode.directiveStart,end=tNode.directiveEnd;i<end;i++){const directiveDef=tView.data[i];ngDevMode&&assertDefined(directiveDef,"Expecting DirectiveDef");const lifecycleHooks=directiveDef.type.prototype,{ngAfterContentInit,ngAfterContentChecked,ngAfterViewInit,ngAfterViewChecked,ngOnDestroy}=lifecycleHooks;ngAfterContentInit&&(tView.contentHooks??=[]).push(-i,ngAfterContentInit),ngAfterContentChecked&&((tView.contentHooks??=[]).push(i,ngAfterContentChecked),(tView.contentCheckHooks??=[]).push(i,ngAfterContentChecked)),ngAfterViewInit&&(tView.viewHooks??=[]).push(-i,ngAfterViewInit),ngAfterViewChecked&&((tView.viewHooks??=[]).push(i,ngAfterViewChecked),(tView.viewCheckHooks??=[]).push(i,ngAfterViewChecked)),null!=ngOnDestroy&&(tView.destroyHooks??=[]).push(i,ngOnDestroy)}}function executeCheckHooks(lView,hooks,nodeIndex){callHooks(lView,hooks,3,nodeIndex)}function executeInitAndCheckHooks(lView,hooks,initPhase,nodeIndex){ngDevMode&&assertNotEqual(initPhase,3,"Init pre-order hooks should not be called more than once"),(3&lView[FLAGS])===initPhase&&callHooks(lView,hooks,initPhase,nodeIndex)}function incrementInitPhaseFlags(lView,initPhase){ngDevMode&&assertNotEqual(initPhase,3,"Init hooks phase should not be incremented after all init hooks have been run.");let flags=lView[FLAGS];(3&flags)===initPhase&&(flags&=16383,flags+=1,lView[FLAGS]=flags)}function callHooks(currentView,arr,initPhase,currentNodeIndex){ngDevMode&&assertEqual(isInCheckNoChangesMode(),!1,"Hooks should never be run when in check no changes mode.");const startIndex=void 0!==currentNodeIndex?65535&currentView[PREORDER_HOOK_FLAGS]:0,nodeIndexLimit=null!=currentNodeIndex?currentNodeIndex:-1,max=arr.length-1;let lastNodeIndexFound=0;for(let i=startIndex;i<max;i++){if("number"==typeof arr[i+1]){if(lastNodeIndexFound=arr[i],null!=currentNodeIndex&&lastNodeIndexFound>=currentNodeIndex)break}else{arr[i]<0&&(currentView[PREORDER_HOOK_FLAGS]+=65536),(lastNodeIndexFound<nodeIndexLimit||-1==nodeIndexLimit)&&(callHook(currentView,initPhase,arr,i),currentView[PREORDER_HOOK_FLAGS]=(4294901760&currentView[PREORDER_HOOK_FLAGS])+i+2),i++}}}function callHookInternal(directive,hook){profiler(4,directive,hook);const prevConsumer=setActiveConsumer(null);try{hook.call(directive)}finally{setActiveConsumer(prevConsumer),profiler(5,directive,hook)}}function callHook(currentView,initPhase,arr,i){const isInitHook=arr[i]<0,hook=arr[i+1],directive=currentView[isInitHook?-arr[i]:arr[i]];if(isInitHook){currentView[FLAGS]>>14<currentView[PREORDER_HOOK_FLAGS]>>16&&(3&currentView[FLAGS])===initPhase&&(currentView[FLAGS]+=16384,callHookInternal(directive,hook))}else callHookInternal(directive,hook)}const NO_PARENT_INJECTOR=-1;class NodeInjectorFactory{constructor(factory,isViewProvider,injectImplementation){this.factory=factory,this.resolving=!1,ngDevMode&&assertDefined(factory,"Factory not specified"),ngDevMode&&assertEqual(typeof factory,"function","Expected factory function."),this.canSeeViewProviders=isViewProvider,this.injectImpl=injectImplementation}}function toTNodeTypeAsString(tNodeType){let text="";return 1&tNodeType&&(text+="|Text"),2&tNodeType&&(text+="|Element"),4&tNodeType&&(text+="|Container"),8&tNodeType&&(text+="|ElementContainer"),16&tNodeType&&(text+="|Projection"),32&tNodeType&&(text+="|IcuContainer"),64&tNodeType&&(text+="|Placeholder"),text.length>0?text.substring(1):text}function assertTNodeType(tNode,expectedTypes,message){assertDefined(tNode,"should be called with a TNode"),tNode.type&expectedTypes||throwError(message||`Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`)}function hasParentInjector(parentLocation){return parentLocation!==NO_PARENT_INJECTOR}function getParentInjectorIndex(parentLocation){if(ngDevMode){assertNumber(parentLocation,"Number expected"),assertNotEqual(parentLocation,-1,"Not a valid state.");assertGreaterThan(32767&parentLocation,HEADER_OFFSET,"Parent injector must be pointing past HEADER_OFFSET.")}return 32767&parentLocation}function getParentInjectorView(location,startView){let viewOffset=function getParentInjectorViewOffset(parentLocation){return parentLocation>>16}(location),parentView=startView;for(;viewOffset>0;)parentView=parentView[DECLARATION_VIEW],viewOffset--;return parentView}let includeViewProviders=!0;function setIncludeViewProviders(v){const oldValue=includeViewProviders;return includeViewProviders=v,oldValue}const BLOOM_MASK=255,BLOOM_BUCKET_BITS=5;let nextNgElementId=0;const NOT_FOUND={};function getOrCreateNodeInjectorForNode(tNode,lView){const existingInjectorIndex=getInjectorIndex(tNode,lView);if(-1!==existingInjectorIndex)return existingInjectorIndex;const tView=lView[TVIEW];tView.firstCreatePass&&(tNode.injectorIndex=lView.length,insertBloom(tView.data,tNode),insertBloom(lView,null),insertBloom(tView.blueprint,null));const parentLoc=getParentInjectorLocation(tNode,lView),injectorIndex=tNode.injectorIndex;if(hasParentInjector(parentLoc)){const parentIndex=getParentInjectorIndex(parentLoc),parentLView=getParentInjectorView(parentLoc,lView),parentData=parentLView[TVIEW].data;for(let i=0;i<8;i++)lView[injectorIndex+i]=parentLView[parentIndex+i]|parentData[parentIndex+i]}return lView[injectorIndex+8]=parentLoc,injectorIndex}function insertBloom(arr,footer){arr.push(0,0,0,0,0,0,0,0,footer)}function getInjectorIndex(tNode,lView){return-1===tNode.injectorIndex||tNode.parent&&tNode.parent.injectorIndex===tNode.injectorIndex||null===lView[tNode.injectorIndex+8]?-1:(ngDevMode&&assertIndexInRange(lView,tNode.injectorIndex),tNode.injectorIndex)}function getParentInjectorLocation(tNode,lView){if(tNode.parent&&-1!==tNode.parent.injectorIndex)return tNode.parent.injectorIndex;let declarationViewOffset=0,parentTNode=null,lViewCursor=lView;for(;null!==lViewCursor;){if(parentTNode=getTNodeFromLView(lViewCursor),null===parentTNode)return NO_PARENT_INJECTOR;if(ngDevMode&&parentTNode&&assertTNodeForLView(parentTNode,lViewCursor[DECLARATION_VIEW]),declarationViewOffset++,lViewCursor=lViewCursor[DECLARATION_VIEW],-1!==parentTNode.injectorIndex)return parentTNode.injectorIndex|declarationViewOffset<<16}return NO_PARENT_INJECTOR}function diPublicInInjector(injectorIndex,tView,token){!function bloomAdd(injectorIndex,tView,type){let id;ngDevMode&&assertEqual(tView.firstCreatePass,!0,"expected firstCreatePass to be true"),"string"==typeof type?id=type.charCodeAt(0)||0:type.hasOwnProperty(NG_ELEMENT_ID)&&(id=type[NG_ELEMENT_ID]),null==id&&(id=type[NG_ELEMENT_ID]=nextNgElementId++);const bloomHash=id&BLOOM_MASK,mask=1<<bloomHash;tView.data[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]|=mask}(injectorIndex,tView,token)}function notFoundValueOrThrow(notFoundValue,token,flags){if(flags&InjectFlags.Optional||void 0!==notFoundValue)return notFoundValue;throwProviderNotFoundError(token,"NodeInjector")}function lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue){if(flags&InjectFlags.Optional&&void 0===notFoundValue&&(notFoundValue=null),!(flags&(InjectFlags.Self|InjectFlags.Host))){const moduleInjector=lView[INJECTOR],previousInjectImplementation=setInjectImplementation(void 0);try{return moduleInjector?moduleInjector.get(token,notFoundValue,flags&InjectFlags.Optional):injectRootLimpMode(token,notFoundValue,flags&InjectFlags.Optional)}finally{setInjectImplementation(previousInjectImplementation)}}return notFoundValueOrThrow(notFoundValue,token,flags)}function getOrCreateInjectable(tNode,lView,token,flags=InjectFlags.Default,notFoundValue){if(null!==tNode){if(2048&lView[FLAGS]&&!(flags&InjectFlags.Self)){const embeddedInjectorValue=function lookupTokenUsingEmbeddedInjector(tNode,lView,token,flags,notFoundValue){let currentTNode=tNode,currentLView=lView;for(;null!==currentTNode&&null!==currentLView&&2048&currentLView[FLAGS]&&!(512&currentLView[FLAGS]);){ngDevMode&&assertTNodeForLView(currentTNode,currentLView);const nodeInjectorValue=lookupTokenUsingNodeInjector(currentTNode,currentLView,token,flags|InjectFlags.Self,NOT_FOUND);if(nodeInjectorValue!==NOT_FOUND)return nodeInjectorValue;let parentTNode=currentTNode.parent;if(!parentTNode){const embeddedViewInjector=currentLView[EMBEDDED_VIEW_INJECTOR];if(embeddedViewInjector){const embeddedViewInjectorValue=embeddedViewInjector.get(token,NOT_FOUND,flags);if(embeddedViewInjectorValue!==NOT_FOUND)return embeddedViewInjectorValue}parentTNode=getTNodeFromLView(currentLView),currentLView=currentLView[DECLARATION_VIEW]}currentTNode=parentTNode}return notFoundValue}(tNode,lView,token,flags,NOT_FOUND);if(embeddedInjectorValue!==NOT_FOUND)return embeddedInjectorValue}const value=lookupTokenUsingNodeInjector(tNode,lView,token,flags,NOT_FOUND);if(value!==NOT_FOUND)return value}return lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue)}function lookupTokenUsingNodeInjector(tNode,lView,token,flags,notFoundValue){const bloomHash=function bloomHashBitOrFactory(token){if(ngDevMode&&assertDefined(token,"token must be defined"),"string"==typeof token)return token.charCodeAt(0)||0;const tokenId=token.hasOwnProperty(NG_ELEMENT_ID)?token[NG_ELEMENT_ID]:void 0;return"number"==typeof tokenId?tokenId>=0?tokenId&BLOOM_MASK:(ngDevMode&&assertEqual(tokenId,-1,"Expecting to get Special Injector Id"),createNodeInjector):tokenId}(token);if("function"==typeof bloomHash){if(!enterDI(lView,tNode,flags))return flags&InjectFlags.Host?notFoundValueOrThrow(notFoundValue,token,flags):lookupTokenUsingModuleInjector(lView,token,flags,notFoundValue);try{let value;if(ngDevMode?runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(),getLView()),token,(()=>{value=bloomHash(flags),null!=value&&emitInstanceCreatedByInjectorEvent(value)})):value=bloomHash(flags),null!=value||flags&InjectFlags.Optional)return value;throwProviderNotFoundError(token)}finally{leaveDI()}}else if("number"==typeof bloomHash){let previousTView=null,injectorIndex=getInjectorIndex(tNode,lView),parentLocation=NO_PARENT_INJECTOR,hostTElementNode=flags&InjectFlags.Host?lView[DECLARATION_COMPONENT_VIEW][T_HOST]:null;for((-1===injectorIndex||flags&InjectFlags.SkipSelf)&&(parentLocation=-1===injectorIndex?getParentInjectorLocation(tNode,lView):lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,!1)?(previousTView=lView[TVIEW],injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1);-1!==injectorIndex;){ngDevMode&&assertNodeInjector(lView,injectorIndex);const tView=lView[TVIEW];if(ngDevMode&&assertTNodeForLView(tView.data[injectorIndex+8],lView),bloomHasToken(bloomHash,injectorIndex,tView.data)){const instance=searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode);if(instance!==NOT_FOUND)return instance}parentLocation=lView[injectorIndex+8],parentLocation!==NO_PARENT_INJECTOR&&shouldSearchParent(flags,lView[TVIEW].data[injectorIndex+8]===hostTElementNode)&&bloomHasToken(bloomHash,injectorIndex,lView)?(previousTView=tView,injectorIndex=getParentInjectorIndex(parentLocation),lView=getParentInjectorView(parentLocation,lView)):injectorIndex=-1}}return notFoundValue}function searchTokensOnInjector(injectorIndex,lView,token,previousTView,flags,hostTElementNode){const currentTView=lView[TVIEW],tNode=currentTView.data[injectorIndex+8],injectableIdx=locateDirectiveOrProvider(tNode,currentTView,token,null==previousTView?isComponentHost(tNode)&&includeViewProviders:previousTView!=currentTView&&!!(3&tNode.type),flags&InjectFlags.Host&&hostTElementNode===tNode);return null!==injectableIdx?getNodeInjectable(lView,currentTView,injectableIdx,tNode):NOT_FOUND}function locateDirectiveOrProvider(tNode,tView,token,canAccessViewProviders,isHostSpecialCase){const nodeProviderIndexes=tNode.providerIndexes,tInjectables=tView.data,injectablesStart=1048575&nodeProviderIndexes,directivesStart=tNode.directiveStart,directiveEnd=tNode.directiveEnd,cptViewProvidersCount=nodeProviderIndexes>>20,endIndex=isHostSpecialCase?injectablesStart+cptViewProvidersCount:directiveEnd;for(let i=canAccessViewProviders?injectablesStart:injectablesStart+cptViewProvidersCount;i<endIndex;i++){const providerTokenOrDef=tInjectables[i];if(i<directivesStart&&token===providerTokenOrDef||i>=directivesStart&&providerTokenOrDef.type===token)return i}if(isHostSpecialCase){const dirDef=tInjectables[directivesStart];if(dirDef&&isComponentDef(dirDef)&&dirDef.type===token)return directivesStart}return null}function getNodeInjectable(lView,tView,index,tNode){let value=lView[index];const tData=tView.data;if(function isFactory(obj){return obj instanceof NodeInjectorFactory}(value)){const factory=value;factory.resolving&&throwCyclicDependencyError(stringifyForError(tData[index]));const previousIncludeViewProviders=setIncludeViewProviders(factory.canSeeViewProviders);let prevInjectContext;if(factory.resolving=!0,ngDevMode){const token=tData[index].type||tData[index];prevInjectContext=setInjectorProfilerContext({injector:new NodeInjector(tNode,lView),token})}const previousInjectImplementation=factory.injectImpl?setInjectImplementation(factory.injectImpl):null,success=enterDI(lView,tNode,InjectFlags.Default);ngDevMode&&assertEqual(success,!0,"Because flags do not contain `SkipSelf' we expect this to always succeed.");try{value=lView[index]=factory.factory(void 0,tData,lView,tNode),ngDevMode&&emitInstanceCreatedByInjectorEvent(value),tView.firstCreatePass&&index>=tNode.directiveStart&&(ngDevMode&&function assertDirectiveDef(obj){void 0!==obj.type&&null!=obj.selectors&&void 0!==obj.inputs||throwError("Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.")}(tData[index]),function registerPreOrderHooks(directiveIndex,directiveDef,tView){ngDevMode&&assertFirstCreatePass(tView);const{ngOnChanges,ngOnInit,ngDoCheck}=directiveDef.type.prototype;if(ngOnChanges){const wrappedOnChanges=NgOnChangesFeatureImpl(directiveDef);(tView.preOrderHooks??=[]).push(directiveIndex,wrappedOnChanges),(tView.preOrderCheckHooks??=[]).push(directiveIndex,wrappedOnChanges)}ngOnInit&&(tView.preOrderHooks??=[]).push(0-directiveIndex,ngOnInit),ngDoCheck&&((tView.preOrderHooks??=[]).push(directiveIndex,ngDoCheck),(tView.preOrderCheckHooks??=[]).push(directiveIndex,ngDoCheck))}(index,tData[index],tView))}finally{ngDevMode&&setInjectorProfilerContext(prevInjectContext),null!==previousInjectImplementation&&setInjectImplementation(previousInjectImplementation),setIncludeViewProviders(previousIncludeViewProviders),factory.resolving=!1,leaveDI()}}return value}function bloomHasToken(bloomHash,injectorIndex,injectorView){const mask=1<<bloomHash;return!!(injectorView[injectorIndex+(bloomHash>>BLOOM_BUCKET_BITS)]&mask)}function shouldSearchParent(flags,isFirstHostTNode){return!(flags&InjectFlags.Self||flags&InjectFlags.Host&&isFirstHostTNode)}function getNodeInjectorLView(nodeInjector){return nodeInjector._lView}function getNodeInjectorTNode(nodeInjector){return nodeInjector._tNode}class NodeInjector{constructor(_tNode,_lView){this._tNode=_tNode,this._lView=_lView}get(token,notFoundValue,flags){return getOrCreateInjectable(this._tNode,this._lView,token,convertToBitFlags(flags),notFoundValue)}}function createNodeInjector(){return new NodeInjector(getCurrentTNode(),getLView())}function ɵɵgetInheritedFactory(type){return noSideEffects((()=>{const ownConstructor=type.prototype.constructor,ownFactory=ownConstructor[NG_FACTORY_DEF]||getFactoryOf(ownConstructor),objectPrototype=Object.prototype;let parent=Object.getPrototypeOf(type.prototype).constructor;for(;parent&&parent!==objectPrototype;){const factory=parent[NG_FACTORY_DEF]||getFactoryOf(parent);if(factory&&factory!==ownFactory)return factory;parent=Object.getPrototypeOf(parent)}return t=>new t}))}function getFactoryOf(type){return isForwardRef(type)?()=>{const factory=getFactoryOf(resolveForwardRef(type));return factory&&factory()}:getFactoryDef(type)}function getTNodeFromLView(lView){const tView=lView[TVIEW],tViewType=tView.type;return 2===tViewType?(ngDevMode&&assertDefined(tView.declTNode,"Embedded TNodes should have declaration parents."),tView.declTNode):1===tViewType?lView[T_HOST]:null}function ɵɵinjectAttribute(attrNameToInject){return function injectAttributeImpl(tNode,attrNameToInject){if(ngDevMode&&assertTNodeType(tNode,15),ngDevMode&&assertDefined(tNode,"expecting tNode"),"class"===attrNameToInject)return tNode.classes;if("style"===attrNameToInject)return tNode.styles;const attrs=tNode.attrs;if(attrs){const attrsLength=attrs.length;let i=0;for(;i<attrsLength;){const value=attrs[i];if(isNameOnlyAttributeMarker(value))break;if(0===value)i+=2;else if("number"==typeof value)for(i++;i<attrsLength&&"string"==typeof attrs[i];)i++;else{if(value===attrNameToInject)return attrs[i+1];i+=2}}}return null}(getCurrentTNode(),attrNameToInject)}const Attribute=makeParamDecorator("Attribute",(attributeName=>({attributeName,__NG_ELEMENT_ID__:()=>ɵɵinjectAttribute(attributeName)})));let _reflect=null;function getReflect(){return _reflect=_reflect||new ReflectionCapabilities}function reflectDependencies(type){return convertDependencies(getReflect().parameters(type))}function convertDependencies(deps){return deps.map((dep=>function reflectDependency(dep){const meta={token:null,attribute:null,host:!1,optional:!1,self:!1,skipSelf:!1};if(Array.isArray(dep)&&dep.length>0)for(let j=0;j<dep.length;j++){const param=dep[j];if(void 0===param)continue;const proto=Object.getPrototypeOf(param);if(param instanceof Optional||"Optional"===proto.ngMetadataName)meta.optional=!0;else if(param instanceof SkipSelf||"SkipSelf"===proto.ngMetadataName)meta.skipSelf=!0;else if(param instanceof Self||"Self"===proto.ngMetadataName)meta.self=!0;else if(param instanceof Host||"Host"===proto.ngMetadataName)meta.host=!0;else if(param instanceof Inject)meta.token=param.token;else if(param instanceof Attribute){if(void 0===param.attributeName)throw new RuntimeError(204,ngDevMode&&"Attribute name must be defined.");meta.attribute=param.attributeName}else meta.token=param}else void 0===dep||Array.isArray(dep)&&0===dep.length?meta.token=null:meta.token=dep;return meta}(dep)))}function compileInjectable(type,meta){let ngInjectableDef=null,ngFactoryDef=null;type.hasOwnProperty(NG_PROV_DEF)||Object.defineProperty(type,NG_PROV_DEF,{get:()=>{if(null===ngInjectableDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngInjectableDef=compiler.compileInjectable(angularCoreDiEnv,`ng:///${type.name}/ɵprov.js`,function getInjectableMetadata(type,srcMeta){const meta=srcMeta||{providedIn:null},compilerMeta={name:type.name,type,typeArgumentCount:0,providedIn:meta.providedIn};(isUseClassProvider(meta)||isUseFactoryProvider(meta))&&void 0!==meta.deps&&(compilerMeta.deps=convertDependencies(meta.deps));isUseClassProvider(meta)?compilerMeta.useClass=meta.useClass:!function isUseValueProvider(meta){return USE_VALUE in meta}(meta)?isUseFactoryProvider(meta)?compilerMeta.useFactory=meta.useFactory:function isUseExistingProvider(meta){return void 0!==meta.useExisting}(meta)&&(compilerMeta.useExisting=meta.useExisting):compilerMeta.useValue=meta.useValue;return compilerMeta}(type,meta))}return ngInjectableDef}}),type.hasOwnProperty(NG_FACTORY_DEF)||Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=getCompilerFacade({usage:0,kind:"injectable",type});ngFactoryDef=compiler.compileFactory(angularCoreDiEnv,`ng:///${type.name}/ɵfac.js`,{name:type.name,type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Injectable})}return ngFactoryDef},configurable:!0})}const USE_VALUE=getClosureSafeProperty({provide:String,useValue:getClosureSafeProperty});function isUseClassProvider(meta){return void 0!==meta.useClass}function isUseFactoryProvider(meta){return void 0!==meta.useFactory}const Injectable=makeDecorator("Injectable",void 0,void 0,void 0,((type,meta)=>compileInjectable(type,meta)));function createInjector(defType,parent=null,additionalProviders=null,name){const injector=createInjectorWithoutInjectorInstances(defType,parent,additionalProviders,name);return injector.resolveInjectorInitializers(),injector}function createInjectorWithoutInjectorInstances(defType,parent=null,additionalProviders=null,name,scopes=new Set){const providers=[additionalProviders||EMPTY_ARRAY,importProvidersFrom(defType)];return name=name||("object"==typeof defType?void 0:stringify(defType)),new R3Injector(providers,parent||getNullInjector(),name||null,scopes)}class Injector{static#_=this.THROW_IF_NOT_FOUND=THROW_IF_NOT_FOUND;static#_2=this.NULL=new NullInjector;static create(options,parent){if(Array.isArray(options))return createInjector({name:""},parent,options,"");{const name=options.name??"";return createInjector({name},options.parent,options.providers,name)}}static#_3=this.ɵprov=ɵɵdefineInjectable({token:Injector,providedIn:"any",factory:()=>ɵɵinject(INJECTOR$1)});static#_4=this.__NG_ELEMENT_ID__=-1}function getOriginalError(error){return error.ngOriginalError}class ErrorHandler{constructor(){this._console=console}handleError(error){const originalError=this._findOriginalError(error);this._console.error("ERROR",error),originalError&&this._console.error("ORIGINAL ERROR",originalError)}_findOriginalError(error){let e=error&&getOriginalError(error);for(;e&&getOriginalError(e);)e=getOriginalError(e);return e||null}}const INTERNAL_APPLICATION_ERROR_HANDLER=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"internal error handler":"",{providedIn:"root",factory:()=>inject(ErrorHandler).handleError.bind(void 0)});class DestroyRef{static#_=this.__NG_ELEMENT_ID__=injectDestroyRef;static#_2=this.__NG_ENV_ID__=injector=>injector}class NodeInjectorDestroyRef extends DestroyRef{constructor(_lView){super(),this._lView=_lView}onDestroy(callback){return storeLViewOnDestroy(this._lView,callback),()=>removeLViewOnDestroy(this._lView,callback)}}function injectDestroyRef(){return new NodeInjectorDestroyRef(getLView())}class OutputEmitterRef{constructor(){this.destroyed=!1,this.listeners=null,this.errorHandler=inject(ErrorHandler,{optional:!0}),this.destroyRef=inject(DestroyRef),this.destroyRef.onDestroy((()=>{this.destroyed=!0,this.listeners=null}))}subscribe(callback){if(this.destroyed)throw new RuntimeError(953,ngDevMode&&"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.");return(this.listeners??=[]).push(callback),{unsubscribe:()=>{const idx=this.listeners?.indexOf(callback);void 0!==idx&&-1!==idx&&this.listeners?.splice(idx,1)}}}emit(value){if(this.destroyed)throw new RuntimeError(953,ngDevMode&&"Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.");if(null===this.listeners)return;const previousConsumer=setActiveConsumer(null);try{for(const listenerFn of this.listeners)try{listenerFn(value)}catch(err){this.errorHandler?.handleError(err)}}finally{setActiveConsumer(previousConsumer)}}}function inputFunction(initialValue,opts){return ngDevMode&&assertInInjectionContext(input),createInputSignal(initialValue,opts)}function inputRequiredFunction(opts){return ngDevMode&&assertInInjectionContext(input),createInputSignal(REQUIRED_UNSET_VALUE,opts)}const input=(inputFunction.required=inputRequiredFunction,inputFunction);function injectElementRef(){return createElementRef(getCurrentTNode(),getLView())}function createElementRef(tNode,lView){return new ElementRef(getNativeByTNode(tNode,lView))}class ElementRef{constructor(nativeElement){this.nativeElement=nativeElement}static#_=this.__NG_ELEMENT_ID__=injectElementRef}function unwrapElementRef(value){return value instanceof ElementRef?value.nativeElement:value}class EventEmitter_ extends Subject.B{constructor(isAsync=!1){super(),this.destroyRef=void 0,this.__isAsync=isAsync,isInInjectionContext()&&(this.destroyRef=inject(DestroyRef,{optional:!0})??void 0)}emit(value){const prevConsumer=setActiveConsumer(null);try{super.next(value)}finally{setActiveConsumer(prevConsumer)}}subscribe(observerOrNext,error,complete){let nextFn=observerOrNext,errorFn=error||(()=>null),completeFn=complete;if(observerOrNext&&"object"==typeof observerOrNext){const observer=observerOrNext;nextFn=observer.next?.bind(observer),errorFn=observer.error?.bind(observer),completeFn=observer.complete?.bind(observer)}this.__isAsync&&(errorFn=_wrapInTimeout(errorFn),nextFn&&(nextFn=_wrapInTimeout(nextFn)),completeFn&&(completeFn=_wrapInTimeout(completeFn)));const sink=super.subscribe({next:nextFn,error:errorFn,complete:completeFn});return observerOrNext instanceof Subscription.yU&&observerOrNext.add(sink),sink}}function _wrapInTimeout(fn){return value=>{setTimeout(fn,void 0,value)}}const EventEmitter=EventEmitter_;function symbolIterator(){return this._results[Symbol.iterator]()}class QueryList{static#_=Symbol.iterator;get changes(){return this._changes??=new EventEmitter}constructor(_emitDistinctChangesOnly=!1){this._emitDistinctChangesOnly=_emitDistinctChangesOnly,this.dirty=!0,this._onDirty=void 0,this._results=[],this._changesDetected=!1,this._changes=void 0,this.length=0,this.first=void 0,this.last=void 0;const proto=QueryList.prototype;proto[Symbol.iterator]||(proto[Symbol.iterator]=symbolIterator)}get(index){return this._results[index]}map(fn){return this._results.map(fn)}filter(fn){return this._results.filter(fn)}find(fn){return this._results.find(fn)}reduce(fn,init){return this._results.reduce(fn,init)}forEach(fn){this._results.forEach(fn)}some(fn){return this._results.some(fn)}toArray(){return this._results.slice()}toString(){return this._results.toString()}reset(resultsTree,identityAccessor){this.dirty=!1;const newResultFlat=flatten(resultsTree);(this._changesDetected=!function arrayEquals(a,b,identityAccessor){if(a.length!==b.length)return!1;for(let i=0;i<a.length;i++){let valueA=a[i],valueB=b[i];if(identityAccessor&&(valueA=identityAccessor(valueA),valueB=identityAccessor(valueB)),valueB!==valueA)return!1}return!0}(this._results,newResultFlat,identityAccessor))&&(this._results=newResultFlat,this.length=newResultFlat.length,this.last=newResultFlat[this.length-1],this.first=newResultFlat[0])}notifyOnChanges(){void 0===this._changes||!this._changesDetected&&this._emitDistinctChangesOnly||this._changes.emit(this)}onDirty(cb){this._onDirty=cb}setDirty(){this.dirty=!0,this._onDirty?.()}destroy(){void 0!==this._changes&&(this._changes.complete(),this._changes.unsubscribe())}}function hasInSkipHydrationBlockFlag(tNode){return!(128&~tNode.flags)}const TRACKED_LVIEWS=new Map;let uniqueIdCounter=0;function getLViewById(id){return ngDevMode&&assertNumber(id,"ID used for LView lookup must be a number"),TRACKED_LVIEWS.get(id)||null}class LContext{get lView(){return getLViewById(this.lViewId)}constructor(lViewId,nodeIndex,native){this.lViewId=lViewId,this.nodeIndex=nodeIndex,this.native=native}}function getLContext(target){let mpValue=readPatchedData(target);if(mpValue){if(isLView(mpValue)){const lView=mpValue;let nodeIndex,component,directives;if(isComponentInstance(target)){if(nodeIndex=findViaComponent(lView,target),-1==nodeIndex)throw new Error("The provided component was not found in the application");component=target}else if(function isDirectiveInstance(instance){return instance&&instance.constructor&&instance.constructor.ɵdir}(target)){if(nodeIndex=function findViaDirective(lView,directiveInstance){let tNode=lView[TVIEW].firstChild;for(;tNode;){const directiveIndexStart=tNode.directiveStart,directiveIndexEnd=tNode.directiveEnd;for(let i=directiveIndexStart;i<directiveIndexEnd;i++)if(lView[i]===directiveInstance)return tNode.index;tNode=traverseNextElement(tNode)}return-1}(lView,target),-1==nodeIndex)throw new Error("The provided directive was not found in the application");directives=getDirectivesAtNodeIndex(nodeIndex,lView)}else if(nodeIndex=findViaNativeElement(lView,target),-1==nodeIndex)return null;const native=unwrapRNode(lView[nodeIndex]),existingCtx=readPatchedData(native),context=existingCtx&&!Array.isArray(existingCtx)?existingCtx:createLContext(lView,nodeIndex,native);if(component&&void 0===context.component&&(context.component=component,attachPatchData(context.component,context)),directives&&void 0===context.directives){context.directives=directives;for(let i=0;i<directives.length;i++)attachPatchData(directives[i],context)}attachPatchData(context.native,context),mpValue=context}}else{const rElement=target;ngDevMode&&assertDomNode(rElement);let parent=rElement;for(;parent=parent.parentNode;){const parentContext=readPatchedData(parent);if(parentContext){const lView=Array.isArray(parentContext)?parentContext:parentContext.lView;if(!lView)return null;const index=findViaNativeElement(lView,rElement);if(index>=0){const native=unwrapRNode(lView[index]),context=createLContext(lView,index,native);attachPatchData(native,context),mpValue=context;break}}}}return mpValue||null}function createLContext(lView,nodeIndex,native){return new LContext(lView[ID],nodeIndex,native)}function getComponentViewByInstance(componentInstance){let lView,patchedData=readPatchedData(componentInstance);if(isLView(patchedData)){const contextLView=patchedData,nodeIndex=findViaComponent(contextLView,componentInstance);lView=getComponentLViewByIndex(nodeIndex,contextLView);const context=createLContext(contextLView,nodeIndex,lView[HOST]);context.component=componentInstance,attachPatchData(componentInstance,context),attachPatchData(context.native,context)}else{const context=patchedData,contextLView=context.lView;ngDevMode&&assertLView(contextLView),lView=getComponentLViewByIndex(context.nodeIndex,contextLView)}return lView}const MONKEY_PATCH_KEY_NAME="__ngContext__";function attachPatchData(target,data){ngDevMode&&assertDefined(target,"Target expected"),isLView(data)?(target[MONKEY_PATCH_KEY_NAME]=data[ID],function registerLView(lView){ngDevMode&&assertNumber(lView[ID],"LView must have an ID in order to be registered"),TRACKED_LVIEWS.set(lView[ID],lView)}(data)):target[MONKEY_PATCH_KEY_NAME]=data}function readPatchedData(target){ngDevMode&&assertDefined(target,"Target expected");const data=target[MONKEY_PATCH_KEY_NAME];return"number"==typeof data?getLViewById(data):data||null}function readPatchedLView(target){const value=readPatchedData(target);return value?isLView(value)?value:value.lView:null}function isComponentInstance(instance){return instance&&instance.constructor&&instance.constructor.ɵcmp}function findViaNativeElement(lView,target){const tView=lView[TVIEW];for(let i=HEADER_OFFSET;i<tView.bindingStartIndex;i++)if(unwrapRNode(lView[i])===target)return i;return-1}function traverseNextElement(tNode){if(tNode.child)return tNode.child;if(tNode.next)return tNode.next;for(;tNode.parent&&!tNode.parent.next;)tNode=tNode.parent;return tNode.parent&&tNode.parent.next}function findViaComponent(lView,componentInstance){const componentIndices=lView[TVIEW].components;if(componentIndices)for(let i=0;i<componentIndices.length;i++){const elementComponentIndex=componentIndices[i];if(getComponentLViewByIndex(elementComponentIndex,lView)[CONTEXT]===componentInstance)return elementComponentIndex}else{if(getComponentLViewByIndex(HEADER_OFFSET,lView)[CONTEXT]===componentInstance)return HEADER_OFFSET}return-1}function getDirectivesAtNodeIndex(nodeIndex,lView){const tNode=lView[TVIEW].data[nodeIndex];if(0===tNode.directiveStart)return EMPTY_ARRAY;const results=[];for(let i=tNode.directiveStart;i<tNode.directiveEnd;i++){const directiveInstance=lView[i];isComponentInstance(directiveInstance)||results.push(directiveInstance)}return results}function getRootContext(viewOrComponent){const rootView=function getRootView(componentOrLView){ngDevMode&&assertDefined(componentOrLView,"component");let lView=isLView(componentOrLView)?componentOrLView:readPatchedLView(componentOrLView);for(;lView&&!(512&lView[FLAGS]);)lView=getLViewParent(lView);return ngDevMode&&assertLView(lView),lView}(viewOrComponent);return ngDevMode&&assertDefined(rootView[CONTEXT],"Root view has no context. Perhaps it is disconnected?"),rootView[CONTEXT]}function getFirstLContainer(lView){return getNearestLContainer(lView[CHILD_HEAD])}function getNextLContainer(container){return getNearestLContainer(container[NEXT])}function getNearestLContainer(viewOrContainer){for(;null!==viewOrContainer&&!isLContainer(viewOrContainer);)viewOrContainer=viewOrContainer[NEXT];return viewOrContainer}function getComponent$1(element){ngDevMode&&assertDomElement(element);const context=getLContext(element);if(null===context)return null;if(void 0===context.component){const lView=context.lView;if(null===lView)return null;context.component=function getComponentAtNodeIndex(nodeIndex,lView){const tNode=lView[TVIEW].data[nodeIndex],{directiveStart,componentOffset}=tNode;return componentOffset>-1?lView[directiveStart+componentOffset]:null}(context.nodeIndex,lView)}return context.component}function getContext(element){assertDomElement(element);const context=getLContext(element),lView=context?context.lView:null;return null===lView?null:lView[CONTEXT]}function getOwningComponent(elementOrDir){const context=getLContext(elementOrDir);let parent,lView=context?context.lView:null;if(null===lView)return null;for(;2===lView[TVIEW].type&&(parent=getLViewParent(lView));)lView=parent;return 512&lView[FLAGS]?null:lView[CONTEXT]}function getRootComponents(elementOrDir){const lView=readPatchedLView(elementOrDir);return null!==lView?[getRootContext(lView)]:[]}function getInjector(elementOrDir){const context=getLContext(elementOrDir),lView=context?context.lView:null;if(null===lView)return Injector.NULL;const tNode=lView[TVIEW].data[context.nodeIndex];return new NodeInjector(tNode,lView)}function getHostElement(componentOrDirective){return getLContext(componentOrDirective).native}function getListeners(element){ngDevMode&&assertDomElement(element);const lContext=getLContext(element),lView=null===lContext?null:lContext.lView;if(null===lView)return[];const tView=lView[TVIEW],lCleanup=lView[CLEANUP],tCleanup=tView.cleanup,listeners=[];if(tCleanup&&lCleanup)for(let i=0;i<tCleanup.length;){const firstParam=tCleanup[i++],secondParam=tCleanup[i++];if("string"==typeof firstParam){const name=firstParam,listenerElement=unwrapRNode(lView[secondParam]),callback=lCleanup[tCleanup[i++]],useCaptureOrIndx=tCleanup[i++],type="boolean"==typeof useCaptureOrIndx||useCaptureOrIndx>=0?"dom":"output",useCapture="boolean"==typeof useCaptureOrIndx&&useCaptureOrIndx;element==listenerElement&&listeners.push({element,name,callback,useCapture,type})}}return listeners.sort(sortListeners),listeners}function sortListeners(a,b){return a.name==b.name?0:a.name<b.name?-1:1}function assertDomElement(value){if("undefined"!=typeof Element&&!(value instanceof Element))throw new Error("Expecting instance of DOM Element")}function extractInputDebugMetadata(inputs){const res={};for(const key in inputs){if(!inputs.hasOwnProperty(key))continue;const value=inputs[key];if(void 0===value)continue;let minifiedName;minifiedName=Array.isArray(value)?value[0]:value,res[key]=minifiedName}return res}let DOCUMENT;function getDocument(){if(void 0!==DOCUMENT)return DOCUMENT;if("undefined"!=typeof document)return document;throw new RuntimeError(210,("undefined"==typeof ngDevMode||ngDevMode)&&"The document object is not available in this context. Make sure the DOCUMENT injection token is provided.")}const APP_ID=new InjectionToken(ngDevMode?"AppId":"",{providedIn:"root",factory:()=>DEFAULT_APP_ID}),DEFAULT_APP_ID="ng",PLATFORM_INITIALIZER=new InjectionToken(ngDevMode?"Platform Initializer":""),PLATFORM_ID=new InjectionToken(ngDevMode?"Platform ID":"",{providedIn:"platform",factory:()=>"unknown"}),IMAGE_CONFIG_DEFAULTS=(new InjectionToken(ngDevMode?"Application Packages Root URL":""),new InjectionToken(ngDevMode?"AnimationModuleType":""),new InjectionToken(ngDevMode?"CSP nonce":"",{providedIn:"root",factory:()=>getDocument().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce")||null}),{breakpoints:[16,32,48,64,96,128,256,384,640,750,828,1080,1200,1920,2048,3840],placeholderResolution:30,disableImageSizeWarning:!1,disableImageLazyLoadWarning:!1}),IMAGE_CONFIG=new InjectionToken(ngDevMode?"ImageConfig":"",{providedIn:"root",factory:()=>IMAGE_CONFIG_DEFAULTS});function initTransferState(){const transferState=new TransferState;return"browser"===inject(PLATFORM_ID)&&(transferState.store=function retrieveTransferredState(doc,appId){const script=doc.getElementById(appId+"-state");if(script?.textContent)try{return JSON.parse(script.textContent)}catch(e){console.warn("Exception while restoring TransferState for app "+appId,e)}return{}}(getDocument(),inject(APP_ID))),transferState}class TransferState{constructor(){this.store={},this.onSerializeCallbacks={}}static#_=this.ɵprov=ɵɵdefineInjectable({token:TransferState,providedIn:"root",factory:initTransferState});get(key,defaultValue){return void 0!==this.store[key]?this.store[key]:defaultValue}set(key,value){this.store[key]=value}remove(key){delete this.store[key]}hasKey(key){return this.store.hasOwnProperty(key)}get isEmpty(){return 0===Object.keys(this.store).length}onSerialize(key,callback){this.onSerializeCallbacks[key]=callback}toJson(){for(const key in this.onSerializeCallbacks)if(this.onSerializeCallbacks.hasOwnProperty(key))try{this.store[key]=this.onSerializeCallbacks[key]()}catch(e){console.warn("Exception in onSerialize callback: ",e)}return JSON.stringify(this.store).replace(/</g,"\\u003C")}}const REFERENCE_NODE_HOST="h",REFERENCE_NODE_BODY="b";var NodeNavigationStep;!function(NodeNavigationStep){NodeNavigationStep.FirstChild="f",NodeNavigationStep.NextSibling="n"}(NodeNavigationStep||(NodeNavigationStep={}));let _retrieveHydrationInfoImpl=()=>null;function retrieveHydrationInfo(rNode,injector,isRootView=!1){return _retrieveHydrationInfoImpl(rNode,injector,isRootView)}var HydrationStatus;!function(HydrationStatus){HydrationStatus.Hydrated="hydrated",HydrationStatus.Skipped="skipped",HydrationStatus.Mismatched="mismatched"}(HydrationStatus||(HydrationStatus={}));new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_HYDRATION_DOM_REUSE_ENABLED":"");const PRESERVE_HOST_CONTENT=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"PRESERVE_HOST_CONTENT":"",{providedIn:"root",factory:()=>false});new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"IS_I18N_HYDRATION_ENABLED":"");let policy$1,policy;function getPolicy$1(){if(void 0===policy$1&&(policy$1=null,_global.trustedTypes))try{policy$1=_global.trustedTypes.createPolicy("angular",{createHTML:s=>s,createScript:s=>s,createScriptURL:s=>s})}catch{}return policy$1}function trustedHTMLFromString(html){return getPolicy$1()?.createHTML(html)||html}function getPolicy(){if(void 0===policy&&(policy=null,_global.trustedTypes))try{policy=_global.trustedTypes.createPolicy("angular#unsafe-bypass",{createHTML:s=>s,createScript:s=>s,createScriptURL:s=>s})}catch{}return policy}function trustedHTMLFromStringBypass(html){return getPolicy()?.createHTML(html)||html}function trustedScriptFromStringBypass(script){return getPolicy()?.createScript(script)||script}function trustedScriptURLFromStringBypass(url){return getPolicy()?.createScriptURL(url)||url}class SafeValueImpl{constructor(changingThisBreaksApplicationSecurity){this.changingThisBreaksApplicationSecurity=changingThisBreaksApplicationSecurity}toString(){return`SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`}}function unwrapSafeValue(value){return value instanceof SafeValueImpl?value.changingThisBreaksApplicationSecurity:value}function allowSanitizationBypassAndThrow(value,type){const actualType=function getSanitizationBypassType(value){return value instanceof SafeValueImpl&&value.getTypeName()||null}(value);if(null!=actualType&&actualType!==type){if("ResourceURL"===actualType&&"URL"===type)return!0;throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`)}return actualType===type}function getInertBodyHelper(defaultDoc){const inertDocumentHelper=new InertDocumentHelper(defaultDoc);return function isDOMParserAvailable(){try{return!!(new window.DOMParser).parseFromString(trustedHTMLFromString(""),"text/html")}catch{return!1}}()?new DOMParserHelper(inertDocumentHelper):inertDocumentHelper}class DOMParserHelper{constructor(inertDocumentHelper){this.inertDocumentHelper=inertDocumentHelper}getInertBodyElement(html){html="<body><remove></remove>"+html;try{const body=(new window.DOMParser).parseFromString(trustedHTMLFromString(html),"text/html").body;return null===body?this.inertDocumentHelper.getInertBodyElement(html):(body.removeChild(body.firstChild),body)}catch{return null}}}class InertDocumentHelper{constructor(defaultDoc){this.defaultDoc=defaultDoc,this.inertDocument=this.defaultDoc.implementation.createHTMLDocument("sanitization-inert")}getInertBodyElement(html){const templateEl=this.inertDocument.createElement("template");return templateEl.innerHTML=trustedHTMLFromString(html),templateEl}}const SAFE_URL_PATTERN=/^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i;function _sanitizeUrl(url){return(url=String(url)).match(SAFE_URL_PATTERN)?url:(("undefined"==typeof ngDevMode||ngDevMode)&&console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`),"unsafe:"+url)}function tagSet(tags){const res={};for(const t of tags.split(","))res[t]=!0;return res}function merge(...sets){const res={};for(const s of sets)for(const v in s)s.hasOwnProperty(v)&&(res[v]=!0);return res}const VOID_ELEMENTS=tagSet("area,br,col,hr,img,wbr"),OPTIONAL_END_TAG_BLOCK_ELEMENTS=tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),OPTIONAL_END_TAG_INLINE_ELEMENTS=tagSet("rp,rt"),OPTIONAL_END_TAG_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,OPTIONAL_END_TAG_BLOCK_ELEMENTS),BLOCK_ELEMENTS=merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS,tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),INLINE_ELEMENTS=merge(OPTIONAL_END_TAG_INLINE_ELEMENTS,tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),VALID_ELEMENTS=merge(VOID_ELEMENTS,BLOCK_ELEMENTS,INLINE_ELEMENTS,OPTIONAL_END_TAG_ELEMENTS),URI_ATTRS=tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),HTML_ATTRS=tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),ARIA_ATTRS=tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"),VALID_ATTRS=merge(URI_ATTRS,HTML_ATTRS,ARIA_ATTRS),SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS=tagSet("script,style,template");class SanitizingHtmlSerializer{constructor(){this.sanitizedSomething=!1,this.buf=[]}sanitizeChildren(el){let current=el.firstChild,traverseContent=!0,parentNodes=[];for(;current;)if(current.nodeType===Node.ELEMENT_NODE?traverseContent=this.startElement(current):current.nodeType===Node.TEXT_NODE?this.chars(current.nodeValue):this.sanitizedSomething=!0,traverseContent&&current.firstChild)parentNodes.push(current),current=getFirstChild(current);else for(;current;){current.nodeType===Node.ELEMENT_NODE&&this.endElement(current);let next=getNextSibling(current);if(next){current=next;break}current=parentNodes.pop()}return this.buf.join("")}startElement(element){const tagName=getNodeName(element).toLowerCase();if(!VALID_ELEMENTS.hasOwnProperty(tagName))return this.sanitizedSomething=!0,!SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);this.buf.push("<"),this.buf.push(tagName);const elAttrs=element.attributes;for(let i=0;i<elAttrs.length;i++){const elAttr=elAttrs.item(i),attrName=elAttr.name,lower=attrName.toLowerCase();if(!VALID_ATTRS.hasOwnProperty(lower)){this.sanitizedSomething=!0;continue}let value=elAttr.value;URI_ATTRS[lower]&&(value=_sanitizeUrl(value)),this.buf.push(" ",attrName,'="',encodeEntities(value),'"')}return this.buf.push(">"),!0}endElement(current){const tagName=getNodeName(current).toLowerCase();VALID_ELEMENTS.hasOwnProperty(tagName)&&!VOID_ELEMENTS.hasOwnProperty(tagName)&&(this.buf.push("</"),this.buf.push(tagName),this.buf.push(">"))}chars(chars){this.buf.push(encodeEntities(chars))}}function getNextSibling(node){const nextSibling=node.nextSibling;if(nextSibling&&node!==nextSibling.previousSibling)throw clobberedElementError(nextSibling);return nextSibling}function getFirstChild(node){const firstChild=node.firstChild;if(firstChild&&function isClobberedElement(parentNode,childNode){return(parentNode.compareDocumentPosition(childNode)&Node.DOCUMENT_POSITION_CONTAINED_BY)!==Node.DOCUMENT_POSITION_CONTAINED_BY}(node,firstChild))throw clobberedElementError(firstChild);return firstChild}function getNodeName(node){const nodeName=node.nodeName;return"string"==typeof nodeName?nodeName:"FORM"}function clobberedElementError(node){return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`)}const SURROGATE_PAIR_REGEXP=/[\uD800-\uDBFF][\uDC00-\uDFFF]/g,NON_ALPHANUMERIC_REGEXP=/([^\#-~ |!])/g;function encodeEntities(value){return value.replace(/&/g,"&amp;").replace(SURROGATE_PAIR_REGEXP,(function(match){return"&#"+(1024*(match.charCodeAt(0)-55296)+(match.charCodeAt(1)-56320)+65536)+";"})).replace(NON_ALPHANUMERIC_REGEXP,(function(match){return"&#"+match.charCodeAt(0)+";"})).replace(/</g,"&lt;").replace(/>/g,"&gt;")}let inertBodyHelper;function getTemplateContent(el){return"content"in el&&function isTemplateElement(el){return el.nodeType===Node.ELEMENT_NODE&&"TEMPLATE"===el.nodeName}(el)?el.content:null}var SecurityContext;function ɵɵsanitizeHtml(unsafeHtml){const sanitizer=getSanitizer();return sanitizer?trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML,unsafeHtml)||""):allowSanitizationBypassAndThrow(unsafeHtml,"HTML")?trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml)):function _sanitizeHtml(defaultDoc,unsafeHtmlInput){let inertBodyElement=null;try{inertBodyHelper=inertBodyHelper||getInertBodyHelper(defaultDoc);let unsafeHtml=unsafeHtmlInput?String(unsafeHtmlInput):"";inertBodyElement=inertBodyHelper.getInertBodyElement(unsafeHtml);let mXSSAttempts=5,parsedHtml=unsafeHtml;do{if(0===mXSSAttempts)throw new Error("Failed to sanitize html because the input is unstable");mXSSAttempts--,unsafeHtml=parsedHtml,parsedHtml=inertBodyElement.innerHTML,inertBodyElement=inertBodyHelper.getInertBodyElement(unsafeHtml)}while(unsafeHtml!==parsedHtml);const sanitizer=new SanitizingHtmlSerializer,safeHtml=sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement)||inertBodyElement);return("undefined"==typeof ngDevMode||ngDevMode)&&sanitizer.sanitizedSomething&&console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`),trustedHTMLFromString(safeHtml)}finally{if(inertBodyElement){const parent=getTemplateContent(inertBodyElement)||inertBodyElement;for(;parent.firstChild;)parent.removeChild(parent.firstChild)}}}(getDocument(),renderStringify(unsafeHtml))}function ɵɵsanitizeStyle(unsafeStyle){const sanitizer=getSanitizer();return sanitizer?sanitizer.sanitize(SecurityContext.STYLE,unsafeStyle)||"":allowSanitizationBypassAndThrow(unsafeStyle,"Style")?unwrapSafeValue(unsafeStyle):renderStringify(unsafeStyle)}function ɵɵsanitizeUrl(unsafeUrl){const sanitizer=getSanitizer();return sanitizer?sanitizer.sanitize(SecurityContext.URL,unsafeUrl)||"":allowSanitizationBypassAndThrow(unsafeUrl,"URL")?unwrapSafeValue(unsafeUrl):_sanitizeUrl(renderStringify(unsafeUrl))}function ɵɵsanitizeResourceUrl(unsafeResourceUrl){const sanitizer=getSanitizer();if(sanitizer)return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL,unsafeResourceUrl)||"");if(allowSanitizationBypassAndThrow(unsafeResourceUrl,"ResourceURL"))return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));throw new RuntimeError(904,ngDevMode&&`unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`)}function ɵɵsanitizeScript(unsafeScript){const sanitizer=getSanitizer();if(sanitizer)return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT,unsafeScript)||"");if(allowSanitizationBypassAndThrow(unsafeScript,"Script"))return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));throw new RuntimeError(905,ngDevMode&&"unsafe value used in a script context")}function ɵɵtrustConstantHtml(html){if(ngDevMode&&(!Array.isArray(html)||!Array.isArray(html.raw)||1!==html.length))throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join("?")}`);return trustedHTMLFromString(html[0])}function ɵɵtrustConstantResourceUrl(url){if(ngDevMode&&(!Array.isArray(url)||!Array.isArray(url.raw)||1!==url.length))throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join("?")}`);return function trustedScriptURLFromString(url){return getPolicy$1()?.createScriptURL(url)||url}(url[0])}function ɵɵsanitizeUrlOrResourceUrl(unsafeUrl,tag,prop){return function getUrlSanitizer(tag,prop){return"src"===prop&&("embed"===tag||"frame"===tag||"iframe"===tag||"media"===tag||"script"===tag)||"href"===prop&&("base"===tag||"link"===tag)?ɵɵsanitizeResourceUrl:ɵɵsanitizeUrl}(tag,prop)(unsafeUrl)}function getSanitizer(){const lView=getLView();return lView&&lView[ENVIRONMENT].sanitizer}!function(SecurityContext){SecurityContext[SecurityContext.NONE=0]="NONE",SecurityContext[SecurityContext.HTML=1]="HTML",SecurityContext[SecurityContext.STYLE=2]="STYLE",SecurityContext[SecurityContext.SCRIPT=3]="SCRIPT",SecurityContext[SecurityContext.URL=4]="URL",SecurityContext[SecurityContext.RESOURCE_URL=5]="RESOURCE_URL"}(SecurityContext||(SecurityContext={}));const COMMENT_DISALLOWED=/^>|^->|<!--|-->|--!>|<!-$/g,COMMENT_DELIMITER=/(<|>)/g,COMMENT_DELIMITER_ESCAPED="​$1​";function escapeCommentText(value){return value.replace(COMMENT_DISALLOWED,(text=>text.replace(COMMENT_DELIMITER,COMMENT_DELIMITER_ESCAPED)))}function normalizeDebugBindingName(name){return name=function camelCaseToDashCase(input){return input.replace(CAMEL_CASE_REGEXP,((...m)=>"-"+m[1].toLowerCase()))}(name.replace(/[$@]/g,"_")),`ng-reflect-${name}`}const CAMEL_CASE_REGEXP=/([A-Z])/g;const CUSTOM_ELEMENTS_SCHEMA={name:"custom-elements"},NO_ERRORS_SCHEMA={name:"no-errors-schema"};let shouldThrowErrorOnUnknownElement=!1;let shouldThrowErrorOnUnknownProperty=!1;function handleUnknownPropertyError(propName,tagName,nodeType,lView){tagName||4!==nodeType||(tagName="ng-template");const isHostStandalone=isHostComponentStandalone(lView);let message=`Can't bind to '${propName}' since it isn't a known property of '${tagName}'${getTemplateLocationDetails(lView)}.`;const schemas=`'${isHostStandalone?"@Component":"@NgModule"}.schemas'`,importLocation=isHostStandalone?"included in the '@Component.imports' of this component":"a part of an @NgModule where this component is declared";if(KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)){message+=`\nIf the '${propName}' is an Angular control flow directive, please make sure that either the '${KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName)}' directive or the 'CommonModule' is ${importLocation}.`}else message+=`\n1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`,tagName&&tagName.indexOf("-")>-1?(message+=`\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`,message+=`\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`):message+=`\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;reportUnknownPropertyError(message)}function reportUnknownPropertyError(message){if(shouldThrowErrorOnUnknownProperty)throw new RuntimeError(303,message);console.error(formatRuntimeError(303,message))}function getDeclarationComponentDef(lView){!ngDevMode&&throwError("Must never be called in production mode");const context=lView[DECLARATION_COMPONENT_VIEW][CONTEXT];return context&&context.constructor?getComponentDef(context.constructor):null}function isHostComponentStandalone(lView){!ngDevMode&&throwError("Must never be called in production mode");const componentDef=getDeclarationComponentDef(lView);return!!componentDef?.standalone}function getTemplateLocationDetails(lView){!ngDevMode&&throwError("Must never be called in production mode");const hostComponentDef=getDeclarationComponentDef(lView),componentClassName=hostComponentDef?.type?.name;return componentClassName?` (used in the '${componentClassName}' component template)`:""}const KNOWN_CONTROL_FLOW_DIRECTIVES=new Map([["ngIf","NgIf"],["ngFor","NgFor"],["ngSwitchCase","NgSwitchCase"],["ngSwitchDefault","NgSwitchDefault"]]);function matchingSchemas(schemas,tagName){if(null!==schemas)for(let i=0;i<schemas.length;i++){const schema=schemas[i];if(schema===NO_ERRORS_SCHEMA||schema===CUSTOM_ELEMENTS_SCHEMA&&tagName&&tagName.indexOf("-")>-1)return!0}return!1}function ɵɵresolveWindow(element){return element.ownerDocument.defaultView}function ɵɵresolveDocument(element){return element.ownerDocument}function ɵɵresolveBody(element){return element.ownerDocument.body}const INTERPOLATION_DELIMITER="�";function maybeUnwrapFn(value){return value instanceof Function?value():value}function isPlatformBrowser(injector){return"browser"===(injector??inject(Injector)).get(PLATFORM_ID)}const VALUE_STRING_LENGTH_LIMIT=200;function throwMultipleComponentError(tNode,first,second){throw new RuntimeError(-300,`Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first)} and ${stringifyForError(second)}`)}function formatValue(value){let strValue=String(value);try{(Array.isArray(value)||"[object Object]"===strValue)&&(strValue=JSON.stringify(value))}catch(error){}return strValue.length>VALUE_STRING_LENGTH_LIMIT?strValue.substring(0,VALUE_STRING_LENGTH_LIMIT)+"…":strValue}function constructDetailsForInterpolation(lView,rootIndex,expressionIndex,meta,changedValue){const[propName,prefix,...chunks]=meta.split(INTERPOLATION_DELIMITER);let oldValue=prefix,newValue=prefix;for(let i=0;i<chunks.length;i++){const slotIdx=rootIndex+i;oldValue+=`${lView[slotIdx]}${chunks[i]}`,newValue+=`${slotIdx===expressionIndex?changedValue:lView[slotIdx]}${chunks[i]}`}return{propName,oldValue,newValue}}var RendererStyleFlags2;let _icuContainerIterate;function icuContainerIterate(tIcuContainerNode,lView){return _icuContainerIterate(tIcuContainerNode,lView)}function applyToElementOrContainer(action,renderer,parent,lNodeToHandle,beforeNode){if(null!=lNodeToHandle){let lContainer,isComponent=!1;isLContainer(lNodeToHandle)?lContainer=lNodeToHandle:isLView(lNodeToHandle)&&(isComponent=!0,ngDevMode&&assertDefined(lNodeToHandle[HOST],"HOST must be defined for a component LView"),lNodeToHandle=lNodeToHandle[HOST]);const rNode=unwrapRNode(lNodeToHandle);0===action&&null!==parent?null==beforeNode?nativeAppendChild(renderer,parent,rNode):nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):1===action&&null!==parent?nativeInsertBefore(renderer,parent,rNode,beforeNode||null,!0):2===action?nativeRemoveNode(renderer,rNode,isComponent):3===action&&(ngDevMode&&ngDevMode.rendererDestroyNode++,renderer.destroyNode(rNode)),null!=lContainer&&function applyContainer(renderer,action,lContainer,parentRElement,beforeNode){ngDevMode&&assertLContainer(lContainer);const anchor=lContainer[NATIVE],native=unwrapRNode(lContainer);anchor!==native&&applyToElementOrContainer(action,renderer,parentRElement,anchor,beforeNode);for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const lView=lContainer[i];applyView(lView[TVIEW],lView,renderer,action,parentRElement,anchor)}}(renderer,action,lContainer,parent,beforeNode)}}function createTextNode(renderer,value){return ngDevMode&&ngDevMode.rendererCreateTextNode++,ngDevMode&&ngDevMode.rendererSetText++,renderer.createText(value)}function updateTextNode(renderer,rNode,value){ngDevMode&&ngDevMode.rendererSetText++,renderer.setValue(rNode,value)}function createCommentNode(renderer,value){return ngDevMode&&ngDevMode.rendererCreateComment++,renderer.createComment(escapeCommentText(value))}function createElementNode(renderer,name,namespace){return ngDevMode&&ngDevMode.rendererCreateElement++,renderer.createElement(name,namespace)}function detachViewFromDOM(tView,lView){lView[ENVIRONMENT].changeDetectionScheduler?.notify(1),applyView(tView,lView,lView[RENDERER],2,null,null)}function insertView(tView,lView,lContainer,index){ngDevMode&&assertLView(lView),ngDevMode&&assertLContainer(lContainer);const indexInContainer=CONTAINER_HEADER_OFFSET+index,containerLength=lContainer.length;index>0&&(lContainer[indexInContainer-1][NEXT]=lView),index<containerLength-CONTAINER_HEADER_OFFSET?(lView[NEXT]=lContainer[indexInContainer],addToArray(lContainer,CONTAINER_HEADER_OFFSET+index,lView)):(lContainer.push(lView),lView[NEXT]=null),lView[PARENT]=lContainer;const declarationLContainer=lView[DECLARATION_LCONTAINER];null!==declarationLContainer&&lContainer!==declarationLContainer&&function trackMovedView(declarationContainer,lView){ngDevMode&&assertDefined(lView,"LView required"),ngDevMode&&assertLContainer(declarationContainer);const movedViews=declarationContainer[MOVED_VIEWS],insertedLContainer=lView[PARENT];ngDevMode&&assertLContainer(insertedLContainer);const insertedComponentLView=insertedLContainer[PARENT][DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(insertedComponentLView,"Missing insertedComponentLView");const declaredComponentLView=lView[DECLARATION_COMPONENT_VIEW];ngDevMode&&assertDefined(declaredComponentLView,"Missing declaredComponentLView"),declaredComponentLView!==insertedComponentLView&&(declarationContainer[FLAGS]|=LContainerFlags.HasTransplantedViews);null===movedViews?declarationContainer[MOVED_VIEWS]=[lView]:movedViews.push(lView)}(declarationLContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.insertView(tView),updateAncestorTraversalFlagsOnAttach(lView),lView[FLAGS]|=128}function detachMovedView(declarationContainer,lView){ngDevMode&&assertLContainer(declarationContainer),ngDevMode&&assertDefined(declarationContainer[MOVED_VIEWS],"A projected view should belong to a non-empty projected views collection");const movedViews=declarationContainer[MOVED_VIEWS],declarationViewIndex=movedViews.indexOf(lView);ngDevMode&&assertLContainer(lView[PARENT]),movedViews.splice(declarationViewIndex,1)}function detachView(lContainer,removeIndex){if(lContainer.length<=CONTAINER_HEADER_OFFSET)return;const indexInContainer=CONTAINER_HEADER_OFFSET+removeIndex,viewToDetach=lContainer[indexInContainer];if(viewToDetach){const declarationLContainer=viewToDetach[DECLARATION_LCONTAINER];null!==declarationLContainer&&declarationLContainer!==lContainer&&detachMovedView(declarationLContainer,viewToDetach),removeIndex>0&&(lContainer[indexInContainer-1][NEXT]=viewToDetach[NEXT]);const removedLView=removeFromArray(lContainer,CONTAINER_HEADER_OFFSET+removeIndex);!function removeViewFromDOM(tView,lView){detachViewFromDOM(tView,lView),lView[HOST]=null,lView[T_HOST]=null}(viewToDetach[TVIEW],viewToDetach);const lQueries=removedLView[QUERIES];null!==lQueries&&lQueries.detachView(removedLView[TVIEW]),viewToDetach[PARENT]=null,viewToDetach[NEXT]=null,viewToDetach[FLAGS]&=-129}return viewToDetach}function destroyLView(tView,lView){if(!(256&lView[FLAGS])){const renderer=lView[RENDERER];renderer.destroyNode&&applyView(tView,lView,renderer,3,null,null),function destroyViewTree(rootView){let lViewOrLContainer=rootView[CHILD_HEAD];if(!lViewOrLContainer)return cleanUpView(rootView[TVIEW],rootView);for(;lViewOrLContainer;){let next=null;if(isLView(lViewOrLContainer))next=lViewOrLContainer[CHILD_HEAD];else{ngDevMode&&assertLContainer(lViewOrLContainer);const firstView=lViewOrLContainer[CONTAINER_HEADER_OFFSET];firstView&&(next=firstView)}if(!next){for(;lViewOrLContainer&&!lViewOrLContainer[NEXT]&&lViewOrLContainer!==rootView;)isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),lViewOrLContainer=lViewOrLContainer[PARENT];null===lViewOrLContainer&&(lViewOrLContainer=rootView),isLView(lViewOrLContainer)&&cleanUpView(lViewOrLContainer[TVIEW],lViewOrLContainer),next=lViewOrLContainer&&lViewOrLContainer[NEXT]}lViewOrLContainer=next}}(lView)}}function cleanUpView(tView,lView){if(256&lView[FLAGS])return;const prevConsumer=setActiveConsumer(null);try{lView[FLAGS]&=-129,lView[FLAGS]|=256,lView[REACTIVE_TEMPLATE_CONSUMER]&&consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]),executeOnDestroys(tView,lView),processCleanups(tView,lView),1===lView[TVIEW].type&&(ngDevMode&&ngDevMode.rendererDestroy++,lView[RENDERER].destroy());const declarationContainer=lView[DECLARATION_LCONTAINER];if(null!==declarationContainer&&isLContainer(lView[PARENT])){declarationContainer!==lView[PARENT]&&detachMovedView(declarationContainer,lView);const lQueries=lView[QUERIES];null!==lQueries&&lQueries.detachView(tView)}!function unregisterLView(lView){ngDevMode&&assertNumber(lView[ID],"Cannot stop tracking an LView that does not have an ID"),TRACKED_LVIEWS.delete(lView[ID])}(lView)}finally{setActiveConsumer(prevConsumer)}}function processCleanups(tView,lView){ngDevMode&&assertNotReactive(processCleanups.name);const tCleanup=tView.cleanup,lCleanup=lView[CLEANUP];if(null!==tCleanup)for(let i=0;i<tCleanup.length-1;i+=2)if("string"==typeof tCleanup[i]){const targetIdx=tCleanup[i+3];ngDevMode&&assertNumber(targetIdx,"cleanup target must be a number"),targetIdx>=0?lCleanup[targetIdx]():lCleanup[-targetIdx].unsubscribe(),i+=2}else{const context=lCleanup[tCleanup[i+1]];tCleanup[i].call(context)}null!==lCleanup&&(lView[CLEANUP]=null);const destroyHooks=lView[ON_DESTROY_HOOKS];if(null!==destroyHooks){lView[ON_DESTROY_HOOKS]=null;for(let i=0;i<destroyHooks.length;i++){const destroyHooksFn=destroyHooks[i];ngDevMode&&assertFunction(destroyHooksFn,"Expecting destroy hook to be a function."),destroyHooksFn()}}}function executeOnDestroys(tView,lView){let destroyHooks;if(ngDevMode&&assertNotReactive(executeOnDestroys.name),null!=tView&&null!=(destroyHooks=tView.destroyHooks))for(let i=0;i<destroyHooks.length;i+=2){const context=lView[destroyHooks[i]];if(!(context instanceof NodeInjectorFactory)){const toCall=destroyHooks[i+1];if(Array.isArray(toCall))for(let j=0;j<toCall.length;j+=2){const callContext=context[toCall[j]],hook=toCall[j+1];profiler(4,callContext,hook);try{hook.call(callContext)}finally{profiler(5,callContext,hook)}}else{profiler(4,context,toCall);try{toCall.call(context)}finally{profiler(5,context,toCall)}}}}}function getParentRElement(tView,tNode,lView){return getClosestRElement(tView,tNode.parent,lView)}function getClosestRElement(tView,tNode,lView){let parentTNode=tNode;for(;null!==parentTNode&&40&parentTNode.type;)parentTNode=(tNode=parentTNode).parent;if(null===parentTNode)return lView[HOST];{ngDevMode&&assertTNodeType(parentTNode,7);const{componentOffset}=parentTNode;if(componentOffset>-1){ngDevMode&&assertTNodeForLView(parentTNode,lView);const{encapsulation}=tView.data[parentTNode.directiveStart+componentOffset];if(encapsulation===ViewEncapsulation$1.None||encapsulation===ViewEncapsulation$1.Emulated)return null}return getNativeByTNode(parentTNode,lView)}}function nativeInsertBefore(renderer,parent,child,beforeNode,isMove){ngDevMode&&ngDevMode.rendererInsertBefore++,renderer.insertBefore(parent,child,beforeNode,isMove)}function nativeAppendChild(renderer,parent,child){ngDevMode&&ngDevMode.rendererAppendChild++,ngDevMode&&assertDefined(parent,"parent node must be defined"),renderer.appendChild(parent,child)}function nativeAppendOrInsertBefore(renderer,parent,child,beforeNode,isMove){null!==beforeNode?nativeInsertBefore(renderer,parent,child,beforeNode,isMove):nativeAppendChild(renderer,parent,child)}function nativeParentNode(renderer,node){return renderer.parentNode(node)}function getInsertInFrontOfRNode(parentTNode,currentTNode,lView){return _getInsertInFrontOfRNodeWithI18n(parentTNode,currentTNode,lView)}function getInsertInFrontOfRNodeWithNoI18n(parentTNode,currentTNode,lView){return 40&parentTNode.type?getNativeByTNode(parentTNode,lView):null}!function(RendererStyleFlags2){RendererStyleFlags2[RendererStyleFlags2.Important=1]="Important",RendererStyleFlags2[RendererStyleFlags2.DashCase=2]="DashCase"}(RendererStyleFlags2||(RendererStyleFlags2={}));let _processI18nInsertBefore,_getInsertInFrontOfRNodeWithI18n=getInsertInFrontOfRNodeWithNoI18n;function setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore){_getInsertInFrontOfRNodeWithI18n=getInsertInFrontOfRNodeWithI18n,_processI18nInsertBefore=processI18nInsertBefore}function appendChild(tView,lView,childRNode,childTNode){const parentRNode=getParentRElement(tView,childTNode,lView),renderer=lView[RENDERER],anchorNode=getInsertInFrontOfRNode(childTNode.parent||lView[T_HOST],childTNode,lView);if(null!=parentRNode)if(Array.isArray(childRNode))for(let i=0;i<childRNode.length;i++)nativeAppendOrInsertBefore(renderer,parentRNode,childRNode[i],anchorNode,!1);else nativeAppendOrInsertBefore(renderer,parentRNode,childRNode,anchorNode,!1);void 0!==_processI18nInsertBefore&&_processI18nInsertBefore(renderer,childTNode,lView,childRNode,parentRNode)}function getFirstNativeNode(lView,tNode){if(null!==tNode){ngDevMode&&assertTNodeType(tNode,63);const tNodeType=tNode.type;if(3&tNodeType)return getNativeByTNode(tNode,lView);if(4&tNodeType)return getBeforeNodeForView(-1,lView[tNode.index]);if(8&tNodeType){const elIcuContainerChild=tNode.child;if(null!==elIcuContainerChild)return getFirstNativeNode(lView,elIcuContainerChild);{const rNodeOrLContainer=lView[tNode.index];return isLContainer(rNodeOrLContainer)?getBeforeNodeForView(-1,rNodeOrLContainer):unwrapRNode(rNodeOrLContainer)}}if(32&tNodeType){return icuContainerIterate(tNode,lView)()||unwrapRNode(lView[tNode.index])}{const projectionNodes=getProjectionNodes(lView,tNode);if(null!==projectionNodes){if(Array.isArray(projectionNodes))return projectionNodes[0];const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);return ngDevMode&&assertParentView(parentView),getFirstNativeNode(parentView,projectionNodes)}return getFirstNativeNode(lView,tNode.next)}}return null}function getProjectionNodes(lView,tNode){if(null!==tNode){const componentHost=lView[DECLARATION_COMPONENT_VIEW][T_HOST],slotIdx=tNode.projection;return ngDevMode&&function assertProjectionSlots(lView,errMessage){assertDefined(lView[DECLARATION_COMPONENT_VIEW],"Component views should exist."),assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection,errMessage||"Components with projection nodes (<ng-content>) must have projection slots defined.")}(lView),componentHost.projection[slotIdx]}return null}function getBeforeNodeForView(viewIndexInContainer,lContainer){const nextViewIndex=CONTAINER_HEADER_OFFSET+viewIndexInContainer+1;if(nextViewIndex<lContainer.length){const lView=lContainer[nextViewIndex],firstTNodeOfView=lView[TVIEW].firstChild;if(null!==firstTNodeOfView)return getFirstNativeNode(lView,firstTNodeOfView)}return lContainer[NATIVE]}function nativeRemoveNode(renderer,rNode,isHostElement){ngDevMode&&ngDevMode.rendererRemoveNode++;const nativeParent=nativeParentNode(renderer,rNode);nativeParent&&function nativeRemoveChild(renderer,parent,child,isHostElement){renderer.removeChild(parent,child,isHostElement)}(renderer,nativeParent,rNode,isHostElement)}function applyNodes(renderer,action,tNode,lView,parentRElement,beforeNode,isProjection){for(;null!=tNode;){ngDevMode&&assertTNodeForLView(tNode,lView),ngDevMode&&assertTNodeType(tNode,63);const rawSlotValue=lView[tNode.index],tNodeType=tNode.type;if(isProjection&&0===action&&(rawSlotValue&&attachPatchData(unwrapRNode(rawSlotValue),lView),tNode.flags|=2),32&~tNode.flags)if(8&tNodeType)applyNodes(renderer,action,tNode.child,lView,parentRElement,beforeNode,!1),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)applyToElementOrContainer(action,renderer,parentRElement,rNode,beforeNode);applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode)}else 16&tNodeType?applyProjectionRecursive(renderer,action,lView,tNode,parentRElement,beforeNode):(ngDevMode&&assertTNodeType(tNode,7),applyToElementOrContainer(action,renderer,parentRElement,rawSlotValue,beforeNode));tNode=isProjection?tNode.projectionNext:tNode.next}}function applyView(tView,lView,renderer,action,parentRElement,beforeNode){applyNodes(renderer,action,tView.firstChild,lView,parentRElement,beforeNode,!1)}function applyProjectionRecursive(renderer,action,lView,tProjectionNode,parentRElement,beforeNode){const componentLView=lView[DECLARATION_COMPONENT_VIEW],componentNode=componentLView[T_HOST];ngDevMode&&assertEqual(typeof tProjectionNode.projection,"number","expecting projection index");const nodeToProjectOrRNodes=componentNode.projection[tProjectionNode.projection];if(Array.isArray(nodeToProjectOrRNodes))for(let i=0;i<nodeToProjectOrRNodes.length;i++){applyToElementOrContainer(action,renderer,parentRElement,nodeToProjectOrRNodes[i],beforeNode)}else{let nodeToProject=nodeToProjectOrRNodes;const projectedComponentLView=componentLView[PARENT];hasInSkipHydrationBlockFlag(tProjectionNode)&&(nodeToProject.flags|=128),applyNodes(renderer,action,nodeToProject,projectedComponentLView,parentRElement,beforeNode,!0)}}function writeDirectClass(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),""===newValue?renderer.removeAttribute(element,"class"):renderer.setAttribute(element,"class",newValue),ngDevMode&&ngDevMode.rendererSetClassName++}function setupStaticAttributes(renderer,element,tNode){const{mergedAttrs,classes,styles}=tNode;null!==mergedAttrs&&setUpAttributes(renderer,element,mergedAttrs),null!==classes&&writeDirectClass(renderer,element,classes),null!==styles&&function writeDirectStyle(renderer,element,newValue){ngDevMode&&assertString(newValue,"'newValue' should be a string"),renderer.setAttribute(element,"style",newValue),ngDevMode&&ngDevMode.rendererSetStyle++}(renderer,element,styles)}const NO_CHANGE="undefined"==typeof ngDevMode||ngDevMode?{__brand__:"NO_CHANGE"}:{};function ɵɵadvance(delta=1){ngDevMode&&assertGreaterThan(delta,0,"Can only advance forward"),selectIndexInternal(getTView(),getLView(),getSelectedIndex()+delta,!!ngDevMode&&isInCheckNoChangesMode())}function selectIndexInternal(tView,lView,index,checkNoChangesMode){if(ngDevMode&&assertIndexInDeclRange(lView[TVIEW],index),!checkNoChangesMode){if(!(3&~lView[FLAGS])){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,index)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,index)}}setSelectedIndex(index)}function ɵɵdirectiveInject(token,flags=InjectFlags.Default){const lView=getLView();if(null===lView)return ngDevMode&&function assertInjectImplementationNotEqual(fn){ngDevMode&&assertNotEqual(_injectImplementation,fn,"Calling ɵɵinject would cause infinite recursion")}(ɵɵdirectiveInject),ɵɵinject(token,flags);const value=getOrCreateInjectable(getCurrentTNode(),lView,resolveForwardRef(token),flags);return ngDevMode&&emitInjectEvent(token,value,flags),value}function ɵɵinvalidFactory(){const msg=ngDevMode?"This constructor was not compatible with Dependency Injection.":"invalid";throw new Error(msg)}function writeToDirectiveInput(def,instance,publicName,privateName,flags,value){const prevConsumer=setActiveConsumer(null);try{let inputSignalNode=null;if(flags&InputFlags.SignalBased){inputSignalNode=instance[privateName][SIGNAL]}null!==inputSignalNode&&void 0!==inputSignalNode.transformFn&&(value=inputSignalNode.transformFn(value)),flags&InputFlags.HasDecoratorInputTransform&&(value=def.inputTransforms[privateName].call(instance,value)),null!==def.setInput?def.setInput(instance,inputSignalNode,value,publicName,privateName):applyValueToInputField(instance,inputSignalNode,privateName,value)}finally{setActiveConsumer(prevConsumer)}}function createLView(parentLView,tView,context,flags,host,tHostNode,environment,renderer,injector,embeddedViewInjector,hydrationInfo){const lView=tView.blueprint.slice();return lView[HOST]=host,lView[FLAGS]=204|flags,(null!==embeddedViewInjector||parentLView&&2048&parentLView[FLAGS])&&(lView[FLAGS]|=2048),resetPreOrderHookFlags(lView),ngDevMode&&tView.declTNode&&parentLView&&assertTNodeForLView(tView.declTNode,parentLView),lView[PARENT]=lView[DECLARATION_VIEW]=parentLView,lView[CONTEXT]=context,lView[ENVIRONMENT]=environment||parentLView&&parentLView[ENVIRONMENT],ngDevMode&&assertDefined(lView[ENVIRONMENT],"LViewEnvironment is required"),lView[RENDERER]=renderer||parentLView&&parentLView[RENDERER],ngDevMode&&assertDefined(lView[RENDERER],"Renderer is required"),lView[INJECTOR]=injector||parentLView&&parentLView[INJECTOR]||null,lView[T_HOST]=tHostNode,lView[ID]=function getUniqueLViewId(){return uniqueIdCounter++}(),lView[HYDRATION]=hydrationInfo,lView[EMBEDDED_VIEW_INJECTOR]=embeddedViewInjector,ngDevMode&&assertEqual(2!=tView.type||null!==parentLView,!0,"Embedded views must have parentLView"),lView[DECLARATION_COMPONENT_VIEW]=2==tView.type?parentLView[DECLARATION_COMPONENT_VIEW]:lView,lView}function getOrCreateTNode(tView,index,type,name,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&function assertPureTNodeType(type){2!==type&&1!==type&&4!==type&&8!==type&&32!==type&&16!==type&&64!==type&&throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`)}(type);let tNode=tView.data[index];if(null===tNode)tNode=createTNodeAtIndex(tView,index,type,name,attrs),function isInI18nBlock(){return instructionState.lFrame.inI18n}()&&(tNode.flags|=32);else if(64&tNode.type){tNode.type=type,tNode.value=name,tNode.attrs=attrs;const parent=getCurrentParentTNode();tNode.injectorIndex=null===parent?-1:parent.injectorIndex,ngDevMode&&assertTNodeForTView(tNode,tView),ngDevMode&&assertEqual(index,tNode.index,"Expecting same index")}return setCurrentTNode(tNode,!0),tNode}function createTNodeAtIndex(tView,index,type,name,attrs){const currentTNode=getCurrentTNodePlaceholderOk(),isParent=isCurrentTNodeParent(),parent=isParent?currentTNode:currentTNode&&currentTNode.parent,tNode=tView.data[index]=function createTNode(tView,tParent,type,index,value,attrs){ngDevMode&&0!==index&&assertGreaterThanOrEqual(index,HEADER_OFFSET,"TNodes can't be in the LView header."),ngDevMode&&assertNotSame(attrs,void 0,"'undefined' is not valid value for 'attrs'"),ngDevMode&&ngDevMode.tNode++,ngDevMode&&tParent&&assertTNodeForTView(tParent,tView);let injectorIndex=tParent?tParent.injectorIndex:-1,flags=0;isInSkipHydrationBlock$1()&&(flags|=128);const tNode={type,index,insertBeforeIndex:null,injectorIndex,directiveStart:-1,directiveEnd:-1,directiveStylingLast:-1,componentOffset:-1,propertyBindings:null,flags,providerIndexes:0,value,attrs,mergedAttrs:null,localNames:null,initialInputs:void 0,inputs:null,outputs:null,tView:null,next:null,prev:null,projectionNext:null,child:null,parent:tParent,projection:null,styles:null,stylesWithoutHost:null,residualStyles:void 0,classes:null,classesWithoutHost:null,residualClasses:void 0,classBindings:0,styleBindings:0};ngDevMode&&Object.seal(tNode);return tNode}(tView,parent,type,index,name,attrs);return null===tView.firstChild&&(tView.firstChild=tNode),null!==currentTNode&&(isParent?null==currentTNode.child&&null!==tNode.parent&&(currentTNode.child=tNode):null===currentTNode.next&&(currentTNode.next=tNode,tNode.prev=currentTNode)),tNode}function allocExpando(tView,lView,numSlotsToAlloc,initialValue){if(0===numSlotsToAlloc)return-1;ngDevMode&&(assertFirstCreatePass(tView),assertSame(tView,lView[TVIEW],"`LView` must be associated with `TView`!"),assertEqual(tView.data.length,lView.length,"Expecting LView to be same size as TView"),assertEqual(tView.data.length,tView.blueprint.length,"Expecting Blueprint to be same size as TView"),assertFirstUpdatePass(tView));const allocIdx=lView.length;for(let i=0;i<numSlotsToAlloc;i++)lView.push(initialValue),tView.blueprint.push(initialValue),tView.data.push(null);return allocIdx}function executeTemplate(tView,lView,templateFn,rf,context){const prevSelectedIndex=getSelectedIndex(),isUpdatePhase=2&rf;try{setSelectedIndex(-1),isUpdatePhase&&lView.length>HEADER_OFFSET&&selectIndexInternal(tView,lView,HEADER_OFFSET,!!ngDevMode&&isInCheckNoChangesMode());profiler(isUpdatePhase?2:0,context),templateFn(rf,context)}finally{setSelectedIndex(prevSelectedIndex);profiler(isUpdatePhase?3:1,context)}}function executeContentQueries(tView,tNode,lView){if(isContentQueryHost(tNode)){const prevConsumer=setActiveConsumer(null);try{const start=tNode.directiveStart,end=tNode.directiveEnd;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const def=tView.data[directiveIndex];if(def.contentQueries){const directiveInstance=lView[directiveIndex];ngDevMode&&assertDefined(directiveIndex,"Incorrect reference to a directive defining a content query"),def.contentQueries(1,directiveInstance,directiveIndex)}}}finally{setActiveConsumer(prevConsumer)}}}function createDirectivesInstances(tView,lView,tNode){getBindingsEnabled()&&(!function instantiateAllDirectives(tView,lView,tNode,native){const start=tNode.directiveStart,end=tNode.directiveEnd;isComponentHost(tNode)&&(ngDevMode&&assertTNodeType(tNode,3),function addComponentLogic(lView,hostTNode,def){const native=getNativeByTNode(hostTNode,lView),tView=getOrCreateComponentTView(def),rendererFactory=lView[ENVIRONMENT].rendererFactory;let lViewFlags=16;def.signals?lViewFlags=4096:def.onPush&&(lViewFlags=64);const componentView=addToViewTree(lView,createLView(lView,tView,null,lViewFlags,native,hostTNode,null,rendererFactory.createRenderer(native,def),null,null,null));lView[hostTNode.index]=componentView}(lView,tNode,tView.data[start+tNode.componentOffset]));tView.firstCreatePass||getOrCreateNodeInjectorForNode(tNode,lView);attachPatchData(native,lView);const initialInputs=tNode.initialInputs;for(let i=start;i<end;i++){const def=tView.data[i],directive=getNodeInjectable(lView,tView,i,tNode);if(attachPatchData(directive,lView),null!==initialInputs&&setInputsFromAttrs(lView,i-start,directive,def,tNode,initialInputs),isComponentDef(def)){getComponentLViewByIndex(tNode.index,lView)[CONTEXT]=getNodeInjectable(lView,tView,i,tNode)}}}(tView,lView,tNode,getNativeByTNode(tNode,lView)),64&~tNode.flags||invokeDirectivesHostBindings(tView,lView,tNode))}function saveResolvedLocalsInData(viewData,tNode,localRefExtractor=getNativeByTNode){const localNames=tNode.localNames;if(null!==localNames){let localIndex=tNode.index+1;for(let i=0;i<localNames.length;i+=2){const index=localNames[i+1],value=-1===index?localRefExtractor(tNode,viewData):viewData[index];viewData[localIndex++]=value}}}function getOrCreateComponentTView(def){const tView=def.tView;if(null===tView||tView.incompleteFirstPass){const declTNode=null;return def.tView=createTView(1,declTNode,def.template,def.decls,def.vars,def.directiveDefs,def.pipeDefs,def.viewQuery,def.schemas,def.consts,def.id)}return tView}function createTView(type,declTNode,templateFn,decls,vars,directives,pipes,viewQuery,schemas,constsOrFactory,ssrId){ngDevMode&&ngDevMode.tView++;const bindingStartIndex=HEADER_OFFSET+decls,initialViewLength=bindingStartIndex+vars,blueprint=function createViewBlueprint(bindingStartIndex,initialViewLength){const blueprint=[];for(let i=0;i<initialViewLength;i++)blueprint.push(i<bindingStartIndex?null:NO_CHANGE);return blueprint}(bindingStartIndex,initialViewLength),consts="function"==typeof constsOrFactory?constsOrFactory():constsOrFactory,tView=blueprint[TVIEW]={type,blueprint,template:templateFn,queries:null,viewQuery,declTNode,data:blueprint.slice().fill(null,bindingStartIndex),bindingStartIndex,expandoStartIndex:initialViewLength,hostBindingOpCodes:null,firstCreatePass:!0,firstUpdatePass:!0,staticViewQueries:!1,staticContentQueries:!1,preOrderHooks:null,preOrderCheckHooks:null,contentHooks:null,contentCheckHooks:null,viewHooks:null,viewCheckHooks:null,destroyHooks:null,cleanup:null,contentQueries:null,components:null,directiveRegistry:"function"==typeof directives?directives():directives,pipeRegistry:"function"==typeof pipes?pipes():pipes,firstChild:null,schemas,consts,incompleteFirstPass:!1,ssrId};return ngDevMode&&Object.seal(tView),tView}function locateHostElement(renderer,elementOrSelector,encapsulation,injector){const preserveContent=injector.get(PRESERVE_HOST_CONTENT,false)||encapsulation===ViewEncapsulation$1.ShadowDom,rootElement=renderer.selectRootElement(elementOrSelector,preserveContent);return function applyRootElementTransform(rootElement){_applyRootElementTransformImpl(rootElement)}(rootElement),rootElement}let _applyRootElementTransformImpl=()=>null;function captureNodeBindings(mode,aliasMap,directiveIndex,bindingsResult,hostDirectiveAliasMap){for(let publicName in aliasMap){if(!aliasMap.hasOwnProperty(publicName))continue;const value=aliasMap[publicName];if(void 0===value)continue;let internalName;bindingsResult??={};let inputFlags=InputFlags.None;Array.isArray(value)?(internalName=value[0],inputFlags=value[1]):internalName=value;let finalPublicName=publicName;if(null!==hostDirectiveAliasMap){if(!hostDirectiveAliasMap.hasOwnProperty(publicName))continue;finalPublicName=hostDirectiveAliasMap[publicName]}0===mode?addPropertyBinding(bindingsResult,directiveIndex,finalPublicName,internalName,inputFlags):addPropertyBinding(bindingsResult,directiveIndex,finalPublicName,internalName)}return bindingsResult}function addPropertyBinding(bindings,directiveIndex,publicName,internalName,inputFlags){let values;bindings.hasOwnProperty(publicName)?(values=bindings[publicName]).push(directiveIndex,internalName):values=bindings[publicName]=[directiveIndex,internalName],void 0!==inputFlags&&values.push(inputFlags)}function elementPropertyInternal(tView,tNode,lView,propName,value,renderer,sanitizer,nativeOnly){ngDevMode&&assertNotSame(value,NO_CHANGE,"Incoming value should never be NO_CHANGE.");const element=getNativeByTNode(tNode,lView);let dataValue,inputData=tNode.inputs;!nativeOnly&&null!=inputData&&(dataValue=inputData[propName])?(setInputsForProperty(tView,lView,dataValue,propName,value),isComponentHost(tNode)&&function markDirtyIfOnPush(lView,viewIndex){ngDevMode&&assertLView(lView);const childComponentLView=getComponentLViewByIndex(viewIndex,lView);16&childComponentLView[FLAGS]||(childComponentLView[FLAGS]|=64)}(lView,tNode.index),ngDevMode&&function setNgReflectProperties(lView,element,type,dataValue,value){if(7&type)for(let i=0;i<dataValue.length;i+=3)setNgReflectProperty(lView,element,type,dataValue[i+1],value)}(lView,element,tNode.type,dataValue,value)):3&tNode.type?(propName=function mapPropName(name){return"class"===name?"className":"for"===name?"htmlFor":"formaction"===name?"formAction":"innerHtml"===name?"innerHTML":"readonly"===name?"readOnly":"tabindex"===name?"tabIndex":name}(propName),ngDevMode&&(!function validateAgainstEventProperties(name){if(name.toLowerCase().startsWith("on")){const errorMessage=`Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...\nIf '${name}' is a directive input, make sure the directive is imported by the current module.`;throw new RuntimeError(306,errorMessage)}}(propName),function isPropertyValid(element,propName,tagName,schemas){return!(null!==schemas&&!(matchingSchemas(schemas,tagName)||propName in element||isAnimationProp(propName))&&"undefined"!=typeof Node&&null!==Node&&element instanceof Node)}(element,propName,tNode.value,tView.schemas)||handleUnknownPropertyError(propName,tNode.value,tNode.type,lView),ngDevMode.rendererSetProperty++),value=null!=sanitizer?sanitizer(value,tNode.value||"",propName):value,renderer.setProperty(element,propName,value)):12&tNode.type&&ngDevMode&&!matchingSchemas(tView.schemas,tNode.value)&&handleUnknownPropertyError(propName,tNode.value,tNode.type,lView)}function setNgReflectProperty(lView,element,type,attrName,value){const renderer=lView[RENDERER];attrName=normalizeDebugBindingName(attrName);const debugValue=function normalizeDebugBindingValue(value){try{return null!=value?value.toString().slice(0,30):value}catch(e){return"[ERROR] Exception while trying to serialize the value"}}(value);if(3&type)null==value?renderer.removeAttribute(element,attrName):renderer.setAttribute(element,attrName,debugValue);else{const textContent=escapeCommentText(`bindings=${JSON.stringify({[attrName]:debugValue},null,2)}`);renderer.setValue(element,textContent)}}function resolveDirectives(tView,lView,tNode,localRefs){if(ngDevMode&&assertFirstCreatePass(tView),getBindingsEnabled()){const exportsMap=null===localRefs?null:{"":-1},matchResult=function findDirectiveDefMatches(tView,tNode){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertTNodeType(tNode,15);const registry=tView.directiveRegistry;let matches=null,hostDirectiveDefs=null;if(registry)for(let i=0;i<registry.length;i++){const def=registry[i];if(isNodeMatchingSelectorList(tNode,def.selectors,!1))if(matches||(matches=[]),isComponentDef(def))if(ngDevMode&&(assertTNodeType(tNode,2,`"${tNode.value}" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`),isComponentHost(tNode)&&throwMultipleComponentError(tNode,matches.find(isComponentDef).type,def.type)),null!==def.findHostDirectiveDefs){const hostDirectiveMatches=[];hostDirectiveDefs=hostDirectiveDefs||new Map,def.findHostDirectiveDefs(def,hostDirectiveMatches,hostDirectiveDefs),matches.unshift(...hostDirectiveMatches,def);markAsComponentHost(tView,tNode,hostDirectiveMatches.length)}else matches.unshift(def),markAsComponentHost(tView,tNode,0);else hostDirectiveDefs=hostDirectiveDefs||new Map,def.findHostDirectiveDefs?.(def,matches,hostDirectiveDefs),matches.push(def)}return ngDevMode&&null!==matches&&assertNoDuplicateDirectives(matches),null===matches?null:[matches,hostDirectiveDefs]}(tView,tNode);let directiveDefs,hostDirectiveDefs;null===matchResult?directiveDefs=hostDirectiveDefs=null:[directiveDefs,hostDirectiveDefs]=matchResult,null!==directiveDefs&&initializeDirectives(tView,lView,tNode,directiveDefs,exportsMap,hostDirectiveDefs),exportsMap&&function cacheMatchingLocalNames(tNode,localRefs,exportsMap){if(localRefs){const localNames=tNode.localNames=[];for(let i=0;i<localRefs.length;i+=2){const index=exportsMap[localRefs[i+1]];if(null==index)throw new RuntimeError(-301,ngDevMode&&`Export of name '${localRefs[i+1]}' not found!`);localNames.push(localRefs[i],index)}}}(tNode,localRefs,exportsMap)}tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,tNode.attrs)}function initializeDirectives(tView,lView,tNode,directives,exportsMap,hostDirectiveDefs){ngDevMode&&assertFirstCreatePass(tView);for(let i=0;i<directives.length;i++)diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,directives[i].type);!function initTNodeFlags(tNode,index,numberOfDirectives){ngDevMode&&assertNotEqual(numberOfDirectives,tNode.directiveEnd-tNode.directiveStart,"Reached the max number of directives"),tNode.flags|=1,tNode.directiveStart=index,tNode.directiveEnd=index+numberOfDirectives,tNode.providerIndexes=index}(tNode,tView.data.length,directives.length);for(let i=0;i<directives.length;i++){const def=directives[i];def.providersResolver&&def.providersResolver(def)}let preOrderHooksFound=!1,preOrderCheckHooksFound=!1,directiveIdx=allocExpando(tView,lView,directives.length,null);ngDevMode&&assertSame(directiveIdx,tNode.directiveStart,"TNode.directiveStart should point to just allocated space");for(let i=0;i<directives.length;i++){const def=directives[i];tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs),configureViewWithDirective(tView,tNode,lView,directiveIdx,def),saveNameToExportMap(directiveIdx,def,exportsMap),null!==def.contentQueries&&(tNode.flags|=4),null===def.hostBindings&&null===def.hostAttrs&&0===def.hostVars||(tNode.flags|=64);const lifeCycleHooks=def.type.prototype;!preOrderHooksFound&&(lifeCycleHooks.ngOnChanges||lifeCycleHooks.ngOnInit||lifeCycleHooks.ngDoCheck)&&((tView.preOrderHooks??=[]).push(tNode.index),preOrderHooksFound=!0),preOrderCheckHooksFound||!lifeCycleHooks.ngOnChanges&&!lifeCycleHooks.ngDoCheck||((tView.preOrderCheckHooks??=[]).push(tNode.index),preOrderCheckHooksFound=!0),directiveIdx++}!function initializeInputAndOutputAliases(tView,tNode,hostDirectiveDefinitionMap){ngDevMode&&assertFirstCreatePass(tView);const start=tNode.directiveStart,end=tNode.directiveEnd,tViewData=tView.data,tNodeAttrs=tNode.attrs,inputsFromAttrs=[];let inputsStore=null,outputsStore=null;for(let directiveIndex=start;directiveIndex<end;directiveIndex++){const directiveDef=tViewData[directiveIndex],aliasData=hostDirectiveDefinitionMap?hostDirectiveDefinitionMap.get(directiveDef):null,aliasedInputs=aliasData?aliasData.inputs:null,aliasedOutputs=aliasData?aliasData.outputs:null;inputsStore=captureNodeBindings(0,directiveDef.inputs,directiveIndex,inputsStore,aliasedInputs),outputsStore=captureNodeBindings(1,directiveDef.outputs,directiveIndex,outputsStore,aliasedOutputs);const initialInputs=null===inputsStore||null===tNodeAttrs||isInlineTemplate(tNode)?null:generateInitialInputs(inputsStore,directiveIndex,tNodeAttrs);inputsFromAttrs.push(initialInputs)}null!==inputsStore&&(inputsStore.hasOwnProperty("class")&&(tNode.flags|=8),inputsStore.hasOwnProperty("style")&&(tNode.flags|=16)),tNode.initialInputs=inputsFromAttrs,tNode.inputs=inputsStore,tNode.outputs=outputsStore}(tView,tNode,hostDirectiveDefs)}function invokeDirectivesHostBindings(tView,lView,tNode){const start=tNode.directiveStart,end=tNode.directiveEnd,elementIndex=tNode.index,currentDirectiveIndex=function getCurrentDirectiveIndex(){return instructionState.lFrame.currentDirectiveIndex}();try{setSelectedIndex(elementIndex);for(let dirIndex=start;dirIndex<end;dirIndex++){const def=tView.data[dirIndex],directive=lView[dirIndex];setCurrentDirectiveIndex(dirIndex),null===def.hostBindings&&0===def.hostVars&&null===def.hostAttrs||invokeHostBindingsInCreationMode(def,directive)}}finally{setSelectedIndex(-1),setCurrentDirectiveIndex(currentDirectiveIndex)}}function invokeHostBindingsInCreationMode(def,directive){null!==def.hostBindings&&def.hostBindings(1,directive)}function markAsComponentHost(tView,hostTNode,componentOffset){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&assertGreaterThan(componentOffset,-1,"componentOffset must be great than -1"),hostTNode.componentOffset=componentOffset,(tView.components??=[]).push(hostTNode.index)}function saveNameToExportMap(directiveIdx,def,exportsMap){if(exportsMap){if(def.exportAs)for(let i=0;i<def.exportAs.length;i++)exportsMap[def.exportAs[i]]=directiveIdx;isComponentDef(def)&&(exportsMap[""]=directiveIdx)}}function configureViewWithDirective(tView,tNode,lView,directiveIndex,def){ngDevMode&&assertGreaterThanOrEqual(directiveIndex,HEADER_OFFSET,"Must be in Expando section"),tView.data[directiveIndex]=def;const directiveFactory=def.factory||(def.factory=getFactoryDef(def.type,!0)),nodeInjectorFactory=new NodeInjectorFactory(directiveFactory,isComponentDef(def),ɵɵdirectiveInject);tView.blueprint[directiveIndex]=nodeInjectorFactory,lView[directiveIndex]=nodeInjectorFactory,function registerHostBindingOpCodes(tView,tNode,directiveIdx,directiveVarsIdx,def){ngDevMode&&assertFirstCreatePass(tView);const hostBindings=def.hostBindings;if(hostBindings){let hostBindingOpCodes=tView.hostBindingOpCodes;null===hostBindingOpCodes&&(hostBindingOpCodes=tView.hostBindingOpCodes=[]);const elementIndx=~tNode.index;(function lastSelectedElementIdx(hostBindingOpCodes){let i=hostBindingOpCodes.length;for(;i>0;){const value=hostBindingOpCodes[--i];if("number"==typeof value&&value<0)return value}return 0})(hostBindingOpCodes)!=elementIndx&&hostBindingOpCodes.push(elementIndx),hostBindingOpCodes.push(directiveIdx,directiveVarsIdx,hostBindings)}}(tView,tNode,directiveIndex,allocExpando(tView,lView,def.hostVars,NO_CHANGE),def)}function elementAttributeInternal(tNode,lView,name,value,sanitizer,namespace){ngDevMode&&(assertNotSame(value,NO_CHANGE,"Incoming value should never be NO_CHANGE."),function validateAgainstEventAttributes(name){if(name.toLowerCase().startsWith("on")){const errorMessage=`Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;throw new RuntimeError(306,errorMessage)}}(name),assertTNodeType(tNode,2,`Attempted to set attribute \`${name}\` on a container node. Host bindings are not valid on ng-container or ng-template.`));const element=getNativeByTNode(tNode,lView);setElementAttribute(lView[RENDERER],element,namespace,tNode.value,name,value,sanitizer)}function setElementAttribute(renderer,element,namespace,tagName,name,value,sanitizer){if(null==value)ngDevMode&&ngDevMode.rendererRemoveAttribute++,renderer.removeAttribute(element,name,namespace);else{ngDevMode&&ngDevMode.rendererSetAttribute++;const strValue=null==sanitizer?renderStringify(value):sanitizer(value,tagName||"",name);renderer.setAttribute(element,name,strValue,namespace)}}function setInputsFromAttrs(lView,directiveIndex,instance,def,tNode,initialInputData){const initialInputs=initialInputData[directiveIndex];if(null!==initialInputs)for(let i=0;i<initialInputs.length;){const publicName=initialInputs[i++],privateName=initialInputs[i++],flags=initialInputs[i++],value=initialInputs[i++];if(writeToDirectiveInput(def,instance,publicName,privateName,flags,value),ngDevMode){setNgReflectProperty(lView,getNativeByTNode(tNode,lView),tNode.type,privateName,value)}}}function generateInitialInputs(inputs,directiveIndex,attrs){let inputsToStore=null,i=0;for(;i<attrs.length;){const attrName=attrs[i];if(0!==attrName)if(5!==attrName){if("number"==typeof attrName)break;if(inputs.hasOwnProperty(attrName)){null===inputsToStore&&(inputsToStore=[]);const inputConfig=inputs[attrName];for(let j=0;j<inputConfig.length;j+=3)if(inputConfig[j]===directiveIndex){inputsToStore.push(attrName,inputConfig[j+1],inputConfig[j+2],attrs[i+1]);break}}i+=2}else i+=2;else i+=4}return inputsToStore}function createLContainer(hostNative,currentView,native,tNode){ngDevMode&&assertLView(currentView);const lContainer=[hostNative,!0,0,currentView,null,tNode,null,native,null,null];return ngDevMode&&assertEqual(lContainer.length,CONTAINER_HEADER_OFFSET,"Should allocate correct number of slots for LContainer header."),lContainer}function refreshContentQueries(tView,lView){const contentQueries=tView.contentQueries;if(null!==contentQueries){const prevConsumer=setActiveConsumer(null);try{for(let i=0;i<contentQueries.length;i+=2){const queryStartIdx=contentQueries[i],directiveDefIdx=contentQueries[i+1];if(-1!==directiveDefIdx){const directiveDef=tView.data[directiveDefIdx];ngDevMode&&assertDefined(directiveDef,"DirectiveDef not found."),ngDevMode&&assertDefined(directiveDef.contentQueries,"contentQueries function should be defined"),setCurrentQueryIndex(queryStartIdx),directiveDef.contentQueries(2,lView[directiveDefIdx],directiveDefIdx)}}}finally{setActiveConsumer(prevConsumer)}}}function addToViewTree(lView,lViewOrLContainer){return lView[CHILD_HEAD]?lView[CHILD_TAIL][NEXT]=lViewOrLContainer:lView[CHILD_HEAD]=lViewOrLContainer,lView[CHILD_TAIL]=lViewOrLContainer,lViewOrLContainer}function executeViewQueryFn(flags,viewQueryFn,component){ngDevMode&&assertDefined(viewQueryFn,"View queries function to execute must be defined."),setCurrentQueryIndex(0);const prevConsumer=setActiveConsumer(null);try{viewQueryFn(flags,component)}finally{setActiveConsumer(prevConsumer)}}function storePropertyBindingMetadata(tData,tNode,propertyName,bindingIndex,...interpolationParts){if(null===tData[bindingIndex]&&(null==tNode.inputs||!tNode.inputs[propertyName])){(tNode.propertyBindings||(tNode.propertyBindings=[])).push(bindingIndex);let bindingMetadata=propertyName;interpolationParts.length>0&&(bindingMetadata+=INTERPOLATION_DELIMITER+interpolationParts.join(INTERPOLATION_DELIMITER)),tData[bindingIndex]=bindingMetadata}}function getOrCreateLViewCleanup(view){return view[CLEANUP]||(view[CLEANUP]=[])}function getOrCreateTViewCleanup(tView){return tView.cleanup||(tView.cleanup=[])}function loadComponentRenderer(currentDef,tNode,lView){return(null===currentDef||isComponentDef(currentDef))&&(lView=unwrapLView(lView[tNode.index])),lView[RENDERER]}function handleError(lView,error){const injector=lView[INJECTOR],errorHandler=injector?injector.get(ErrorHandler,null):null;errorHandler&&errorHandler.handleError(error)}function setInputsForProperty(tView,lView,inputs,publicName,value){for(let i=0;i<inputs.length;){const index=inputs[i++],privateName=inputs[i++],flags=inputs[i++],instance=lView[index];ngDevMode&&assertIndexInRange(lView,index);writeToDirectiveInput(tView.data[index],instance,publicName,privateName,flags,value)}}function textBindingInternal(lView,index,value){ngDevMode&&assertString(value,"Value should be a string"),ngDevMode&&assertNotSame(value,NO_CHANGE,"value should not be NO_CHANGE"),ngDevMode&&assertIndexInRange(lView,index);const element=getNativeByIndex(index,lView);ngDevMode&&assertDefined(element,"native element should exist"),updateTextNode(lView[RENDERER],element,value)}function renderComponent(hostLView,componentHostIdx){ngDevMode&&assertEqual(isCreationMode(hostLView),!0,"Should be run in creation mode");const componentView=getComponentLViewByIndex(componentHostIdx,hostLView),componentTView=componentView[TVIEW];!function syncViewWithBlueprint(tView,lView){for(let i=lView.length;i<tView.blueprint.length;i++)lView.push(tView.blueprint[i])}(componentTView,componentView);const hostRNode=componentView[HOST];null!==hostRNode&&null===componentView[HYDRATION]&&(componentView[HYDRATION]=retrieveHydrationInfo(hostRNode,componentView[INJECTOR])),renderView(componentTView,componentView,componentView[CONTEXT])}function renderView(tView,lView,context){ngDevMode&&assertEqual(isCreationMode(lView),!0,"Should be run in creation mode"),ngDevMode&&assertNotReactive(renderView.name),enterView(lView);try{const viewQuery=tView.viewQuery;null!==viewQuery&&executeViewQueryFn(1,viewQuery,context);const templateFn=tView.template;null!==templateFn&&executeTemplate(tView,lView,templateFn,1,context),tView.firstCreatePass&&(tView.firstCreatePass=!1),lView[QUERIES]?.finishViewCreation(tView),tView.staticContentQueries&&refreshContentQueries(tView,lView),tView.staticViewQueries&&executeViewQueryFn(2,tView.viewQuery,context);const components=tView.components;null!==components&&function renderChildComponents(hostLView,components){for(let i=0;i<components.length;i++)renderComponent(hostLView,components[i])}(lView,components)}catch(error){throw tView.firstCreatePass&&(tView.incompleteFirstPass=!0,tView.firstCreatePass=!1),error}finally{lView[FLAGS]&=-5,leaveView()}}function createAndRenderEmbeddedLView(declarationLView,templateTNode,context,options){const prevConsumer=setActiveConsumer(null);try{const embeddedTView=templateTNode.tView;ngDevMode&&assertDefined(embeddedTView,"TView must be defined for a template node."),ngDevMode&&assertTNodeForLView(templateTNode,declarationLView);const isSignalView=4096&declarationLView[FLAGS],embeddedLView=createLView(declarationLView,embeddedTView,context,isSignalView?4096:16,null,templateTNode,null,null,options?.injector??null,options?.embeddedViewInjector??null,options?.dehydratedView??null),declarationLContainer=declarationLView[templateTNode.index];ngDevMode&&assertLContainer(declarationLContainer),embeddedLView[DECLARATION_LCONTAINER]=declarationLContainer;const declarationViewLQueries=declarationLView[QUERIES];return null!==declarationViewLQueries&&(embeddedLView[QUERIES]=declarationViewLQueries.createEmbeddedView(embeddedTView)),renderView(embeddedTView,embeddedLView,context),embeddedLView}finally{setActiveConsumer(prevConsumer)}}function getLViewFromLContainer(lContainer,index){const adjustedIndex=CONTAINER_HEADER_OFFSET+index;if(adjustedIndex<lContainer.length){const lView=lContainer[adjustedIndex];return ngDevMode&&assertLView(lView),lView}}function shouldAddViewToDom(tNode,dehydratedView){return!dehydratedView||null===dehydratedView.firstChild||hasInSkipHydrationBlockFlag(tNode)}function addLViewToLContainer(lContainer,lView,index,addToDOM=!0){const tView=lView[TVIEW];if(insertView(tView,lView,lContainer,index),addToDOM){const beforeNode=getBeforeNodeForView(index,lContainer),renderer=lView[RENDERER],parentRNode=nativeParentNode(renderer,lContainer[NATIVE]);null!==parentRNode&&function addViewToDOM(tView,parentTNode,renderer,lView,parentNativeNode,beforeNode){lView[HOST]=parentNativeNode,lView[T_HOST]=parentTNode,applyView(tView,lView,renderer,1,parentNativeNode,beforeNode)}(tView,lContainer[T_HOST],renderer,lView,parentRNode,beforeNode)}const hydrationInfo=lView[HYDRATION];null!==hydrationInfo&&null!==hydrationInfo.firstChild&&(hydrationInfo.firstChild=null)}function removeLViewFromLContainer(lContainer,index){const lView=detachView(lContainer,index);return void 0!==lView&&destroyLView(lView[TVIEW],lView),lView}function collectNativeNodes(tView,lView,tNode,result,isProjection=!1){for(;null!==tNode;){ngDevMode&&assertTNodeType(tNode,63);const lNode=lView[tNode.index];null!==lNode&&result.push(unwrapRNode(lNode)),isLContainer(lNode)&&collectNativeNodesInLContainer(lNode,result);const tNodeType=tNode.type;if(8&tNodeType)collectNativeNodes(tView,lView,tNode.child,result);else if(32&tNodeType){const nextRNode=icuContainerIterate(tNode,lView);let rNode;for(;rNode=nextRNode();)result.push(rNode)}else if(16&tNodeType){const nodesInSlot=getProjectionNodes(lView,tNode);if(Array.isArray(nodesInSlot))result.push(...nodesInSlot);else{const parentView=getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);ngDevMode&&assertParentView(parentView),collectNativeNodes(parentView[TVIEW],parentView,nodesInSlot,result,!0)}}tNode=isProjection?tNode.projectionNext:tNode.next}return result}function collectNativeNodesInLContainer(lContainer,result){for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){const lViewInAContainer=lContainer[i],lViewFirstChildTNode=lViewInAContainer[TVIEW].firstChild;null!==lViewFirstChildTNode&&collectNativeNodes(lViewInAContainer[TVIEW],lViewInAContainer,lViewFirstChildTNode,result)}lContainer[NATIVE]!==lContainer[HOST]&&result.push(lContainer[NATIVE])}let freeConsumers=[];function getOrBorrowReactiveLViewConsumer(lView){return lView[REACTIVE_TEMPLATE_CONSUMER]??function borrowReactiveLViewConsumer(lView){const consumer=freeConsumers.pop()??Object.create(REACTIVE_LVIEW_CONSUMER_NODE);return consumer.lView=lView,consumer}(lView)}const REACTIVE_LVIEW_CONSUMER_NODE={...REACTIVE_NODE,consumerIsAlwaysLive:!0,consumerMarkedDirty:node=>{markAncestorsForTraversal(node.lView)},consumerOnSignalRead(){this.lView[REACTIVE_TEMPLATE_CONSUMER]=this}},MAXIMUM_REFRESH_RERUNS=100;function detectChangesInternal(lView,notifyErrorHandler=!0,mode=0){const environment=lView[ENVIRONMENT],rendererFactory=environment.rendererFactory,checkNoChangesMode=!!ngDevMode&&isInCheckNoChangesMode();checkNoChangesMode||rendererFactory.begin?.();try{!function detectChangesInViewWhileDirty(lView,mode){detectChangesInView$1(lView,mode);let retries=0;for(;requiresRefreshOrTraversal(lView);){if(retries===MAXIMUM_REFRESH_RERUNS)throw new RuntimeError(103,ngDevMode&&"Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.");retries++,detectChangesInView$1(lView,1)}}(lView,mode)}catch(error){throw notifyErrorHandler&&handleError(lView,error),error}finally{checkNoChangesMode||(rendererFactory.end?.(),environment.inlineEffectRunner?.flush())}}function refreshView(tView,lView,templateFn,context){ngDevMode&&assertEqual(isCreationMode(lView),!1,"Should be run in update mode");const flags=lView[FLAGS];if(!(256&~flags))return;const isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode();!isInCheckNoChangesPass&&lView[ENVIRONMENT].inlineEffectRunner?.flush(),enterView(lView);let prevConsumer=null,currentConsumer=null;!isInCheckNoChangesPass&&function viewShouldHaveReactiveConsumer(tView){return 2!==tView.type}(tView)&&(currentConsumer=getOrBorrowReactiveLViewConsumer(lView),prevConsumer=consumerBeforeComputation(currentConsumer));try{resetPreOrderHookFlags(lView),setBindingIndex(tView.bindingStartIndex),null!==templateFn&&executeTemplate(tView,lView,templateFn,2,context);const hooksInitPhaseCompleted=!(3&~flags);if(!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const preOrderCheckHooks=tView.preOrderCheckHooks;null!==preOrderCheckHooks&&executeCheckHooks(lView,preOrderCheckHooks,null)}else{const preOrderHooks=tView.preOrderHooks;null!==preOrderHooks&&executeInitAndCheckHooks(lView,preOrderHooks,0,null),incrementInitPhaseFlags(lView,0)}if(function markTransplantedViewsForRefresh(lView){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer)){if(!(lContainer[FLAGS]&LContainerFlags.HasTransplantedViews))continue;const movedViews=lContainer[MOVED_VIEWS];ngDevMode&&assertDefined(movedViews,"Transplanted View flags set but missing MOVED_VIEWS");for(let i=0;i<movedViews.length;i++){const movedLView=movedViews[i],insertionLContainer=movedLView[PARENT];ngDevMode&&assertLContainer(insertionLContainer),markViewForRefresh(movedLView)}}}(lView),detectChangesInEmbeddedViews(lView,0),null!==tView.contentQueries&&refreshContentQueries(tView,lView),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const contentCheckHooks=tView.contentCheckHooks;null!==contentCheckHooks&&executeCheckHooks(lView,contentCheckHooks)}else{const contentHooks=tView.contentHooks;null!==contentHooks&&executeInitAndCheckHooks(lView,contentHooks,1),incrementInitPhaseFlags(lView,1)}!function processHostBindingOpCodes(tView,lView){const hostBindingOpCodes=tView.hostBindingOpCodes;if(null!==hostBindingOpCodes)try{for(let i=0;i<hostBindingOpCodes.length;i++){const opCode=hostBindingOpCodes[i];if(opCode<0)setSelectedIndex(~opCode);else{const directiveIdx=opCode,bindingRootIndx=hostBindingOpCodes[++i],hostBindingFn=hostBindingOpCodes[++i];setBindingRootForHostBindings(bindingRootIndx,directiveIdx),hostBindingFn(2,lView[directiveIdx])}}}finally{setSelectedIndex(-1)}}(tView,lView);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,0);const viewQuery=tView.viewQuery;if(null!==viewQuery&&executeViewQueryFn(2,viewQuery,context),!isInCheckNoChangesPass)if(hooksInitPhaseCompleted){const viewCheckHooks=tView.viewCheckHooks;null!==viewCheckHooks&&executeCheckHooks(lView,viewCheckHooks)}else{const viewHooks=tView.viewHooks;null!==viewHooks&&executeInitAndCheckHooks(lView,viewHooks,2),incrementInitPhaseFlags(lView,2)}if(!0===tView.firstUpdatePass&&(tView.firstUpdatePass=!1),lView[EFFECTS_TO_SCHEDULE]){for(const notifyEffect of lView[EFFECTS_TO_SCHEDULE])notifyEffect();lView[EFFECTS_TO_SCHEDULE]=null}isInCheckNoChangesPass||(lView[FLAGS]&=-73)}catch(e){throw markAncestorsForTraversal(lView),e}finally{null!==currentConsumer&&(consumerAfterComputation(currentConsumer,prevConsumer),function maybeReturnReactiveLViewConsumer(consumer){consumer.lView[REACTIVE_TEMPLATE_CONSUMER]!==consumer&&(consumer.lView=null,freeConsumers.push(consumer))}(currentConsumer)),leaveView()}}function detectChangesInEmbeddedViews(lView,mode){for(let lContainer=getFirstLContainer(lView);null!==lContainer;lContainer=getNextLContainer(lContainer))for(let i=CONTAINER_HEADER_OFFSET;i<lContainer.length;i++){detectChangesInViewIfAttached(lContainer[i],mode)}}function detectChangesInComponent(hostLView,componentHostIdx,mode){ngDevMode&&assertEqual(isCreationMode(hostLView),!1,"Should be run in update mode");detectChangesInViewIfAttached(getComponentLViewByIndex(componentHostIdx,hostLView),mode)}function detectChangesInViewIfAttached(lView,mode){viewAttachedToChangeDetector(lView)&&detectChangesInView$1(lView,mode)}function detectChangesInView$1(lView,mode){const isInCheckNoChangesPass=ngDevMode&&isInCheckNoChangesMode(),tView=lView[TVIEW],flags=lView[FLAGS],consumer=lView[REACTIVE_TEMPLATE_CONSUMER];let shouldRefreshView=!!(0===mode&&16&flags);if(shouldRefreshView||=!(!(64&flags&&0===mode)||isInCheckNoChangesPass),shouldRefreshView||=!!(1024&flags),shouldRefreshView||=!(!consumer?.dirty||!consumerPollProducersForChange(consumer)),consumer&&(consumer.dirty=!1),lView[FLAGS]&=-9217,shouldRefreshView)refreshView(tView,lView,tView.template,lView[CONTEXT]);else if(8192&flags){detectChangesInEmbeddedViews(lView,1);const components=tView.components;null!==components&&detectChangesInChildComponents(lView,components,1)}}function detectChangesInChildComponents(hostLView,components,mode){for(let i=0;i<components.length;i++)detectChangesInComponent(hostLView,components[i],mode)}function markViewDirty(lView){for(lView[ENVIRONMENT].changeDetectionScheduler?.notify();lView;){lView[FLAGS]|=64;const parent=getLViewParent(lView);if(isRootView(lView)&&!parent)return lView;lView=parent}return null}class ViewRef$1{get rootNodes(){const lView=this._lView,tView=lView[TVIEW];return collectNativeNodes(tView,lView,tView.firstChild,[])}constructor(_lView,_cdRefInjectingView,notifyErrorHandler=!0){this._lView=_lView,this._cdRefInjectingView=_cdRefInjectingView,this.notifyErrorHandler=notifyErrorHandler,this._appRef=null,this._attachedToViewContainer=!1}get context(){return this._lView[CONTEXT]}set context(value){ngDevMode&&console.warn("Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated."),this._lView[CONTEXT]=value}get destroyed(){return!(256&~this._lView[FLAGS])}destroy(){if(this._appRef)this._appRef.detachView(this);else if(this._attachedToViewContainer){const parent=this._lView[PARENT];if(isLContainer(parent)){const viewRefs=parent[8],index=viewRefs?viewRefs.indexOf(this):-1;index>-1&&(ngDevMode&&assertEqual(index,parent.indexOf(this._lView)-CONTAINER_HEADER_OFFSET,"An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array."),detachView(parent,index),removeFromArray(viewRefs,index))}this._attachedToViewContainer=!1}destroyLView(this._lView[TVIEW],this._lView)}onDestroy(callback){storeLViewOnDestroy(this._lView,callback)}markForCheck(){markViewDirty(this._cdRefInjectingView||this._lView)}detach(){this._lView[FLAGS]&=-129}reattach(){updateAncestorTraversalFlagsOnAttach(this._lView),this._lView[FLAGS]|=128}detectChanges(){this._lView[FLAGS]|=1024,detectChangesInternal(this._lView,this.notifyErrorHandler)}checkNoChanges(){ngDevMode&&function checkNoChangesInternal(lView,notifyErrorHandler=!0){setIsInCheckNoChangesMode(!0);try{detectChangesInternal(lView,notifyErrorHandler)}finally{setIsInCheckNoChangesMode(!1)}}(this._lView,this.notifyErrorHandler)}attachToViewContainerRef(){if(this._appRef)throw new RuntimeError(902,ngDevMode&&"This view is already attached directly to the ApplicationRef!");this._attachedToViewContainer=!0}detachFromAppRef(){this._appRef=null,detachViewFromDOM(this._lView[TVIEW],this._lView)}attachToAppRef(appRef){if(this._attachedToViewContainer)throw new RuntimeError(902,ngDevMode&&"This view is already attached to a ViewContainer!");this._appRef=appRef,updateAncestorTraversalFlagsOnAttach(this._lView)}}class TemplateRef{static#_=this.__NG_ELEMENT_ID__=injectTemplateRef}const ViewEngineTemplateRef=TemplateRef,R3TemplateRef=class TemplateRef extends ViewEngineTemplateRef{constructor(_declarationLView,_declarationTContainer,elementRef){super(),this._declarationLView=_declarationLView,this._declarationTContainer=_declarationTContainer,this.elementRef=elementRef}get ssrId(){return this._declarationTContainer.tView?.ssrId||null}createEmbeddedView(context,injector){return this.createEmbeddedViewImpl(context,injector)}createEmbeddedViewImpl(context,injector,dehydratedView){const embeddedLView=createAndRenderEmbeddedLView(this._declarationLView,this._declarationTContainer,context,{embeddedViewInjector:injector,dehydratedView});return new ViewRef$1(embeddedLView)}};function injectTemplateRef(){return createTemplateRef(getCurrentTNode(),getLView())}function createTemplateRef(hostTNode,hostLView){return 4&hostTNode.type?(ngDevMode&&assertDefined(hostTNode.tView,"TView must be allocated"),new R3TemplateRef(hostLView,hostTNode,createElementRef(hostTNode,hostLView))):null}new Set(["ngh","ng-version","ng-server-context"]);new RegExp(`^(\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);let _findMatchingDehydratedViewImpl=()=>null;function findMatchingDehydratedView(lContainer,template){return _findMatchingDehydratedViewImpl(lContainer,template)}class ChangeDetectionScheduler{}class ComponentRef$1{}class ComponentFactory$1{}const ERROR_COMPONENT="ngComponent";class _NullComponentFactoryResolver{resolveComponentFactory(component){throw function noComponentFactoryError(component){const error=Error(`No component factory found for ${stringify(component)}.`);return error[ERROR_COMPONENT]=component,error}(component)}}class ComponentFactoryResolver$1{static#_=this.NULL=new _NullComponentFactoryResolver}class RendererFactory2{}class Renderer2{constructor(){this.destroyNode=null}static#_=this.__NG_ELEMENT_ID__=()=>function injectRenderer2(){const lView=getLView(),nodeAtIndex=getComponentLViewByIndex(getCurrentTNode().index,lView);return(isLView(nodeAtIndex)?nodeAtIndex:lView)[RENDERER]}()}class Sanitizer{static#_=this.ɵprov=ɵɵdefineInjectable({token:Sanitizer,providedIn:"root",factory:()=>null})}const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR={};function assertNotInReactiveContext(debugFn,extraContext){if(null!==getActiveConsumer())throw new RuntimeError(-602,ngDevMode&&`${debugFn.name}() cannot be called from within a reactive context.${extraContext?` ${extraContext}`:""}`)}const markedFeatures=new Set;function performanceMarkFeature(feature){markedFeatures.has(feature)||(markedFeatures.add(feature),performance?.mark?.("mark_feature_usage",{detail:{feature}}))}function noop(...args){}class AsyncStackTaggingZoneSpec{constructor(namePrefix,consoleAsyncStackTaggingImpl=console){this.name="asyncStackTagging for "+namePrefix,this.createTask=consoleAsyncStackTaggingImpl?.createTask??(()=>null)}onScheduleTask(delegate,_current,target,task){return task.consoleTask=this.createTask(`Zone - ${task.source||task.type}`),delegate.scheduleTask(target,task)}onInvokeTask(delegate,_currentZone,targetZone,task,applyThis,applyArgs){let ret;return ret=task.consoleTask?task.consoleTask.run((()=>delegate.invokeTask(targetZone,task,applyThis,applyArgs))):delegate.invokeTask(targetZone,task,applyThis,applyArgs),ret}}class NgZone{constructor({enableLongStackTrace=!1,shouldCoalesceEventChangeDetection=!1,shouldCoalesceRunChangeDetection=!1}){if(this.hasPendingMacrotasks=!1,this.hasPendingMicrotasks=!1,this.isStable=!0,this.onUnstable=new EventEmitter(!1),this.onMicrotaskEmpty=new EventEmitter(!1),this.onStable=new EventEmitter(!1),this.onError=new EventEmitter(!1),"undefined"==typeof Zone)throw new RuntimeError(908,ngDevMode&&"In this configuration Angular requires Zone.js");Zone.assertZonePatched();const self=this;self._nesting=0,self._outer=self._inner=Zone.current,ngDevMode&&(self._inner=self._inner.fork(new AsyncStackTaggingZoneSpec("Angular"))),Zone.TaskTrackingZoneSpec&&(self._inner=self._inner.fork(new Zone.TaskTrackingZoneSpec)),enableLongStackTrace&&Zone.longStackTraceZoneSpec&&(self._inner=self._inner.fork(Zone.longStackTraceZoneSpec)),self.shouldCoalesceEventChangeDetection=!shouldCoalesceRunChangeDetection&&shouldCoalesceEventChangeDetection,self.shouldCoalesceRunChangeDetection=shouldCoalesceRunChangeDetection,self.lastRequestAnimationFrameId=-1,self.nativeRequestAnimationFrame=function getNativeRequestAnimationFrame(){const isBrowser="function"==typeof _global.requestAnimationFrame;let nativeRequestAnimationFrame=_global[isBrowser?"requestAnimationFrame":"setTimeout"],nativeCancelAnimationFrame=_global[isBrowser?"cancelAnimationFrame":"clearTimeout"];if("undefined"!=typeof Zone&&nativeRequestAnimationFrame&&nativeCancelAnimationFrame){const unpatchedRequestAnimationFrame=nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];unpatchedRequestAnimationFrame&&(nativeRequestAnimationFrame=unpatchedRequestAnimationFrame);const unpatchedCancelAnimationFrame=nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];unpatchedCancelAnimationFrame&&(nativeCancelAnimationFrame=unpatchedCancelAnimationFrame)}return{nativeRequestAnimationFrame,nativeCancelAnimationFrame}}().nativeRequestAnimationFrame,function forkInnerZoneWithAngularBehavior(zone){const delayChangeDetectionForEventsDelegate=()=>{!function delayChangeDetectionForEvents(zone){if(zone.isCheckStableRunning||-1!==zone.lastRequestAnimationFrameId)return;zone.lastRequestAnimationFrameId=zone.nativeRequestAnimationFrame.call(_global,(()=>{zone.fakeTopEventTask||(zone.fakeTopEventTask=Zone.root.scheduleEventTask("fakeTopEventTask",(()=>{zone.lastRequestAnimationFrameId=-1,updateMicroTaskStatus(zone),zone.isCheckStableRunning=!0,checkStable(zone),zone.isCheckStableRunning=!1}),void 0,(()=>{}),(()=>{}))),zone.fakeTopEventTask.invoke()})),updateMicroTaskStatus(zone)}(zone)};zone._inner=zone._inner.fork({name:"angular",properties:{isAngularZone:!0},onInvokeTask:(delegate,current,target,task,applyThis,applyArgs)=>{if(function shouldBeIgnoredByZone(applyArgs){if(!Array.isArray(applyArgs))return!1;if(1!==applyArgs.length)return!1;return!0===applyArgs[0].data?.__ignore_ng_zone__}(applyArgs))return delegate.invokeTask(target,task,applyThis,applyArgs);try{return onEnter(zone),delegate.invokeTask(target,task,applyThis,applyArgs)}finally{(zone.shouldCoalesceEventChangeDetection&&"eventTask"===task.type||zone.shouldCoalesceRunChangeDetection)&&delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onInvoke:(delegate,current,target,callback,applyThis,applyArgs,source)=>{try{return onEnter(zone),delegate.invoke(target,callback,applyThis,applyArgs,source)}finally{zone.shouldCoalesceRunChangeDetection&&delayChangeDetectionForEventsDelegate(),onLeave(zone)}},onHasTask:(delegate,current,target,hasTaskState)=>{delegate.hasTask(target,hasTaskState),current===target&&("microTask"==hasTaskState.change?(zone._hasPendingMicrotasks=hasTaskState.microTask,updateMicroTaskStatus(zone),checkStable(zone)):"macroTask"==hasTaskState.change&&(zone.hasPendingMacrotasks=hasTaskState.macroTask))},onHandleError:(delegate,current,target,error)=>(delegate.handleError(target,error),zone.runOutsideAngular((()=>zone.onError.emit(error))),!1)})}(self)}static isInAngularZone(){return"undefined"!=typeof Zone&&!0===Zone.current.get("isAngularZone")}static assertInAngularZone(){if(!NgZone.isInAngularZone())throw new RuntimeError(909,ngDevMode&&"Expected to be in Angular Zone, but it is not!")}static assertNotInAngularZone(){if(NgZone.isInAngularZone())throw new RuntimeError(909,ngDevMode&&"Expected to not be in Angular Zone, but it is!")}run(fn,applyThis,applyArgs){return this._inner.run(fn,applyThis,applyArgs)}runTask(fn,applyThis,applyArgs,name){const zone=this._inner,task=zone.scheduleEventTask("NgZoneEvent: "+name,fn,EMPTY_PAYLOAD,noop,noop);try{return zone.runTask(task,applyThis,applyArgs)}finally{zone.cancelTask(task)}}runGuarded(fn,applyThis,applyArgs){return this._inner.runGuarded(fn,applyThis,applyArgs)}runOutsideAngular(fn){return this._outer.run(fn)}}const EMPTY_PAYLOAD={};function checkStable(zone){if(0==zone._nesting&&!zone.hasPendingMicrotasks&&!zone.isStable)try{zone._nesting++,zone.onMicrotaskEmpty.emit(null)}finally{if(zone._nesting--,!zone.hasPendingMicrotasks)try{zone.runOutsideAngular((()=>zone.onStable.emit(null)))}finally{zone.isStable=!0}}}function updateMicroTaskStatus(zone){zone._hasPendingMicrotasks||(zone.shouldCoalesceEventChangeDetection||zone.shouldCoalesceRunChangeDetection)&&-1!==zone.lastRequestAnimationFrameId?zone.hasPendingMicrotasks=!0:zone.hasPendingMicrotasks=!1}function onEnter(zone){zone._nesting++,zone.isStable&&(zone.isStable=!1,zone.onUnstable.emit(null))}function onLeave(zone){zone._nesting--,checkStable(zone)}class NoopNgZone{constructor(){this.hasPendingMicrotasks=!1,this.hasPendingMacrotasks=!1,this.isStable=!0,this.onUnstable=new EventEmitter,this.onMicrotaskEmpty=new EventEmitter,this.onStable=new EventEmitter,this.onError=new EventEmitter}run(fn,applyThis,applyArgs){return fn.apply(applyThis,applyArgs)}runGuarded(fn,applyThis,applyArgs){return fn.apply(applyThis,applyArgs)}runOutsideAngular(fn){return fn()}runTask(fn,applyThis,applyArgs,name){return fn.apply(applyThis,applyArgs)}}var AfterRenderPhase;!function(AfterRenderPhase){AfterRenderPhase[AfterRenderPhase.EarlyRead=0]="EarlyRead",AfterRenderPhase[AfterRenderPhase.Write=1]="Write",AfterRenderPhase[AfterRenderPhase.MixedReadWrite=2]="MixedReadWrite",AfterRenderPhase[AfterRenderPhase.Read=3]="Read"}(AfterRenderPhase||(AfterRenderPhase={}));function internalAfterNextRender(callback,options){const injector=options?.injector??inject(Injector);if(!options?.runOnServer&&!isPlatformBrowser(injector))return;injector.get(AfterRenderEventManager).internalCallbacks.push(callback)}class AfterRenderEventManager{constructor(){this.handler=null,this.internalCallbacks=[]}execute(){this.executeInternalCallbacks(),this.handler?.execute()}executeInternalCallbacks(){const callbacks=[...this.internalCallbacks];this.internalCallbacks.length=0;for(const callback of callbacks)callback()}ngOnDestroy(){this.handler?.destroy(),this.handler=null,this.internalCallbacks.length=0}static#_=this.ɵprov=ɵɵdefineInjectable({token:AfterRenderEventManager,providedIn:"root",factory:()=>new AfterRenderEventManager})}function isModuleWithProviders(value){return void 0!==value.ngModule}function isNgModule(value){return!!getNgModuleDef(value)}function isPipe(value){return!!getPipeDef$1(value)}function isDirective(value){return!!getDirectiveDef(value)}function isComponent(value){return!!getComponentDef(value)}function verifyStandaloneImport(depType,importingType){if(isForwardRef(depType)&&!(depType=resolveForwardRef(depType)))throw new Error(`Expected forwardRef function, imported from "${stringifyForError(importingType)}", to return a standalone entity or NgModule but got "${stringifyForError(depType)||depType}".`);if(null==getNgModuleDef(depType)){const def=getComponentDef(depType)||getDirectiveDef(depType)||getPipeDef$1(depType);if(null==def)throw isModuleWithProviders(depType)?new Error(`A module with providers was imported from "${stringifyForError(importingType)}". Modules with providers are not supported in standalone components imports.`):new Error(`The "${stringifyForError(depType)}" type, imported from "${stringifyForError(importingType)}", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);if(!def.standalone)throw new Error(`The "${stringifyForError(depType)}" ${function getDependencyTypeForError(type){return getComponentDef(type)?"component":getDirectiveDef(type)?"directive":getPipeDef$1(type)?"pipe":"type"}(depType)}, imported from "${stringifyForError(importingType)}", is not standalone. Did you forget to add the standalone: true flag?`)}}const USE_RUNTIME_DEPS_TRACKER_FOR_JIT=!0;class DepsTracker{constructor(){this.ownerNgModule=new Map,this.ngModulesWithSomeUnresolvedDecls=new Set,this.ngModulesScopeCache=new Map,this.standaloneComponentsScopeCache=new Map}resolveNgModulesDecls(){if(0!==this.ngModulesWithSomeUnresolvedDecls.size){for(const moduleType of this.ngModulesWithSomeUnresolvedDecls){const def=getNgModuleDef(moduleType);if(def?.declarations)for(const decl of maybeUnwrapFn(def.declarations))isComponent(decl)&&this.ownerNgModule.set(decl,moduleType)}this.ngModulesWithSomeUnresolvedDecls.clear()}}getComponentDependencies(type,rawImports){this.resolveNgModulesDecls();const def=getComponentDef(type);if(null===def)throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);if(def.standalone){const scope=this.getStandaloneComponentScope(type,rawImports);return scope.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...scope.compilation.directives,...scope.compilation.pipes,...scope.compilation.ngModules]}}{if(!this.ownerNgModule.has(type))return{dependencies:[]};const scope=this.getNgModuleScope(this.ownerNgModule.get(type));return scope.compilation.isPoisoned?{dependencies:[]}:{dependencies:[...scope.compilation.directives,...scope.compilation.pipes]}}}registerNgModule(type,scopeInfo){if(!isNgModule(type))throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);this.ngModulesWithSomeUnresolvedDecls.add(type)}clearScopeCacheFor(type){this.ngModulesScopeCache.delete(type),this.standaloneComponentsScopeCache.delete(type)}getNgModuleScope(type){if(this.ngModulesScopeCache.has(type))return this.ngModulesScopeCache.get(type);const scope=this.computeNgModuleScope(type);return this.ngModulesScopeCache.set(type,scope),scope}computeNgModuleScope(type){const def=getNgModuleDef(type,!0),scope={exported:{directives:new Set,pipes:new Set},compilation:{directives:new Set,pipes:new Set}};for(const imported of maybeUnwrapFn(def.imports))if(isNgModule(imported)){const importedScope=this.getNgModuleScope(imported);addSet(importedScope.exported.directives,scope.compilation.directives),addSet(importedScope.exported.pipes,scope.compilation.pipes)}else{if(!isStandalone(imported)){scope.compilation.isPoisoned=!0;break}if(isDirective(imported)||isComponent(imported))scope.compilation.directives.add(imported);else{if(!isPipe(imported))throw new RuntimeError(1e3,"The standalone imported type is neither a component nor a directive nor a pipe");scope.compilation.pipes.add(imported)}}if(!scope.compilation.isPoisoned)for(const decl of maybeUnwrapFn(def.declarations)){if(isNgModule(decl)||isStandalone(decl)){scope.compilation.isPoisoned=!0;break}isPipe(decl)?scope.compilation.pipes.add(decl):scope.compilation.directives.add(decl)}for(const exported of maybeUnwrapFn(def.exports))if(isNgModule(exported)){const exportedScope=this.getNgModuleScope(exported);addSet(exportedScope.exported.directives,scope.exported.directives),addSet(exportedScope.exported.pipes,scope.exported.pipes),addSet(exportedScope.exported.directives,scope.compilation.directives),addSet(exportedScope.exported.pipes,scope.compilation.pipes)}else isPipe(exported)?scope.exported.pipes.add(exported):scope.exported.directives.add(exported);return scope}getStandaloneComponentScope(type,rawImports){if(this.standaloneComponentsScopeCache.has(type))return this.standaloneComponentsScopeCache.get(type);const ans=this.computeStandaloneComponentScope(type,rawImports);return this.standaloneComponentsScopeCache.set(type,ans),ans}computeStandaloneComponentScope(type,rawImports){const ans={compilation:{directives:new Set([type]),pipes:new Set,ngModules:new Set}};for(const rawImport of flatten(rawImports??[])){const imported=resolveForwardRef(rawImport);try{verifyStandaloneImport(imported,type)}catch(e){return ans.compilation.isPoisoned=!0,ans}if(isNgModule(imported)){ans.compilation.ngModules.add(imported);const importedScope=this.getNgModuleScope(imported);if(importedScope.exported.isPoisoned)return ans.compilation.isPoisoned=!0,ans;addSet(importedScope.exported.directives,ans.compilation.directives),addSet(importedScope.exported.pipes,ans.compilation.pipes)}else if(isPipe(imported))ans.compilation.pipes.add(imported);else{if(!isDirective(imported)&&!isComponent(imported))return ans.compilation.isPoisoned=!0,ans;ans.compilation.directives.add(imported)}}return ans}isOrphanComponent(cmp){const def=getComponentDef(cmp);return!(!def||def.standalone)&&(this.resolveNgModulesDecls(),!this.ownerNgModule.has(cmp))}}function addSet(sourceSet,targetSet){for(const m of sourceSet)targetSet.add(m)}const depsTracker=new DepsTracker;function computeStaticStyling(tNode,attrs,writeToHost){ngDevMode&&assertFirstCreatePass(getTView(),"Expecting to be called in first template pass only");let styles=writeToHost?tNode.styles:null,classes=writeToHost?tNode.classes:null,mode=0;if(null!==attrs)for(let i=0;i<attrs.length;i++){const value=attrs[i];if("number"==typeof value)mode=value;else if(1==mode)classes=concatStringsWithSpace(classes,value);else if(2==mode){styles=concatStringsWithSpace(styles,value+": "+attrs[++i]+";")}}writeToHost?tNode.styles=styles:tNode.stylesWithoutHost=styles,writeToHost?tNode.classes=classes:tNode.classesWithoutHost=classes}class ComponentFactoryResolver extends ComponentFactoryResolver$1{constructor(ngModule){super(),this.ngModule=ngModule}resolveComponentFactory(component){ngDevMode&&function assertComponentType(actual,msg="Type passed in is not ComponentType, it does not have 'ɵcmp' property."){getComponentDef(actual)||throwError(msg)}(component);const componentDef=getComponentDef(component);return new ComponentFactory(componentDef,this.ngModule)}}function toRefArray(map){const array=[];for(const publicName in map){if(!map.hasOwnProperty(publicName))continue;const value=map[publicName];void 0!==value&&array.push({propName:Array.isArray(value)?value[0]:value,templateName:publicName})}return array}class ChainedInjector{constructor(injector,parentInjector){this.injector=injector,this.parentInjector=parentInjector}get(token,notFoundValue,flags){flags=convertToBitFlags(flags);const value=this.injector.get(token,NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR,flags);return value!==NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR||notFoundValue===NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR?value:this.parentInjector.get(token,notFoundValue,flags)}}class ComponentFactory extends ComponentFactory$1{get inputs(){const componentDef=this.componentDef,inputTransforms=componentDef.inputTransforms,refArray=toRefArray(componentDef.inputs);if(null!==inputTransforms)for(const input of refArray)inputTransforms.hasOwnProperty(input.propName)&&(input.transform=inputTransforms[input.propName]);return refArray}get outputs(){return toRefArray(this.componentDef.outputs)}constructor(componentDef,ngModule){super(),this.componentDef=componentDef,this.ngModule=ngModule,this.componentType=componentDef.type,this.selector=stringifyCSSSelectorList(componentDef.selectors),this.ngContentSelectors=componentDef.ngContentSelectors?componentDef.ngContentSelectors:[],this.isBoundToModule=!!ngModule}create(injector,projectableNodes,rootSelectorOrNode,environmentInjector){const prevConsumer=setActiveConsumer(null);try{if(ngDevMode&&("undefined"==typeof ngJitMode||ngJitMode)&&this.componentDef.debugInfo?.forbidOrphanRendering&&depsTracker.isOrphanComponent(this.componentType))throw new RuntimeError(1001,`Orphan component found! Trying to render the component ${function debugStringifyTypeForError(type){let componentDef=type[NG_COMP_DEF]||null;return null!==componentDef&&componentDef.debugInfo?function stringifyTypeFromDebugInfo(debugInfo){return debugInfo.filePath&&debugInfo.lineNumber?`${debugInfo.className} (at ${debugInfo.filePath}:${debugInfo.lineNumber})`:debugInfo.className}(componentDef.debugInfo):stringifyForError(type)}(this.componentType)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);let realEnvironmentInjector=(environmentInjector=environmentInjector||this.ngModule)instanceof EnvironmentInjector?environmentInjector:environmentInjector?.injector;realEnvironmentInjector&&null!==this.componentDef.getStandaloneInjector&&(realEnvironmentInjector=this.componentDef.getStandaloneInjector(realEnvironmentInjector)||realEnvironmentInjector);const rootViewInjector=realEnvironmentInjector?new ChainedInjector(injector,realEnvironmentInjector):injector,rendererFactory=rootViewInjector.get(RendererFactory2,null);if(null===rendererFactory)throw new RuntimeError(407,ngDevMode&&"Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.");const sanitizer=rootViewInjector.get(Sanitizer,null),afterRenderEventManager=rootViewInjector.get(AfterRenderEventManager,null),environment={rendererFactory,sanitizer,inlineEffectRunner:null,afterRenderEventManager,changeDetectionScheduler:rootViewInjector.get(ChangeDetectionScheduler,null)},hostRenderer=rendererFactory.createRenderer(null,this.componentDef),elementName=this.componentDef.selectors[0][0]||"div",hostRNode=rootSelectorOrNode?locateHostElement(hostRenderer,rootSelectorOrNode,this.componentDef.encapsulation,rootViewInjector):createElementNode(hostRenderer,elementName,function getNamespace(elementName){const name=elementName.toLowerCase();return"svg"===name?"svg":"math"===name?"math":null}(elementName));let rootFlags=512;this.componentDef.signals?rootFlags|=4096:this.componentDef.onPush||(rootFlags|=16);let hydrationInfo=null;null!==hostRNode&&(hydrationInfo=retrieveHydrationInfo(hostRNode,rootViewInjector,!0));const rootTView=createTView(0,null,null,1,0,null,null,null,null,null,null),rootLView=createLView(null,rootTView,null,rootFlags,null,null,environment,hostRenderer,rootViewInjector,null,hydrationInfo);let component,tElementNode;enterView(rootLView);try{const rootComponentDef=this.componentDef;let rootDirectives,hostDirectiveDefs=null;rootComponentDef.findHostDirectiveDefs?(rootDirectives=[],hostDirectiveDefs=new Map,rootComponentDef.findHostDirectiveDefs(rootComponentDef,rootDirectives,hostDirectiveDefs),rootDirectives.push(rootComponentDef),ngDevMode&&assertNoDuplicateDirectives(rootDirectives)):rootDirectives=[rootComponentDef];const componentView=function createRootComponentView(tNode,hostRNode,rootComponentDef,rootDirectives,rootView,environment,hostRenderer){const tView=rootView[TVIEW];!function applyRootComponentStyling(rootDirectives,tNode,rNode,hostRenderer){for(const def of rootDirectives)tNode.mergedAttrs=mergeHostAttrs(tNode.mergedAttrs,def.hostAttrs);null!==tNode.mergedAttrs&&(computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==rNode&&setupStaticAttributes(hostRenderer,rNode,tNode))}(rootDirectives,tNode,hostRNode,hostRenderer);let hydrationInfo=null;null!==hostRNode&&(hydrationInfo=retrieveHydrationInfo(hostRNode,rootView[INJECTOR]));const viewRenderer=environment.rendererFactory.createRenderer(hostRNode,rootComponentDef);let lViewFlags=16;rootComponentDef.signals?lViewFlags=4096:rootComponentDef.onPush&&(lViewFlags=64);const componentView=createLView(rootView,getOrCreateComponentTView(rootComponentDef),null,lViewFlags,rootView[tNode.index],tNode,environment,viewRenderer,null,null,hydrationInfo);tView.firstCreatePass&&markAsComponentHost(tView,tNode,rootDirectives.length-1);return addToViewTree(rootView,componentView),rootView[tNode.index]=componentView}(function createRootComponentTNode(lView,rNode){const tView=lView[TVIEW],index=HEADER_OFFSET;return ngDevMode&&assertIndexInRange(lView,index),lView[index]=rNode,getOrCreateTNode(tView,index,2,"#host",null)}(rootLView,hostRNode),hostRNode,rootComponentDef,rootDirectives,rootLView,environment,hostRenderer);tElementNode=getTNode(rootTView,HEADER_OFFSET),hostRNode&&function setRootNodeAttributes(hostRenderer,componentDef,hostRNode,rootSelectorOrNode){if(rootSelectorOrNode)setUpAttributes(hostRenderer,hostRNode,["ng-version","17.3.11"]);else{const{attrs,classes}=function extractAttrsAndClassesFromSelector(selector){const attrs=[],classes=[];let i=1,mode=2;for(;i<selector.length;){let valueOrMarker=selector[i];if("string"==typeof valueOrMarker)2===mode?""!==valueOrMarker&&attrs.push(valueOrMarker,selector[++i]):8===mode&&classes.push(valueOrMarker);else{if(!isPositive(mode))break;mode=valueOrMarker}i++}return{attrs,classes}}(componentDef.selectors[0]);attrs&&setUpAttributes(hostRenderer,hostRNode,attrs),classes&&classes.length>0&&writeDirectClass(hostRenderer,hostRNode,classes.join(" "))}}(hostRenderer,rootComponentDef,hostRNode,rootSelectorOrNode),void 0!==projectableNodes&&function projectNodes(tNode,ngContentSelectors,projectableNodes){const projection=tNode.projection=[];for(let i=0;i<ngContentSelectors.length;i++){const nodesforSlot=projectableNodes[i];projection.push(null!=nodesforSlot?Array.from(nodesforSlot):null)}}(tElementNode,this.ngContentSelectors,projectableNodes),component=function createRootComponent(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,hostFeatures){const rootTNode=getCurrentTNode();ngDevMode&&assertDefined(rootTNode,"tNode should have been already created");const tView=rootLView[TVIEW],native=getNativeByTNode(rootTNode,rootLView);initializeDirectives(tView,rootLView,rootTNode,rootDirectives,null,hostDirectiveDefs);for(let i=0;i<rootDirectives.length;i++){attachPatchData(getNodeInjectable(rootLView,tView,rootTNode.directiveStart+i,rootTNode),rootLView)}invokeDirectivesHostBindings(tView,rootLView,rootTNode),native&&attachPatchData(native,rootLView);ngDevMode&&assertGreaterThan(rootTNode.componentOffset,-1,"componentOffset must be great than -1");const component=getNodeInjectable(rootLView,tView,rootTNode.directiveStart+rootTNode.componentOffset,rootTNode);if(componentView[CONTEXT]=rootLView[CONTEXT]=component,null!==hostFeatures)for(const feature of hostFeatures)feature(component,rootComponentDef);return executeContentQueries(tView,rootTNode,rootLView),component}(componentView,rootComponentDef,rootDirectives,hostDirectiveDefs,rootLView,[LifecycleHooksFeature]),renderView(rootTView,rootLView,null)}finally{leaveView()}return new ComponentRef(this.componentType,component,createElementRef(tElementNode,rootLView),rootLView,tElementNode)}finally{setActiveConsumer(prevConsumer)}}}class ComponentRef extends ComponentRef$1{constructor(componentType,instance,location,_rootLView,_tNode){super(),this.location=location,this._rootLView=_rootLView,this._tNode=_tNode,this.previousInputValues=null,this.instance=instance,this.hostView=this.changeDetectorRef=new ViewRef$1(_rootLView,void 0,!1),this.componentType=componentType}setInput(name,value){const inputData=this._tNode.inputs;let dataValue;if(null!==inputData&&(dataValue=inputData[name])){if(this.previousInputValues??=new Map,this.previousInputValues.has(name)&&Object.is(this.previousInputValues.get(name),value))return;const lView=this._rootLView;setInputsForProperty(lView[TVIEW],lView,dataValue,name,value),this.previousInputValues.set(name,value);markViewDirty(getComponentLViewByIndex(this._tNode.index,lView))}else if(ngDevMode){let message=`Can't set value of the '${name}' input on the '${stringifyForError(this.componentType)}' component. `;message+=`Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`,reportUnknownPropertyError(message)}}get injector(){return new NodeInjector(this._tNode,this._rootLView)}destroy(){this.hostView.destroy()}onDestroy(callback){this.hostView.onDestroy(callback)}}function LifecycleHooksFeature(){const tNode=getCurrentTNode();ngDevMode&&assertDefined(tNode,"TNode is required"),registerPostOrderHooks(getLView()[TVIEW],tNode)}class ViewContainerRef{static#_=this.__NG_ELEMENT_ID__=injectViewContainerRef}function injectViewContainerRef(){return createContainerRef(getCurrentTNode(),getLView())}const VE_ViewContainerRef=ViewContainerRef,R3ViewContainerRef=class ViewContainerRef extends VE_ViewContainerRef{constructor(_lContainer,_hostTNode,_hostLView){super(),this._lContainer=_lContainer,this._hostTNode=_hostTNode,this._hostLView=_hostLView}get element(){return createElementRef(this._hostTNode,this._hostLView)}get injector(){return new NodeInjector(this._hostTNode,this._hostLView)}get parentInjector(){const parentLocation=getParentInjectorLocation(this._hostTNode,this._hostLView);if(hasParentInjector(parentLocation)){const parentView=getParentInjectorView(parentLocation,this._hostLView),injectorIndex=getParentInjectorIndex(parentLocation);ngDevMode&&assertNodeInjector(parentView,injectorIndex);const parentTNode=parentView[TVIEW].data[injectorIndex+8];return new NodeInjector(parentTNode,parentView)}return new NodeInjector(null,this._hostLView)}clear(){for(;this.length>0;)this.remove(this.length-1)}get(index){const viewRefs=getViewRefs(this._lContainer);return null!==viewRefs&&viewRefs[index]||null}get length(){return this._lContainer.length-CONTAINER_HEADER_OFFSET}createEmbeddedView(templateRef,context,indexOrOptions){let index,injector;"number"==typeof indexOrOptions?index=indexOrOptions:null!=indexOrOptions&&(index=indexOrOptions.index,injector=indexOrOptions.injector);const dehydratedView=findMatchingDehydratedView(this._lContainer,templateRef.ssrId),viewRef=templateRef.createEmbeddedViewImpl(context||{},injector,dehydratedView);return this.insertImpl(viewRef,index,shouldAddViewToDom(this._hostTNode,dehydratedView)),viewRef}createComponent(componentFactoryOrType,indexOrOptions,injector,projectableNodes,environmentInjector){const isComponentFactory=componentFactoryOrType&&!isType(componentFactoryOrType);let index;if(isComponentFactory)ngDevMode&&assertEqual("object"!=typeof indexOrOptions,!0,"It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)"),index=indexOrOptions;else{ngDevMode&&(assertDefined(getComponentDef(componentFactoryOrType),"Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator."),assertEqual("number"!=typeof indexOrOptions,!0,"It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead."));const options=indexOrOptions||{};ngDevMode&&options.environmentInjector&&options.ngModuleRef&&throwError("Cannot pass both environmentInjector and ngModuleRef options to createComponent()."),index=options.index,injector=options.injector,projectableNodes=options.projectableNodes,environmentInjector=options.environmentInjector||options.ngModuleRef}const componentFactory=isComponentFactory?componentFactoryOrType:new ComponentFactory(getComponentDef(componentFactoryOrType)),contextInjector=injector||this.parentInjector;if(!environmentInjector&&null==componentFactory.ngModule){const result=(isComponentFactory?contextInjector:this.parentInjector).get(EnvironmentInjector,null);result&&(environmentInjector=result)}const componentDef=getComponentDef(componentFactory.componentType??{}),dehydratedView=findMatchingDehydratedView(this._lContainer,componentDef?.id??null),rNode=dehydratedView?.firstChild??null,componentRef=componentFactory.create(contextInjector,projectableNodes,rNode,environmentInjector);return this.insertImpl(componentRef.hostView,index,shouldAddViewToDom(this._hostTNode,dehydratedView)),componentRef}insert(viewRef,index){return this.insertImpl(viewRef,index,!0)}insertImpl(viewRef,index,addToDOM){const lView=viewRef._lView;if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot insert a destroyed View in a ViewContainer!");if(function viewAttachedToContainer(view){return isLContainer(view[PARENT])}(lView)){const prevIdx=this.indexOf(viewRef);if(-1!==prevIdx)this.detach(prevIdx);else{const prevLContainer=lView[PARENT];ngDevMode&&assertEqual(isLContainer(prevLContainer),!0,"An attached view should have its PARENT point to a container.");const prevVCRef=new R3ViewContainerRef(prevLContainer,prevLContainer[T_HOST],prevLContainer[PARENT]);prevVCRef.detach(prevVCRef.indexOf(viewRef))}}const adjustedIdx=this._adjustIndex(index),lContainer=this._lContainer;return addLViewToLContainer(lContainer,lView,adjustedIdx,addToDOM),viewRef.attachToViewContainerRef(),addToArray(getOrCreateViewRefs(lContainer),adjustedIdx,viewRef),viewRef}move(viewRef,newIndex){if(ngDevMode&&viewRef.destroyed)throw new Error("Cannot move a destroyed View in a ViewContainer!");return this.insert(viewRef,newIndex)}indexOf(viewRef){const viewRefsArr=getViewRefs(this._lContainer);return null!==viewRefsArr?viewRefsArr.indexOf(viewRef):-1}remove(index){const adjustedIdx=this._adjustIndex(index,-1),detachedView=detachView(this._lContainer,adjustedIdx);detachedView&&(removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx),destroyLView(detachedView[TVIEW],detachedView))}detach(index){const adjustedIdx=this._adjustIndex(index,-1),view=detachView(this._lContainer,adjustedIdx);return view&&null!=removeFromArray(getOrCreateViewRefs(this._lContainer),adjustedIdx)?new ViewRef$1(view):null}_adjustIndex(index,shift=0){return null==index?this.length+shift:(ngDevMode&&(assertGreaterThan(index,-1,`ViewRef index must be positive, got ${index}`),assertLessThan(index,this.length+1+shift,"index")),index)}};function getViewRefs(lContainer){return lContainer[8]}function getOrCreateViewRefs(lContainer){return lContainer[8]||(lContainer[8]=[])}function createContainerRef(hostTNode,hostLView){let lContainer;ngDevMode&&assertTNodeType(hostTNode,15);const slotValue=hostLView[hostTNode.index];return isLContainer(slotValue)?lContainer=slotValue:(lContainer=createLContainer(slotValue,hostLView,null,hostTNode),hostLView[hostTNode.index]=lContainer,addToViewTree(hostLView,lContainer)),_locateOrCreateAnchorNode(lContainer,hostLView,hostTNode,slotValue),new R3ViewContainerRef(lContainer,hostTNode,hostLView)}let _locateOrCreateAnchorNode=createAnchorNode,_populateDehydratedViewsInLContainer=()=>!1;function populateDehydratedViewsInLContainer(lContainer,tNode,hostLView){return _populateDehydratedViewsInLContainer(lContainer,tNode,hostLView)}function createAnchorNode(lContainer,hostLView,hostTNode,slotValue){if(lContainer[NATIVE])return;let commentNode;commentNode=8&hostTNode.type?unwrapRNode(slotValue):function insertAnchorNode(hostLView,hostTNode){const renderer=hostLView[RENDERER];ngDevMode&&ngDevMode.rendererCreateComment++;const commentNode=renderer.createComment(ngDevMode?"container":""),hostNative=getNativeByTNode(hostTNode,hostLView);return nativeInsertBefore(renderer,nativeParentNode(renderer,hostNative),commentNode,function nativeNextSibling(renderer,node){return renderer.nextSibling(node)}(renderer,hostNative),!1),commentNode}(hostLView,hostTNode),lContainer[NATIVE]=commentNode}class LQuery_{constructor(queryList){this.queryList=queryList,this.matches=null}clone(){return new LQuery_(this.queryList)}setDirty(){this.queryList.setDirty()}}class LQueries_{constructor(queries=[]){this.queries=queries}createEmbeddedView(tView){const tQueries=tView.queries;if(null!==tQueries){const noOfInheritedQueries=null!==tView.contentQueries?tView.contentQueries[0]:tQueries.length,viewLQueries=[];for(let i=0;i<noOfInheritedQueries;i++){const tQuery=tQueries.getByIndex(i),parentLQuery=this.queries[tQuery.indexInDeclarationView];viewLQueries.push(parentLQuery.clone())}return new LQueries_(viewLQueries)}return null}insertView(tView){this.dirtyQueriesWithMatches(tView)}detachView(tView){this.dirtyQueriesWithMatches(tView)}finishViewCreation(tView){this.dirtyQueriesWithMatches(tView)}dirtyQueriesWithMatches(tView){for(let i=0;i<this.queries.length;i++)null!==getTQuery(tView,i).matches&&this.queries[i].setDirty()}}class TQueryMetadata_{constructor(predicate,flags,read=null){this.flags=flags,this.read=read,this.predicate="string"==typeof predicate?function splitQueryMultiSelectors(locator){return locator.split(",").map((s=>s.trim()))}(predicate):predicate}}class TQueries_{constructor(queries=[]){this.queries=queries}elementStart(tView,tNode){ngDevMode&&assertFirstCreatePass(tView,"Queries should collect results on the first template pass only");for(let i=0;i<this.queries.length;i++)this.queries[i].elementStart(tView,tNode)}elementEnd(tNode){for(let i=0;i<this.queries.length;i++)this.queries[i].elementEnd(tNode)}embeddedTView(tNode){let queriesForTemplateRef=null;for(let i=0;i<this.length;i++){const childQueryIndex=null!==queriesForTemplateRef?queriesForTemplateRef.length:0,tqueryClone=this.getByIndex(i).embeddedTView(tNode,childQueryIndex);tqueryClone&&(tqueryClone.indexInDeclarationView=i,null!==queriesForTemplateRef?queriesForTemplateRef.push(tqueryClone):queriesForTemplateRef=[tqueryClone])}return null!==queriesForTemplateRef?new TQueries_(queriesForTemplateRef):null}template(tView,tNode){ngDevMode&&assertFirstCreatePass(tView,"Queries should collect results on the first template pass only");for(let i=0;i<this.queries.length;i++)this.queries[i].template(tView,tNode)}getByIndex(index){return ngDevMode&&assertIndexInRange(this.queries,index),this.queries[index]}get length(){return this.queries.length}track(tquery){this.queries.push(tquery)}}class TQuery_{constructor(metadata,nodeIndex=-1){this.metadata=metadata,this.matches=null,this.indexInDeclarationView=-1,this.crossesNgTemplate=!1,this._appliesToNextNode=!0,this._declarationNodeIndex=nodeIndex}elementStart(tView,tNode){this.isApplyingToNode(tNode)&&this.matchTNode(tView,tNode)}elementEnd(tNode){this._declarationNodeIndex===tNode.index&&(this._appliesToNextNode=!1)}template(tView,tNode){this.elementStart(tView,tNode)}embeddedTView(tNode,childQueryIndex){return this.isApplyingToNode(tNode)?(this.crossesNgTemplate=!0,this.addMatch(-tNode.index,childQueryIndex),new TQuery_(this.metadata)):null}isApplyingToNode(tNode){if(this._appliesToNextNode&&1&~this.metadata.flags){const declarationNodeIdx=this._declarationNodeIndex;let parent=tNode.parent;for(;null!==parent&&8&parent.type&&parent.index!==declarationNodeIdx;)parent=parent.parent;return declarationNodeIdx===(null!==parent?parent.index:-1)}return this._appliesToNextNode}matchTNode(tView,tNode){const predicate=this.metadata.predicate;if(Array.isArray(predicate))for(let i=0;i<predicate.length;i++){const name=predicate[i];this.matchTNodeWithReadOption(tView,tNode,getIdxOfMatchingSelector(tNode,name)),this.matchTNodeWithReadOption(tView,tNode,locateDirectiveOrProvider(tNode,tView,name,!1,!1))}else predicate===TemplateRef?4&tNode.type&&this.matchTNodeWithReadOption(tView,tNode,-1):this.matchTNodeWithReadOption(tView,tNode,locateDirectiveOrProvider(tNode,tView,predicate,!1,!1))}matchTNodeWithReadOption(tView,tNode,nodeMatchIdx){if(null!==nodeMatchIdx){const read=this.metadata.read;if(null!==read)if(read===ElementRef||read===ViewContainerRef||read===TemplateRef&&4&tNode.type)this.addMatch(tNode.index,-2);else{const directiveOrProviderIdx=locateDirectiveOrProvider(tNode,tView,read,!1,!1);null!==directiveOrProviderIdx&&this.addMatch(tNode.index,directiveOrProviderIdx)}else this.addMatch(tNode.index,nodeMatchIdx)}}addMatch(tNodeIdx,matchIdx){null===this.matches?this.matches=[tNodeIdx,matchIdx]:this.matches.push(tNodeIdx,matchIdx)}}function getIdxOfMatchingSelector(tNode,selector){const localNames=tNode.localNames;if(null!==localNames)for(let i=0;i<localNames.length;i+=2)if(localNames[i]===selector)return localNames[i+1];return null}function createResultForNode(lView,tNode,matchingIdx,read){return-1===matchingIdx?function createResultByTNodeType(tNode,currentView){return 11&tNode.type?createElementRef(tNode,currentView):4&tNode.type?createTemplateRef(tNode,currentView):null}(tNode,lView):-2===matchingIdx?function createSpecialToken(lView,tNode,read){if(read===ElementRef)return createElementRef(tNode,lView);if(read===TemplateRef)return createTemplateRef(tNode,lView);if(read===ViewContainerRef)return ngDevMode&&assertTNodeType(tNode,15),createContainerRef(tNode,lView);ngDevMode&&throwError(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`)}(lView,tNode,read):getNodeInjectable(lView,lView[TVIEW],matchingIdx,tNode)}function materializeViewResults(tView,lView,tQuery,queryIndex){const lQuery=lView[QUERIES].queries[queryIndex];if(null===lQuery.matches){const tViewData=tView.data,tQueryMatches=tQuery.matches,result=[];for(let i=0;null!==tQueryMatches&&i<tQueryMatches.length;i+=2){const matchedNodeIdx=tQueryMatches[i];if(matchedNodeIdx<0)result.push(null);else{ngDevMode&&assertIndexInRange(tViewData,matchedNodeIdx);const tNode=tViewData[matchedNodeIdx];result.push(createResultForNode(lView,tNode,tQueryMatches[i+1],tQuery.metadata.read))}}lQuery.matches=result}return lQuery.matches}function collectQueryResults(tView,lView,queryIndex,result){const tQuery=tView.queries.getByIndex(queryIndex),tQueryMatches=tQuery.matches;if(null!==tQueryMatches){const lViewResults=materializeViewResults(tView,lView,tQuery,queryIndex);for(let i=0;i<tQueryMatches.length;i+=2){const tNodeIdx=tQueryMatches[i];if(tNodeIdx>0)result.push(lViewResults[i/2]);else{const childQueryIndex=tQueryMatches[i+1],declarationLContainer=lView[-tNodeIdx];ngDevMode&&assertLContainer(declarationLContainer);for(let i=CONTAINER_HEADER_OFFSET;i<declarationLContainer.length;i++){const embeddedLView=declarationLContainer[i];embeddedLView[DECLARATION_LCONTAINER]===embeddedLView[PARENT]&&collectQueryResults(embeddedLView[TVIEW],embeddedLView,childQueryIndex,result)}if(null!==declarationLContainer[MOVED_VIEWS]){const embeddedLViews=declarationLContainer[MOVED_VIEWS];for(let i=0;i<embeddedLViews.length;i++){const embeddedLView=embeddedLViews[i];collectQueryResults(embeddedLView[TVIEW],embeddedLView,childQueryIndex,result)}}}}}return result}function loadQueryInternal(lView,queryIndex){return ngDevMode&&assertDefined(lView[QUERIES],"LQueries should be defined when trying to load a query"),ngDevMode&&assertIndexInRange(lView[QUERIES].queries,queryIndex),lView[QUERIES].queries[queryIndex].queryList}function createLQuery(tView,lView,flags){const queryList=new QueryList(!(4&~flags));!function storeCleanupWithContext(tView,lView,context,cleanupFn){const lCleanup=getOrCreateLViewCleanup(lView);ngDevMode&&assertDefined(context,"Cleanup context is mandatory when registering framework-level destroy hooks"),lCleanup.push(context),tView.firstCreatePass?getOrCreateTViewCleanup(tView).push(cleanupFn,lCleanup.length-1):ngDevMode&&Object.freeze(getOrCreateTViewCleanup(tView))}(tView,lView,queryList,queryList.destroy);return(lView[QUERIES]??=new LQueries_).queries.push(new LQuery_(queryList))-1}function createViewQuery(predicate,flags,read){ngDevMode&&assertNumber(flags,"Expecting flags");const tView=getTView();return tView.firstCreatePass&&(createTQuery(tView,new TQueryMetadata_(predicate,flags,read),-1),2&~flags||(tView.staticViewQueries=!0)),createLQuery(tView,getLView(),flags)}function createContentQuery(directiveIndex,predicate,flags,read){ngDevMode&&assertNumber(flags,"Expecting flags");const tView=getTView();if(tView.firstCreatePass){const tNode=getCurrentTNode();createTQuery(tView,new TQueryMetadata_(predicate,flags,read),tNode.index),function saveContentQueryAndDirectiveIndex(tView,directiveIndex){const tViewContentQueries=tView.contentQueries||(tView.contentQueries=[]),lastSavedDirectiveIndex=tViewContentQueries.length?tViewContentQueries[tViewContentQueries.length-1]:-1;directiveIndex!==lastSavedDirectiveIndex&&tViewContentQueries.push(tView.queries.length-1,directiveIndex)}(tView,directiveIndex),2&~flags||(tView.staticContentQueries=!0)}return createLQuery(tView,getLView(),flags)}function createTQuery(tView,metadata,nodeIndex){null===tView.queries&&(tView.queries=new TQueries_),tView.queries.track(new TQuery_(metadata,nodeIndex))}function getTQuery(tView,index){return ngDevMode&&assertDefined(tView.queries,"TQueries must be defined to retrieve a TQuery"),tView.queries.getByIndex(index)}function getQueryResults(lView,queryIndex){const tView=lView[TVIEW],tQuery=getTQuery(tView,queryIndex);return tQuery.crossesNgTemplate?collectQueryResults(tView,lView,queryIndex,[]):materializeViewResults(tView,lView,tQuery,queryIndex)}function isSignal(value){return"function"==typeof value&&void 0!==value[SIGNAL]}function signal(initialValue,options){performanceMarkFeature("NgSignals");const signalFn=function createSignal(initialValue){const node=Object.create(SIGNAL_NODE);node.value=initialValue;const getter=()=>(producerAccessed(node),node.value);return getter[SIGNAL]=node,getter}(initialValue),node=signalFn[SIGNAL];return options?.equal&&(node.equal=options.equal),signalFn.set=newValue=>signalSetFn(node,newValue),signalFn.update=updateFn=>function signalUpdateFn(node,updater){producerUpdatesAllowed()||throwInvalidWriteToSignalError(),signalSetFn(node,updater(node.value))}(node,updateFn),signalFn.asReadonly=signalAsReadonlyFn.bind(signalFn),ngDevMode&&(signalFn.toString=()=>`[Signal: ${signalFn()}]`),signalFn}function signalAsReadonlyFn(){const node=this[SIGNAL];if(void 0===node.readonlyFn){const readonlyFn=()=>this();readonlyFn[SIGNAL]=node,node.readonlyFn=readonlyFn}return node.readonlyFn}function isWritableSignal(value){return isSignal(value)&&"function"==typeof value.set}function createQuerySignalFn(firstOnly,required){let node;const signalFn=createComputed((()=>{node._dirtyCounter();const value=function refreshSignalQuery(node,firstOnly){const lView=node._lView,queryIndex=node._queryIndex;if(void 0===lView||void 0===queryIndex||4&lView[FLAGS])return firstOnly?void 0:EMPTY_ARRAY;const queryList=loadQueryInternal(lView,queryIndex),results=getQueryResults(lView,queryIndex);if(queryList.reset(results,unwrapElementRef),firstOnly)return queryList.first;return queryList._changesDetected||void 0===node._flatValue?node._flatValue=queryList.toArray():node._flatValue}(node,firstOnly);if(required&&void 0===value)throw new RuntimeError(-951,ngDevMode&&"Child query result is required but no value is available.");return value}));return node=signalFn[SIGNAL],node._dirtyCounter=signal(0),node._flatValue=void 0,ngDevMode&&(signalFn.toString=()=>"[Query Signal]"),signalFn}function createSingleResultOptionalQuerySignalFn(){return createQuerySignalFn(!0,!1)}function createSingleResultRequiredQuerySignalFn(){return createQuerySignalFn(!0,!0)}function createMultiResultQuerySignalFn(){return createQuerySignalFn(!1,!1)}function bindQueryToSignal(target,queryIndex){const node=target[SIGNAL];node._lView=getLView(),node._queryIndex=queryIndex,node._queryList=loadQueryInternal(node._lView,queryIndex),node._queryList.onDirty((()=>node._dirtyCounter.update((v=>v+1))))}function viewChildFn(locator,opts){return ngDevMode&&assertInInjectionContext(viewChild),createSingleResultOptionalQuerySignalFn()}function viewChildRequiredFn(locator,opts){return ngDevMode&&assertInInjectionContext(viewChild),createSingleResultRequiredQuerySignalFn()}const viewChild=(viewChildFn.required=viewChildRequiredFn,viewChildFn);function contentChildFn(locator,opts){return ngDevMode&&assertInInjectionContext(contentChild),createSingleResultOptionalQuerySignalFn()}function contentChildRequiredFn(locator,opts){return ngDevMode&&assertInInjectionContext(contentChildren),createSingleResultRequiredQuerySignalFn()}const contentChild=(contentChildFn.required=contentChildRequiredFn,contentChildFn);function contentChildren(locator,opts){return createMultiResultQuerySignalFn()}function createModelSignal(initialValue){const node=Object.create(INPUT_SIGNAL_NODE),emitterRef=new OutputEmitterRef;function getter(){return producerAccessed(node),assertModelSet(node.value),node.value}return node.value=initialValue,getter[SIGNAL]=node,getter.asReadonly=signalAsReadonlyFn.bind(getter),getter.set=newValue=>{node.equal(node.value,newValue)||(signalSetFn(node,newValue),emitterRef.emit(newValue))},getter.update=updateFn=>{assertModelSet(node.value),getter.set(updateFn(node.value))},getter.subscribe=emitterRef.subscribe.bind(emitterRef),getter.destroyRef=emitterRef.destroyRef,ngDevMode&&(getter.toString=()=>`[Model Signal: ${getter()}]`),getter}function assertModelSet(value){if(value===REQUIRED_UNSET_VALUE)throw new RuntimeError(-952,ngDevMode&&"Model is required but no value is available yet.")}function modelFunction(initialValue){return ngDevMode&&assertInInjectionContext(model),createModelSignal(initialValue)}function modelRequiredFunction(){return ngDevMode&&assertInInjectionContext(model),createModelSignal(REQUIRED_UNSET_VALUE)}const model=(modelFunction.required=modelRequiredFunction,modelFunction);class Query{}makePropDecorator("ContentChildren",((selector,opts={})=>({selector,first:!1,isViewQuery:!1,descendants:!1,emitDistinctChangesOnly:true,...opts})),Query),makePropDecorator("ContentChild",((selector,opts={})=>({selector,first:!0,isViewQuery:!1,descendants:!0,...opts})),Query),makePropDecorator("ViewChildren",((selector,opts={})=>({selector,first:!1,isViewQuery:!0,descendants:!0,emitDistinctChangesOnly:true,...opts})),Query),makePropDecorator("ViewChild",((selector,opts)=>({selector,first:!0,isViewQuery:!0,descendants:!0,...opts})),Query);function resolveComponentResources(resourceResolver){const componentResolved=[],urlMap=new Map;function cachedResourceResolve(url){let promise=urlMap.get(url);if(!promise){const resp=resourceResolver(url);urlMap.set(url,promise=resp.then(unwrapResponse))}return promise}return componentResourceResolutionQueue.forEach(((component,type)=>{const promises=[];component.templateUrl&&promises.push(cachedResourceResolve(component.templateUrl).then((template=>{component.template=template})));const styles="string"==typeof component.styles?[component.styles]:component.styles||[];if(component.styles=styles,component.styleUrl&&component.styleUrls?.length)throw new Error("@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple");if(component.styleUrls?.length){const styleOffset=component.styles.length,styleUrls=component.styleUrls;component.styleUrls.forEach(((styleUrl,index)=>{styles.push(""),promises.push(cachedResourceResolve(styleUrl).then((style=>{styles[styleOffset+index]=style,styleUrls.splice(styleUrls.indexOf(styleUrl),1),0==styleUrls.length&&(component.styleUrls=void 0)})))}))}else component.styleUrl&&promises.push(cachedResourceResolve(component.styleUrl).then((style=>{styles.push(style),component.styleUrl=void 0})));const fullyResolved=Promise.all(promises).then((()=>function componentDefResolved(type){componentDefPendingResolution.delete(type)}(type)));componentResolved.push(fullyResolved)})),function clearResolutionOfComponentResourcesQueue(){const old=componentResourceResolutionQueue;return componentResourceResolutionQueue=new Map,old}(),Promise.all(componentResolved).then((()=>{}))}let componentResourceResolutionQueue=new Map;const componentDefPendingResolution=new Set;function componentNeedsResolution(component){return!!(component.templateUrl&&!component.hasOwnProperty("template")||component.styleUrls&&component.styleUrls.length||component.styleUrl)}function unwrapResponse(response){return"string"==typeof response?response:response.text()}const modules=new Map;let checkForDuplicateNgModules=!0;function registerNgModuleType(ngModuleType,id){!function assertSameOrNotExisting(id,type,incoming){if(type&&type!==incoming&&checkForDuplicateNgModules)throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`)}(id,modules.get(id)||null,ngModuleType),modules.set(id,ngModuleType)}function ɵɵvalidateIframeAttribute(attrValue,tagName,attrName){const lView=getLView(),tNode=getSelectedTNode(),element=getNativeByTNode(tNode,lView);if(2===tNode.type&&"iframe"===tagName.toLowerCase()){const iframe=element;iframe.src="",iframe.srcdoc=trustedHTMLFromString(""),nativeRemoveNode(lView[RENDERER],iframe);const errorMessage=ngDevMode&&`Angular has detected that the \`${attrName}\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \`${attrName}\` can be set on an <iframe> as a static attribute only. \nTo fix this, switch the \`${attrName}\` binding to a static attribute in a template or in host bindings section.`;throw new RuntimeError(-910,errorMessage)}return attrValue}function getSuperType(type){return Object.getPrototypeOf(type.prototype).constructor}function ɵɵInheritDefinitionFeature(definition){let superType=getSuperType(definition.type),shouldInheritFields=!0;const inheritanceChain=[definition];for(;superType;){let superDef;if(isComponentDef(definition))superDef=superType.ɵcmp||superType.ɵdir;else{if(superType.ɵcmp)throw new RuntimeError(903,ngDevMode&&`Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);superDef=superType.ɵdir}if(superDef){if(shouldInheritFields){inheritanceChain.push(superDef);const writeableDef=definition;writeableDef.inputs=maybeUnwrapEmpty(definition.inputs),writeableDef.inputTransforms=maybeUnwrapEmpty(definition.inputTransforms),writeableDef.declaredInputs=maybeUnwrapEmpty(definition.declaredInputs),writeableDef.outputs=maybeUnwrapEmpty(definition.outputs);const superHostBindings=superDef.hostBindings;superHostBindings&&inheritHostBindings(definition,superHostBindings);const superViewQuery=superDef.viewQuery,superContentQueries=superDef.contentQueries;if(superViewQuery&&inheritViewQuery(definition,superViewQuery),superContentQueries&&inheritContentQueries(definition,superContentQueries),mergeInputsWithTransforms(definition,superDef),fillProperties(definition.outputs,superDef.outputs),isComponentDef(superDef)&&superDef.data.animation){const defData=definition.data;defData.animation=(defData.animation||[]).concat(superDef.data.animation)}}const features=superDef.features;if(features)for(let i=0;i<features.length;i++){const feature=features[i];feature&&feature.ngInherit&&feature(definition),feature===ɵɵInheritDefinitionFeature&&(shouldInheritFields=!1)}}superType=Object.getPrototypeOf(superType)}!function mergeHostAttrsAcrossInheritance(inheritanceChain){let hostVars=0,hostAttrs=null;for(let i=inheritanceChain.length-1;i>=0;i--){const def=inheritanceChain[i];def.hostVars=hostVars+=def.hostVars,def.hostAttrs=mergeHostAttrs(def.hostAttrs,hostAttrs=mergeHostAttrs(hostAttrs,def.hostAttrs))}}(inheritanceChain)}function mergeInputsWithTransforms(target,source){for(const key in source.inputs){if(!source.inputs.hasOwnProperty(key))continue;if(target.inputs.hasOwnProperty(key))continue;const value=source.inputs[key];if(void 0!==value&&(target.inputs[key]=value,target.declaredInputs[key]=source.declaredInputs[key],null!==source.inputTransforms)){const minifiedName=Array.isArray(value)?value[0]:value;if(!source.inputTransforms.hasOwnProperty(minifiedName))continue;target.inputTransforms??={},target.inputTransforms[minifiedName]=source.inputTransforms[minifiedName]}}}function maybeUnwrapEmpty(value){return value===EMPTY_OBJ?{}:value===EMPTY_ARRAY?[]:value}function inheritViewQuery(definition,superViewQuery){const prevViewQuery=definition.viewQuery;definition.viewQuery=prevViewQuery?(rf,ctx)=>{superViewQuery(rf,ctx),prevViewQuery(rf,ctx)}:superViewQuery}function inheritContentQueries(definition,superContentQueries){const prevContentQueries=definition.contentQueries;definition.contentQueries=prevContentQueries?(rf,ctx,directiveIndex)=>{superContentQueries(rf,ctx,directiveIndex),prevContentQueries(rf,ctx,directiveIndex)}:superContentQueries}function inheritHostBindings(definition,superHostBindings){const prevHostBindings=definition.hostBindings;definition.hostBindings=prevHostBindings?(rf,ctx)=>{superHostBindings(rf,ctx),prevHostBindings(rf,ctx)}:superHostBindings}const COPY_DIRECTIVE_FIELDS=["providersResolver"],COPY_COMPONENT_FIELDS=["template","decls","consts","vars","onPush","ngContentSelectors","styles","encapsulation","schemas"];function ɵɵCopyDefinitionFeature(definition){let superDef,superType=getSuperType(definition.type);superDef=isComponentDef(definition)?superType.ɵcmp:superType.ɵdir;const defAny=definition;for(const field of COPY_DIRECTIVE_FIELDS)defAny[field]=superDef[field];if(isComponentDef(superDef))for(const field of COPY_COMPONENT_FIELDS)defAny[field]=superDef[field]}function ɵɵHostDirectivesFeature(rawHostDirectives){const feature=definition=>{const resolved=(Array.isArray(rawHostDirectives)?rawHostDirectives:rawHostDirectives()).map((dir=>"function"==typeof dir?{directive:resolveForwardRef(dir),inputs:EMPTY_OBJ,outputs:EMPTY_OBJ}:{directive:resolveForwardRef(dir.directive),inputs:bindingArrayToMap(dir.inputs),outputs:bindingArrayToMap(dir.outputs)}));null===definition.hostDirectives?(definition.findHostDirectiveDefs=findHostDirectiveDefs,definition.hostDirectives=resolved):definition.hostDirectives.unshift(...resolved)};return feature.ngInherit=!0,feature}function findHostDirectiveDefs(currentDef,matchedDefs,hostDirectiveDefs){if(null!==currentDef.hostDirectives)for(const hostDirectiveConfig of currentDef.hostDirectives){const hostDirectiveDef=getDirectiveDef(hostDirectiveConfig.directive);("undefined"==typeof ngDevMode||ngDevMode)&&validateHostDirective(hostDirectiveConfig,hostDirectiveDef),patchDeclaredInputs(hostDirectiveDef.declaredInputs,hostDirectiveConfig.inputs),findHostDirectiveDefs(hostDirectiveDef,matchedDefs,hostDirectiveDefs),hostDirectiveDefs.set(hostDirectiveDef,hostDirectiveConfig),matchedDefs.push(hostDirectiveDef)}}function bindingArrayToMap(bindings){if(void 0===bindings||0===bindings.length)return EMPTY_OBJ;const result={};for(let i=0;i<bindings.length;i+=2)result[bindings[i]]=bindings[i+1];return result}function patchDeclaredInputs(declaredInputs,exposedInputs){for(const publicName in exposedInputs)if(exposedInputs.hasOwnProperty(publicName)){const remappedPublicName=exposedInputs[publicName],privateName=declaredInputs[publicName];("undefined"==typeof ngDevMode||ngDevMode)&&declaredInputs.hasOwnProperty(remappedPublicName)&&assertEqual(declaredInputs[remappedPublicName],declaredInputs[publicName],`Conflicting host directive input alias ${publicName}.`),declaredInputs[remappedPublicName]=privateName}}function validateHostDirective(hostDirectiveConfig,directiveDef){const type=hostDirectiveConfig.directive;if(null===directiveDef){if(null!==getComponentDef(type))throw new RuntimeError(310,`Host directive ${type.name} cannot be a component.`);throw new RuntimeError(307,`Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`)}if(!directiveDef.standalone)throw new RuntimeError(308,`Host directive ${directiveDef.type.name} must be standalone.`);validateMappings("input",directiveDef,hostDirectiveConfig.inputs),validateMappings("output",directiveDef,hostDirectiveConfig.outputs)}function validateMappings(bindingType,def,hostDirectiveBindings){const className=def.type.name,bindings="input"===bindingType?def.inputs:def.outputs;for(const publicName in hostDirectiveBindings)if(hostDirectiveBindings.hasOwnProperty(publicName)){if(!bindings.hasOwnProperty(publicName))throw new RuntimeError(311,`Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);const remappedPublicName=hostDirectiveBindings[publicName];if(bindings.hasOwnProperty(remappedPublicName)&&remappedPublicName!==publicName)throw new RuntimeError(312,`Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`)}}function ɵɵInputTransformsFeature(definition){const inputs=definition.inputConfig,inputTransforms={};for(const minifiedKey in inputs)if(inputs.hasOwnProperty(minifiedKey)){const value=inputs[minifiedKey];Array.isArray(value)&&value[3]&&(inputTransforms[minifiedKey]=value[3])}definition.inputTransforms=inputTransforms}class NgModuleRef$1{}class NgModuleFactory$1{}function createNgModule(ngModule,parentInjector){return new NgModuleRef(ngModule,parentInjector??null,[])}class NgModuleRef extends NgModuleRef$1{constructor(ngModuleType,_parent,additionalProviders){super(),this._parent=_parent,this._bootstrapComponents=[],this.destroyCbs=[],this.componentFactoryResolver=new ComponentFactoryResolver(this);const ngModuleDef=getNgModuleDef(ngModuleType);ngDevMode&&assertDefined(ngModuleDef,`NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`),this._bootstrapComponents=maybeUnwrapFn(ngModuleDef.bootstrap),this._r3Injector=createInjectorWithoutInjectorInstances(ngModuleType,_parent,[{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver},...additionalProviders],stringify(ngModuleType),new Set(["environment"])),this._r3Injector.resolveInjectorInitializers(),this.instance=this._r3Injector.get(ngModuleType)}get injector(){return this._r3Injector}destroy(){ngDevMode&&assertDefined(this.destroyCbs,"NgModule already destroyed");const injector=this._r3Injector;!injector.destroyed&&injector.destroy(),this.destroyCbs.forEach((fn=>fn())),this.destroyCbs=null}onDestroy(callback){ngDevMode&&assertDefined(this.destroyCbs,"NgModule already destroyed"),this.destroyCbs.push(callback)}}class NgModuleFactory extends NgModuleFactory$1{constructor(moduleType){super(),this.moduleType=moduleType}create(parentInjector){return new NgModuleRef(this.moduleType,parentInjector,[])}}class EnvironmentNgModuleRefAdapter extends NgModuleRef$1{constructor(config){super(),this.componentFactoryResolver=new ComponentFactoryResolver(this),this.instance=null;const injector=new R3Injector([...config.providers,{provide:NgModuleRef$1,useValue:this},{provide:ComponentFactoryResolver$1,useValue:this.componentFactoryResolver}],config.parent||getNullInjector(),config.debugName,new Set(["environment"]));this.injector=injector,config.runEnvironmentInitializers&&injector.resolveInjectorInitializers()}destroy(){this.injector.destroy()}onDestroy(callback){this.injector.onDestroy(callback)}}function createEnvironmentInjector(providers,parent,debugName=null){return new EnvironmentNgModuleRefAdapter({providers,parent,debugName,runEnvironmentInitializers:!0}).injector}class CachedInjectorService{constructor(){this.cachedInjectors=new Map}getOrCreateInjector(key,parentInjector,providers,debugName){if(!this.cachedInjectors.has(key)){const injector=providers.length>0?createEnvironmentInjector(providers,parentInjector,debugName):null;this.cachedInjectors.set(key,injector)}return this.cachedInjectors.get(key)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static#_=this.ɵprov=ɵɵdefineInjectable({token:CachedInjectorService,providedIn:"environment",factory:()=>new CachedInjectorService})}function setClassMetadata(type,decorators,ctorParameters,propDecorators){return noSideEffects((()=>{const clazz=type;null!==decorators&&(clazz.hasOwnProperty("decorators")&&void 0!==clazz.decorators?clazz.decorators.push(...decorators):clazz.decorators=decorators),null!==ctorParameters&&(clazz.ctorParameters=ctorParameters),null!==propDecorators&&(clazz.hasOwnProperty("propDecorators")&&void 0!==clazz.propDecorators?clazz.propDecorators={...clazz.propDecorators,...propDecorators}:clazz.propDecorators=propDecorators)}))}class PendingTasks{constructor(){this.taskId=0,this.pendingTasks=new Set,this.hasPendingTasks=new BehaviorSubject.t(!1)}get _hasPendingTasks(){return this.hasPendingTasks.value}add(){this._hasPendingTasks||this.hasPendingTasks.next(!0);const taskId=this.taskId++;return this.pendingTasks.add(taskId),taskId}remove(taskId){this.pendingTasks.delete(taskId),0===this.pendingTasks.size&&this._hasPendingTasks&&this.hasPendingTasks.next(!1)}ngOnDestroy(){this.pendingTasks.clear(),this._hasPendingTasks&&this.hasPendingTasks.next(!1)}static#_=this.ɵfac=function PendingTasks_Factory(t){return new(t||PendingTasks)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:PendingTasks,factory:PendingTasks.ɵfac,providedIn:"root"})}function isListLikeIterable(obj){return!!isJsObject(obj)&&(Array.isArray(obj)||!(obj instanceof Map)&&Symbol.iterator in obj)}function isJsObject(o){return null!==o&&("function"==typeof o||"object"==typeof o)}function devModeEqual(a,b){const isListLikeIterableA=isListLikeIterable(a),isListLikeIterableB=isListLikeIterable(b);if(isListLikeIterableA&&isListLikeIterableB)return function areIterablesEqual(a,b,comparator){const iterator1=a[Symbol.iterator](),iterator2=b[Symbol.iterator]();for(;;){const item1=iterator1.next(),item2=iterator2.next();if(item1.done&&item2.done)return!0;if(item1.done||item2.done)return!1;if(!comparator(item1.value,item2.value))return!1}}(a,b,devModeEqual);return!(isListLikeIterableA||!(a&&("object"==typeof a||"function"==typeof a))||isListLikeIterableB||!(b&&("object"==typeof b||"function"==typeof b)))||Object.is(a,b)}function updateBinding(lView,bindingIndex,value){return lView[bindingIndex]=value}function getBinding(lView,bindingIndex){return ngDevMode&&assertIndexInRange(lView,bindingIndex),ngDevMode&&assertNotSame(lView[bindingIndex],NO_CHANGE,"Stored value should never be NO_CHANGE."),lView[bindingIndex]}function bindingUpdated(lView,bindingIndex,value){ngDevMode&&assertNotSame(value,NO_CHANGE,"Incoming value should never be NO_CHANGE."),ngDevMode&&assertLessThan(bindingIndex,lView.length,"Slot should have been initialized to NO_CHANGE");const oldValue=lView[bindingIndex];if(Object.is(oldValue,value))return!1;if(ngDevMode&&isInCheckNoChangesMode()){const oldValueToCompare=oldValue!==NO_CHANGE?oldValue:void 0;if(!devModeEqual(oldValueToCompare,value)){const details=function getExpressionChangedErrorDetails(lView,bindingIndex,oldValue,newValue){const tData=lView[TVIEW].data,metadata=tData[bindingIndex];if("string"==typeof metadata)return metadata.indexOf(INTERPOLATION_DELIMITER)>-1?constructDetailsForInterpolation(lView,bindingIndex,bindingIndex,metadata,newValue):{propName:metadata,oldValue,newValue};if(null===metadata){let idx=bindingIndex-1;for(;"string"!=typeof tData[idx]&&null===tData[idx+1];)idx--;const meta=tData[idx];if("string"==typeof meta){const matches=meta.match(new RegExp(INTERPOLATION_DELIMITER,"g"));if(matches&&matches.length-1>bindingIndex-idx)return constructDetailsForInterpolation(lView,idx,bindingIndex,meta,newValue)}}return{propName:void 0,oldValue,newValue}}(lView,bindingIndex,oldValueToCompare,value);!function throwErrorIfNoChangesMode(creationMode,oldValue,currValue,propName,lView){const hostComponentDef=getDeclarationComponentDef(lView),componentClassName=hostComponentDef?.type?.name;let msg=`ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${propName?` for '${propName}'`:""}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName?` Expression location: ${componentClassName} component`:""}`;throw creationMode&&(msg+=" It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?"),new RuntimeError(-100,msg)}(oldValue===NO_CHANGE,details.oldValue,details.newValue,details.propName,lView)}return!1}return lView[bindingIndex]=value,!0}function bindingUpdated2(lView,bindingIndex,exp1,exp2){const different=bindingUpdated(lView,bindingIndex,exp1);return bindingUpdated(lView,bindingIndex+1,exp2)||different}function bindingUpdated3(lView,bindingIndex,exp1,exp2,exp3){const different=bindingUpdated2(lView,bindingIndex,exp1,exp2);return bindingUpdated(lView,bindingIndex+2,exp3)||different}function bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4){const different=bindingUpdated2(lView,bindingIndex,exp1,exp2);return bindingUpdated2(lView,bindingIndex+2,exp3,exp4)||different}function isDetachedByI18n(tNode){return!(32&~tNode.flags)}function ɵɵtemplate(index,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex,localRefExtractor){const lView=getLView(),tView=getTView(),adjustedIndex=index+HEADER_OFFSET,tNode=tView.firstCreatePass?function templateFirstCreatePass(index,tView,lView,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&ngDevMode.firstCreatePass++;const tViewConsts=tView.consts,tNode=getOrCreateTNode(tView,index,4,tagName||null,getConstant(tViewConsts,attrsIndex));resolveDirectives(tView,lView,tNode,getConstant(tViewConsts,localRefsIndex)),registerPostOrderHooks(tView,tNode);const embeddedTView=tNode.tView=createTView(2,tNode,templateFn,decls,vars,tView.directiveRegistry,tView.pipeRegistry,null,tView.schemas,tViewConsts,null);return null!==tView.queries&&(tView.queries.template(tView,tNode),embeddedTView.queries=tView.queries.embeddedTView(tNode)),tNode}(adjustedIndex,tView,lView,templateFn,decls,vars,tagName,attrsIndex,localRefsIndex):tView.data[adjustedIndex];setCurrentTNode(tNode,!1);const comment=_locateOrCreateContainerAnchor(tView,lView,tNode,index);wasLastNodeCreated()&&appendChild(tView,lView,comment,tNode),attachPatchData(comment,lView);const lContainer=createLContainer(comment,lView,comment,tNode);return lView[adjustedIndex]=lContainer,addToViewTree(lView,lContainer),populateDehydratedViewsInLContainer(lContainer,tNode,lView),isDirectiveHost(tNode)&&createDirectivesInstances(tView,lView,tNode),null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode,localRefExtractor),ɵɵtemplate}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(PendingTasks,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);let _locateOrCreateContainerAnchor=createContainerAnchorImpl;function createContainerAnchorImpl(tView,lView,tNode,index){return lastNodeWasCreated(!0),lView[RENDERER].createComment(ngDevMode?"container":"")}var DeferDependenciesLoadingState;!function(DeferDependenciesLoadingState){DeferDependenciesLoadingState[DeferDependenciesLoadingState.NOT_STARTED=0]="NOT_STARTED",DeferDependenciesLoadingState[DeferDependenciesLoadingState.IN_PROGRESS=1]="IN_PROGRESS",DeferDependenciesLoadingState[DeferDependenciesLoadingState.COMPLETE=2]="COMPLETE",DeferDependenciesLoadingState[DeferDependenciesLoadingState.FAILED=3]="FAILED"}(DeferDependenciesLoadingState||(DeferDependenciesLoadingState={}));const MINIMUM_SLOT=0,LOADING_AFTER_SLOT=1;var DeferBlockState,DeferBlockInternalState;!function(DeferBlockState){DeferBlockState[DeferBlockState.Placeholder=0]="Placeholder",DeferBlockState[DeferBlockState.Loading=1]="Loading",DeferBlockState[DeferBlockState.Complete=2]="Complete",DeferBlockState[DeferBlockState.Error=3]="Error"}(DeferBlockState||(DeferBlockState={})),function(DeferBlockInternalState){DeferBlockInternalState[DeferBlockInternalState.Initial=-1]="Initial"}(DeferBlockInternalState||(DeferBlockInternalState={}));const NEXT_DEFER_BLOCK_STATE=0,DEFER_BLOCK_STATE=1,STATE_IS_FROZEN_UNTIL=2,LOADING_AFTER_CLEANUP_FN=3,TRIGGER_CLEANUP_FNS=4,PREFETCH_TRIGGER_CLEANUP_FNS=5;var DeferBlockBehavior;function storeTriggerCleanupFn(type,lDetails,cleanupFn){const key=1===type?PREFETCH_TRIGGER_CLEANUP_FNS:TRIGGER_CLEANUP_FNS;null===lDetails[key]&&(lDetails[key]=[]),lDetails[key].push(cleanupFn)}function invokeTriggerCleanupFns(type,lDetails){const key=1===type?PREFETCH_TRIGGER_CLEANUP_FNS:TRIGGER_CLEANUP_FNS,cleanupFns=lDetails[key];if(null!==cleanupFns){for(const cleanupFn of cleanupFns)cleanupFn();lDetails[key]=null}}function invokeAllTriggerCleanupFns(lDetails){invokeTriggerCleanupFns(1,lDetails),invokeTriggerCleanupFns(0,lDetails)}function getDeferBlockDataIndex(deferBlockIndex){return deferBlockIndex+1}function getLDeferBlockDetails(lView,tNode){const tView=lView[TVIEW],slotIndex=getDeferBlockDataIndex(tNode.index);return ngDevMode&&assertIndexInDeclRange(tView,slotIndex),lView[slotIndex]}function getTDeferBlockDetails(tView,tNode){const slotIndex=getDeferBlockDataIndex(tNode.index);return ngDevMode&&assertIndexInDeclRange(tView,slotIndex),tView.data[slotIndex]}function getMinimumDurationForState(tDetails,currentState){return currentState===DeferBlockState.Placeholder?tDetails.placeholderBlockConfig?.[MINIMUM_SLOT]??null:currentState===DeferBlockState.Loading?tDetails.loadingBlockConfig?.[MINIMUM_SLOT]??null:null}function getLoadingBlockAfter(tDetails){return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT]??null}function addDepsToRegistry(currentDeps,newDeps){if(!currentDeps||0===currentDeps.length)return newDeps;const currentDepSet=new Set(currentDeps);for(const dep of newDeps)currentDepSet.add(dep);return currentDeps.length===currentDepSet.size?currentDeps:Array.from(currentDepSet)}function assertDeferredDependenciesLoaded(tDetails){assertEqual(tDetails.loadingState,DeferDependenciesLoadingState.COMPLETE,"Expecting all deferred dependencies to be loaded.")}!function(DeferBlockBehavior){DeferBlockBehavior[DeferBlockBehavior.Manual=0]="Manual",DeferBlockBehavior[DeferBlockBehavior.Playthrough=1]="Playthrough"}(DeferBlockBehavior||(DeferBlockBehavior={}));const eventListenerOptions={passive:!0,capture:!0},hoverTriggers=new WeakMap,interactionTriggers=new WeakMap,viewportTriggers=new WeakMap,interactionEventNames=["click","keydown"],hoverEventNames=["mouseenter","focusin"];let intersectionObserver=null,observedViewportElements=0;class DeferEventEntry{constructor(){this.callbacks=new Set,this.listener=()=>{for(const callback of this.callbacks)callback()}}}function onInteraction(trigger,callback){let entry=interactionTriggers.get(trigger);if(!entry){entry=new DeferEventEntry,interactionTriggers.set(trigger,entry);for(const name of interactionEventNames)trigger.addEventListener(name,entry.listener,eventListenerOptions)}return entry.callbacks.add(callback),()=>{const{callbacks,listener}=entry;if(callbacks.delete(callback),0===callbacks.size){interactionTriggers.delete(trigger);for(const name of interactionEventNames)trigger.removeEventListener(name,listener,eventListenerOptions)}}}function onHover(trigger,callback){let entry=hoverTriggers.get(trigger);if(!entry){entry=new DeferEventEntry,hoverTriggers.set(trigger,entry);for(const name of hoverEventNames)trigger.addEventListener(name,entry.listener,eventListenerOptions)}return entry.callbacks.add(callback),()=>{const{callbacks,listener}=entry;if(callbacks.delete(callback),0===callbacks.size){for(const name of hoverEventNames)trigger.removeEventListener(name,listener,eventListenerOptions);hoverTriggers.delete(trigger)}}}function onViewport(trigger,callback,injector){const ngZone=injector.get(NgZone);let entry=viewportTriggers.get(trigger);return intersectionObserver=intersectionObserver||ngZone.runOutsideAngular((()=>new IntersectionObserver((entries=>{for(const current of entries)current.isIntersecting&&viewportTriggers.has(current.target)&&ngZone.run(viewportTriggers.get(current.target).listener)})))),entry||(entry=new DeferEventEntry,ngZone.runOutsideAngular((()=>intersectionObserver.observe(trigger))),viewportTriggers.set(trigger,entry),observedViewportElements++),entry.callbacks.add(callback),()=>{viewportTriggers.has(trigger)&&(entry.callbacks.delete(callback),0===entry.callbacks.size&&(intersectionObserver?.unobserve(trigger),viewportTriggers.delete(trigger),observedViewportElements--),0===observedViewportElements&&(intersectionObserver?.disconnect(),intersectionObserver=null))}}function getTriggerElement(triggerLView,triggerIndex){const element=getNativeByIndex(HEADER_OFFSET+triggerIndex,triggerLView);return ngDevMode&&function assertElement(node){node instanceof Element||throwError(`The provided value must be an element but got ${stringify(node)}`)}(element),element}function registerDomTrigger(initialLView,tNode,triggerIndex,walkUpTimes,registerFn,callback,type){const injector=initialLView[INJECTOR];internalAfterNextRender((function pollDomTrigger(){if(isDestroyed(initialLView))return;const lDetails=getLDeferBlockDetails(initialLView,tNode),renderedState=lDetails[DEFER_BLOCK_STATE];if(renderedState!==DeferBlockInternalState.Initial&&renderedState!==DeferBlockState.Placeholder)return;const triggerLView=function getTriggerLView(deferredHostLView,deferredTNode,walkUpTimes){if(null==walkUpTimes)return deferredHostLView;if(walkUpTimes>=0)return walkUpViews(walkUpTimes,deferredHostLView);const deferredContainer=deferredHostLView[deferredTNode.index];ngDevMode&&assertLContainer(deferredContainer);const triggerLView=deferredContainer[CONTAINER_HEADER_OFFSET]??null;ngDevMode&&null!==triggerLView&&(assertEqual(getLDeferBlockDetails(deferredHostLView,deferredTNode)[DEFER_BLOCK_STATE],DeferBlockState.Placeholder,"Expected a placeholder to be rendered in this defer block."),assertLView(triggerLView));return triggerLView}(initialLView,tNode,walkUpTimes);if(!triggerLView)return void internalAfterNextRender(pollDomTrigger,{injector});if(isDestroyed(triggerLView))return;const element=getTriggerElement(triggerLView,triggerIndex),cleanup=registerFn(element,(()=>{initialLView!==triggerLView&&removeLViewOnDestroy(triggerLView,cleanup),callback()}),injector);initialLView!==triggerLView&&storeLViewOnDestroy(triggerLView,cleanup),storeTriggerCleanupFn(type,lDetails,cleanup)}),{injector})}function onIdle(callback,lView){const scheduler=lView[INJECTOR].get(IdleScheduler);return scheduler.add(callback),()=>scheduler.remove(callback)}class IdleScheduler{constructor(){this.executingCallbacks=!1,this.idleId=null,this.current=new Set,this.deferred=new Set,this.ngZone=inject(NgZone),this.requestIdleCallbackFn=("undefined"!=typeof requestIdleCallback?requestIdleCallback:setTimeout).bind(globalThis),this.cancelIdleCallbackFn=("undefined"!=typeof requestIdleCallback?cancelIdleCallback:clearTimeout).bind(globalThis)}add(callback){(this.executingCallbacks?this.deferred:this.current).add(callback),null===this.idleId&&this.scheduleIdleCallback()}remove(callback){const{current,deferred}=this;current.delete(callback),deferred.delete(callback),0===current.size&&0===deferred.size&&this.cancelIdleCallback()}scheduleIdleCallback(){const callback=()=>{this.cancelIdleCallback(),this.executingCallbacks=!0;for(const callback of this.current)callback();if(this.current.clear(),this.executingCallbacks=!1,this.deferred.size>0){for(const callback of this.deferred)this.current.add(callback);this.deferred.clear(),this.scheduleIdleCallback()}};this.idleId=this.requestIdleCallbackFn((()=>this.ngZone.run(callback)))}cancelIdleCallback(){null!==this.idleId&&(this.cancelIdleCallbackFn(this.idleId),this.idleId=null)}ngOnDestroy(){this.cancelIdleCallback(),this.current.clear(),this.deferred.clear()}static#_=this.ɵprov=ɵɵdefineInjectable({token:IdleScheduler,providedIn:"root",factory:()=>new IdleScheduler})}function onTimer(delay){return(callback,lView)=>scheduleTimerTrigger(delay,callback,lView)}function scheduleTimerTrigger(delay,callback,lView){const scheduler=lView[INJECTOR].get(TimerScheduler);return scheduler.add(delay,callback),()=>scheduler.remove(callback)}class TimerScheduler{constructor(){this.executingCallbacks=!1,this.timeoutId=null,this.invokeTimerAt=null,this.current=[],this.deferred=[]}add(delay,callback){const target=this.executingCallbacks?this.deferred:this.current;this.addToQueue(target,Date.now()+delay,callback),this.scheduleTimer()}remove(callback){const{current,deferred}=this;-1===this.removeFromQueue(current,callback)&&this.removeFromQueue(deferred,callback),0===current.length&&0===deferred.length&&this.clearTimeout()}addToQueue(target,invokeAt,callback){let insertAtIndex=target.length;for(let i=0;i<target.length;i+=2){if(target[i]>invokeAt){insertAtIndex=i;break}}arrayInsert2(target,insertAtIndex,invokeAt,callback)}removeFromQueue(target,callback){let index=-1;for(let i=0;i<target.length;i+=2){if(target[i+1]===callback){index=i;break}}return index>-1&&arraySplice(target,index,2),index}scheduleTimer(){const callback=()=>{this.clearTimeout(),this.executingCallbacks=!0;const current=[...this.current],now=Date.now();for(let i=0;i<current.length;i+=2){const callback=current[i+1];if(!(current[i]<=now))break;callback()}let lastCallbackIndex=-1;for(let i=0;i<this.current.length;i+=2){if(!(this.current[i]<=now))break;lastCallbackIndex=i+1}if(lastCallbackIndex>=0&&arraySplice(this.current,0,lastCallbackIndex+1),this.executingCallbacks=!1,this.deferred.length>0){for(let i=0;i<this.deferred.length;i+=2){const invokeAt=this.deferred[i],callback=this.deferred[i+1];this.addToQueue(this.current,invokeAt,callback)}this.deferred.length=0}this.scheduleTimer()};if(this.current.length>0){const now=Date.now(),invokeAt=this.current[0];if(null===this.timeoutId||this.invokeTimerAt&&this.invokeTimerAt-invokeAt>16){this.clearTimeout();const timeout=Math.max(invokeAt-now,16);this.invokeTimerAt=invokeAt,this.timeoutId=setTimeout(callback,timeout)}}}clearTimeout(){null!==this.timeoutId&&(clearTimeout(this.timeoutId),this.timeoutId=null)}ngOnDestroy(){this.clearTimeout(),this.current.length=0,this.deferred.length=0}static#_=this.ɵprov=ɵɵdefineInjectable({token:TimerScheduler,providedIn:"root",factory:()=>new TimerScheduler})}const DEFER_BLOCK_DEPENDENCY_INTERCEPTOR=new InjectionToken("DEFER_BLOCK_DEPENDENCY_INTERCEPTOR"),DEFER_BLOCK_CONFIG=new InjectionToken(ngDevMode?"DEFER_BLOCK_CONFIG":"");function shouldTriggerDeferBlock(injector){const config=injector.get(DEFER_BLOCK_CONFIG,null,{optional:!0});return config?.behavior!==DeferBlockBehavior.Manual&&isPlatformBrowser(injector)}let applyDeferBlockStateWithSchedulingImpl=null;function ɵɵdeferEnableTimerScheduling(tView,tDetails,placeholderConfigIndex,loadingConfigIndex){const tViewConsts=tView.consts;null!=placeholderConfigIndex&&(tDetails.placeholderBlockConfig=getConstant(tViewConsts,placeholderConfigIndex)),null!=loadingConfigIndex&&(tDetails.loadingBlockConfig=getConstant(tViewConsts,loadingConfigIndex)),null===applyDeferBlockStateWithSchedulingImpl&&(applyDeferBlockStateWithSchedulingImpl=applyDeferBlockStateWithScheduling)}function ɵɵdefer(index,primaryTmplIndex,dependencyResolverFn,loadingTmplIndex,placeholderTmplIndex,errorTmplIndex,loadingConfigIndex,placeholderConfigIndex,enableTimerScheduling){const lView=getLView(),tView=getTView(),adjustedIndex=index+HEADER_OFFSET;if(ɵɵtemplate(index,null,0,0),tView.firstCreatePass){performanceMarkFeature("NgDefer");const tDetails={primaryTmplIndex,loadingTmplIndex:loadingTmplIndex??null,placeholderTmplIndex:placeholderTmplIndex??null,errorTmplIndex:errorTmplIndex??null,placeholderBlockConfig:null,loadingBlockConfig:null,dependencyResolverFn:dependencyResolverFn??null,loadingState:DeferDependenciesLoadingState.NOT_STARTED,loadingPromise:null,providers:null};enableTimerScheduling?.(tView,tDetails,placeholderConfigIndex,loadingConfigIndex),function setTDeferBlockDetails(tView,deferBlockIndex,deferBlockConfig){const slotIndex=getDeferBlockDataIndex(deferBlockIndex);ngDevMode&&assertIndexInDeclRange(tView,slotIndex),tView.data[slotIndex]=deferBlockConfig}(tView,adjustedIndex,tDetails)}const tNode=getCurrentTNode();populateDehydratedViewsInLContainer(lView[adjustedIndex],tNode,lView);const lDetails=[null,DeferBlockInternalState.Initial,null,null,null,null];!function setLDeferBlockDetails(lView,deferBlockIndex,lDetails){const tView=lView[TVIEW],slotIndex=getDeferBlockDataIndex(deferBlockIndex);ngDevMode&&assertIndexInDeclRange(tView,slotIndex),lView[slotIndex]=lDetails}(lView,adjustedIndex,lDetails);const cleanupTriggersFn=()=>invokeAllTriggerCleanupFns(lDetails);storeTriggerCleanupFn(0,lDetails,(()=>removeLViewOnDestroy(lView,cleanupTriggersFn))),storeLViewOnDestroy(lView,cleanupTriggersFn)}function ɵɵdeferWhen(rawValue){const lView=getLView();if(bindingUpdated(lView,nextBindingIndex(),rawValue)){const prevConsumer=setActiveConsumer(null);try{const value=Boolean(rawValue),tNode=getSelectedTNode(),renderedState=getLDeferBlockDetails(lView,tNode)[DEFER_BLOCK_STATE];!1===value&&renderedState===DeferBlockInternalState.Initial?renderPlaceholder(lView,tNode):!0!==value||renderedState!==DeferBlockInternalState.Initial&&renderedState!==DeferBlockState.Placeholder||triggerDeferBlock(lView,tNode)}finally{setActiveConsumer(prevConsumer)}}}function ɵɵdeferPrefetchWhen(rawValue){const lView=getLView();if(bindingUpdated(lView,nextBindingIndex(),rawValue)){const prevConsumer=setActiveConsumer(null);try{const value=Boolean(rawValue),tView=lView[TVIEW],tNode=getSelectedTNode(),tDetails=getTDeferBlockDetails(tView,tNode);!0===value&&tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&triggerPrefetching(tDetails,lView,tNode)}finally{setActiveConsumer(prevConsumer)}}}function ɵɵdeferOnIdle(){scheduleDelayedTrigger(onIdle)}function ɵɵdeferPrefetchOnIdle(){scheduleDelayedPrefetching(onIdle)}function ɵɵdeferOnImmediate(){const lView=getLView(),tNode=getCurrentTNode(),tView=lView[TVIEW],injector=lView[INJECTOR],tDetails=getTDeferBlockDetails(tView,tNode);shouldTriggerDeferBlock(injector)&&null!==tDetails.loadingTmplIndex||renderPlaceholder(lView,tNode),triggerDeferBlock(lView,tNode)}function ɵɵdeferPrefetchOnImmediate(){const lView=getLView(),tNode=getCurrentTNode(),tDetails=getTDeferBlockDetails(lView[TVIEW],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&triggerResourceLoading(tDetails,lView,tNode)}function ɵɵdeferOnTimer(delay){scheduleDelayedTrigger(onTimer(delay))}function ɵɵdeferPrefetchOnTimer(delay){scheduleDelayedPrefetching(onTimer(delay))}function ɵɵdeferOnHover(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode();renderPlaceholder(lView,tNode),registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onHover,(()=>triggerDeferBlock(lView,tNode)),0)}function ɵɵdeferPrefetchOnHover(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode(),tDetails=getTDeferBlockDetails(lView[TVIEW],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onHover,(()=>triggerPrefetching(tDetails,lView,tNode)),1)}function ɵɵdeferOnInteraction(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode();renderPlaceholder(lView,tNode),registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onInteraction,(()=>triggerDeferBlock(lView,tNode)),0)}function ɵɵdeferPrefetchOnInteraction(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode(),tDetails=getTDeferBlockDetails(lView[TVIEW],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onInteraction,(()=>triggerPrefetching(tDetails,lView,tNode)),1)}function ɵɵdeferOnViewport(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode();renderPlaceholder(lView,tNode),registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onViewport,(()=>triggerDeferBlock(lView,tNode)),0)}function ɵɵdeferPrefetchOnViewport(triggerIndex,walkUpTimes){const lView=getLView(),tNode=getCurrentTNode(),tDetails=getTDeferBlockDetails(lView[TVIEW],tNode);tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED&&registerDomTrigger(lView,tNode,triggerIndex,walkUpTimes,onViewport,(()=>triggerPrefetching(tDetails,lView,tNode)),1)}function scheduleDelayedTrigger(scheduleFn){const lView=getLView(),tNode=getCurrentTNode();if(renderPlaceholder(lView,tNode),isPlatformBrowser(lView[INJECTOR])){const cleanupFn=scheduleFn((()=>triggerDeferBlock(lView,tNode)),lView);storeTriggerCleanupFn(0,getLDeferBlockDetails(lView,tNode),cleanupFn)}}function scheduleDelayedPrefetching(scheduleFn){const lView=getLView();if(isPlatformBrowser(lView[INJECTOR])){const tNode=getCurrentTNode(),tDetails=getTDeferBlockDetails(lView[TVIEW],tNode);if(tDetails.loadingState===DeferDependenciesLoadingState.NOT_STARTED){storeTriggerCleanupFn(1,getLDeferBlockDetails(lView,tNode),scheduleFn((()=>triggerPrefetching(tDetails,lView,tNode)),lView))}}}function renderDeferBlockState(newState,tNode,lContainer,skipTimerScheduling=!1){const hostLView=lContainer[PARENT],hostTView=hostLView[TVIEW];if(isDestroyed(hostLView))return;ngDevMode&&assertTNodeForLView(tNode,hostLView);const lDetails=getLDeferBlockDetails(hostLView,tNode);ngDevMode&&assertDefined(lDetails,"Expected a defer block state defined");if(isValidStateChange(lDetails[DEFER_BLOCK_STATE],newState)&&isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE]??-1,newState)){const injector=hostLView[INJECTOR],tDetails=getTDeferBlockDetails(hostTView,tNode),needsScheduling=!skipTimerScheduling&&isPlatformBrowser(injector)&&(null!==getLoadingBlockAfter(tDetails)||null!==getMinimumDurationForState(tDetails,DeferBlockState.Loading)||getMinimumDurationForState(tDetails,DeferBlockState.Placeholder));ngDevMode&&needsScheduling&&assertDefined(applyDeferBlockStateWithSchedulingImpl,"Expected scheduling function to be defined");const applyStateFn=needsScheduling?applyDeferBlockStateWithSchedulingImpl:applyDeferBlockState;try{applyStateFn(newState,lDetails,lContainer,tNode,hostLView)}catch(error){handleError(hostLView,error)}}}function applyDeferBlockState(newState,lDetails,lContainer,tNode,hostLView){const stateTmplIndex=function getTemplateIndexForState(newState,hostLView,tNode){const tDetails=getTDeferBlockDetails(hostLView[TVIEW],tNode);switch(newState){case DeferBlockState.Complete:return tDetails.primaryTmplIndex;case DeferBlockState.Loading:return tDetails.loadingTmplIndex;case DeferBlockState.Error:return tDetails.errorTmplIndex;case DeferBlockState.Placeholder:return tDetails.placeholderTmplIndex;default:return ngDevMode&&throwError(`Unexpected defer block state: ${newState}`),null}}(newState,hostLView,tNode);if(null!==stateTmplIndex){lDetails[DEFER_BLOCK_STATE]=newState;const hostTView=hostLView[TVIEW],activeBlockTNode=getTNode(hostTView,stateTmplIndex+HEADER_OFFSET),viewIndex=0;let injector;if(removeLViewFromLContainer(lContainer,viewIndex),newState===DeferBlockState.Complete){const tDetails=getTDeferBlockDetails(hostTView,tNode),providers=tDetails.providers;if(providers&&providers.length>0){const parentInjector=hostLView[INJECTOR],isParentOutletInjector=function isRouterOutletInjector(currentInjector){return currentInjector instanceof ChainedInjector&&"function"==typeof currentInjector.injector.__ngOutletInjector}(parentInjector),parentEnvInjector=isParentOutletInjector?parentInjector:parentInjector.get(EnvironmentInjector);injector=parentEnvInjector.get(CachedInjectorService).getOrCreateInjector(tDetails,parentEnvInjector,providers,ngDevMode?"DeferBlock Injector":""),isParentOutletInjector&&(injector=function createRouterOutletInjector(parentOutletInjector,parentInjector){return parentOutletInjector.injector.__ngOutletInjector(parentInjector)}(parentInjector,injector))}}const dehydratedView=findMatchingDehydratedView(lContainer,activeBlockTNode.tView.ssrId),embeddedLView=createAndRenderEmbeddedLView(hostLView,activeBlockTNode,null,{dehydratedView,injector});addLViewToLContainer(lContainer,embeddedLView,viewIndex,shouldAddViewToDom(activeBlockTNode,dehydratedView)),markViewDirty(embeddedLView)}}function applyDeferBlockStateWithScheduling(newState,lDetails,lContainer,tNode,hostLView){const now=Date.now(),tDetails=getTDeferBlockDetails(hostLView[TVIEW],tNode);if(null===lDetails[STATE_IS_FROZEN_UNTIL]||lDetails[STATE_IS_FROZEN_UNTIL]<=now){lDetails[STATE_IS_FROZEN_UNTIL]=null;const loadingAfter=getLoadingBlockAfter(tDetails),inLoadingAfterPhase=null!==lDetails[LOADING_AFTER_CLEANUP_FN];if(newState!==DeferBlockState.Loading||null===loadingAfter||inLoadingAfterPhase){newState>DeferBlockState.Loading&&inLoadingAfterPhase&&(lDetails[LOADING_AFTER_CLEANUP_FN](),lDetails[LOADING_AFTER_CLEANUP_FN]=null,lDetails[NEXT_DEFER_BLOCK_STATE]=null),applyDeferBlockState(newState,lDetails,lContainer,tNode,hostLView);const duration=getMinimumDurationForState(tDetails,newState);null!==duration&&(lDetails[STATE_IS_FROZEN_UNTIL]=now+duration,scheduleDeferBlockUpdate(duration,lDetails,tNode,lContainer,hostLView))}else{lDetails[NEXT_DEFER_BLOCK_STATE]=newState;const cleanupFn=scheduleDeferBlockUpdate(loadingAfter,lDetails,tNode,lContainer,hostLView);lDetails[LOADING_AFTER_CLEANUP_FN]=cleanupFn}}else lDetails[NEXT_DEFER_BLOCK_STATE]=newState}function scheduleDeferBlockUpdate(timeout,lDetails,tNode,lContainer,hostLView){return scheduleTimerTrigger(timeout,(()=>{const nextState=lDetails[NEXT_DEFER_BLOCK_STATE];lDetails[STATE_IS_FROZEN_UNTIL]=null,lDetails[NEXT_DEFER_BLOCK_STATE]=null,null!==nextState&&renderDeferBlockState(nextState,tNode,lContainer)}),hostLView)}function isValidStateChange(currentState,newState){return currentState<newState}function triggerPrefetching(tDetails,lView,tNode){lView[INJECTOR]&&shouldTriggerDeferBlock(lView[INJECTOR])&&triggerResourceLoading(tDetails,lView,tNode)}function triggerResourceLoading(tDetails,lView,tNode){const injector=lView[INJECTOR],tView=lView[TVIEW];if(tDetails.loadingState!==DeferDependenciesLoadingState.NOT_STARTED)return tDetails.loadingPromise??Promise.resolve();const lDetails=getLDeferBlockDetails(lView,tNode),primaryBlockTNode=function getPrimaryBlockTNode(tView,tDetails){return getTNode(tView,tDetails.primaryTmplIndex+HEADER_OFFSET)}(tView,tDetails);tDetails.loadingState=DeferDependenciesLoadingState.IN_PROGRESS,invokeTriggerCleanupFns(1,lDetails);let dependenciesFn=tDetails.dependencyResolverFn;if(ngDevMode){const deferDependencyInterceptor=injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR,null,{optional:!0});deferDependencyInterceptor&&(dependenciesFn=deferDependencyInterceptor.intercept(dependenciesFn))}const pendingTasks=injector.get(PendingTasks),taskId=pendingTasks.add();return dependenciesFn?(tDetails.loadingPromise=Promise.allSettled(dependenciesFn()).then((results=>{let failed=!1;const directiveDefs=[],pipeDefs=[];for(const result of results){if("fulfilled"!==result.status){failed=!0;break}{const dependency=result.value,directiveDef=getComponentDef(dependency)||getDirectiveDef(dependency);if(directiveDef)directiveDefs.push(directiveDef);else{const pipeDef=getPipeDef$1(dependency);pipeDef&&pipeDefs.push(pipeDef)}}}if(tDetails.loadingPromise=null,pendingTasks.remove(taskId),failed){if(tDetails.loadingState=DeferDependenciesLoadingState.FAILED,null===tDetails.errorTmplIndex){const templateLocation=getTemplateLocationDetails(lView),error=new RuntimeError(750,ngDevMode&&`Loading dependencies for \`@defer\` block failed, but no \`@error\` block was configured${templateLocation}. Consider using the \`@error\` block to render an error state.`);handleError(lView,error)}}else{tDetails.loadingState=DeferDependenciesLoadingState.COMPLETE;const primaryBlockTView=primaryBlockTNode.tView;if(directiveDefs.length>0){primaryBlockTView.directiveRegistry=addDepsToRegistry(primaryBlockTView.directiveRegistry,directiveDefs);const providers=internalImportProvidersFrom(!1,...directiveDefs.map((def=>def.type)));tDetails.providers=providers}pipeDefs.length>0&&(primaryBlockTView.pipeRegistry=addDepsToRegistry(primaryBlockTView.pipeRegistry,pipeDefs))}})),tDetails.loadingPromise):(tDetails.loadingPromise=Promise.resolve().then((()=>{tDetails.loadingPromise=null,tDetails.loadingState=DeferDependenciesLoadingState.COMPLETE,pendingTasks.remove(taskId)})),tDetails.loadingPromise)}function renderPlaceholder(lView,tNode){const lContainer=lView[tNode.index];ngDevMode&&assertLContainer(lContainer),renderDeferBlockState(DeferBlockState.Placeholder,tNode,lContainer)}function renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer){ngDevMode&&assertDefined(tDetails.loadingPromise,"Expected loading Promise to exist on this defer block"),tDetails.loadingPromise.then((()=>{tDetails.loadingState===DeferDependenciesLoadingState.COMPLETE?(ngDevMode&&assertDeferredDependenciesLoaded(tDetails),renderDeferBlockState(DeferBlockState.Complete,tNode,lContainer)):tDetails.loadingState===DeferDependenciesLoadingState.FAILED&&renderDeferBlockState(DeferBlockState.Error,tNode,lContainer)}))}function triggerDeferBlock(lView,tNode){const tView=lView[TVIEW],lContainer=lView[tNode.index],injector=lView[INJECTOR];if(ngDevMode&&assertLContainer(lContainer),!shouldTriggerDeferBlock(injector))return;const lDetails=getLDeferBlockDetails(lView,tNode),tDetails=getTDeferBlockDetails(tView,tNode);switch(invokeAllTriggerCleanupFns(lDetails),tDetails.loadingState){case DeferDependenciesLoadingState.NOT_STARTED:renderDeferBlockState(DeferBlockState.Loading,tNode,lContainer),triggerResourceLoading(tDetails,lView,tNode),tDetails.loadingState===DeferDependenciesLoadingState.IN_PROGRESS&&renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer);break;case DeferDependenciesLoadingState.IN_PROGRESS:renderDeferBlockState(DeferBlockState.Loading,tNode,lContainer),renderDeferStateAfterResourceLoading(tDetails,tNode,lContainer);break;case DeferDependenciesLoadingState.COMPLETE:ngDevMode&&assertDeferredDependenciesLoaded(tDetails),renderDeferBlockState(DeferBlockState.Complete,tNode,lContainer);break;case DeferDependenciesLoadingState.FAILED:renderDeferBlockState(DeferBlockState.Error,tNode,lContainer);break;default:ngDevMode&&throwError("Unknown defer block state")}}function ɵɵattribute(name,value,sanitizer,namespace){const lView=getLView(),bindingIndex=nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,name,value,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,"attr."+name,bindingIndex)}return ɵɵattribute}function interpolationV(lView,values){ngDevMode&&assertLessThan(2,values.length,"should have at least 3 values"),ngDevMode&&assertEqual(values.length%2,1,"should have an odd number of values");let isBindingUpdated=!1,bindingIndex=getBindingIndex();for(let i=1;i<values.length;i+=2)isBindingUpdated=bindingUpdated(lView,bindingIndex++,values[i])||isBindingUpdated;if(setBindingIndex(bindingIndex),!isBindingUpdated)return NO_CHANGE;let content=values[0];for(let i=1;i<values.length;i+=2)content+=renderStringify(values[i])+values[i+1];return content}function interpolation1(lView,prefix,v0,suffix){return bindingUpdated(lView,nextBindingIndex(),v0)?prefix+renderStringify(v0)+suffix:NO_CHANGE}function interpolation2(lView,prefix,v0,i0,v1,suffix){const different=bindingUpdated2(lView,getBindingIndex(),v0,v1);return incrementBindingIndex(2),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+suffix:NO_CHANGE}function interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix){const different=bindingUpdated3(lView,getBindingIndex(),v0,v1,v2);return incrementBindingIndex(3),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+suffix:NO_CHANGE}function interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix){const different=bindingUpdated4(lView,getBindingIndex(),v0,v1,v2,v3);return incrementBindingIndex(4),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+i2+renderStringify(v3)+suffix:NO_CHANGE}function interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated(lView,bindingIndex+4,v4)||different,incrementBindingIndex(5),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+i2+renderStringify(v3)+i3+renderStringify(v4)+suffix:NO_CHANGE}function interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated2(lView,bindingIndex+4,v4,v5)||different,incrementBindingIndex(6),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+i2+renderStringify(v3)+i3+renderStringify(v4)+i4+renderStringify(v5)+suffix:NO_CHANGE}function interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated3(lView,bindingIndex+4,v4,v5,v6)||different,incrementBindingIndex(7),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+i2+renderStringify(v3)+i3+renderStringify(v4)+i4+renderStringify(v5)+i5+renderStringify(v6)+suffix:NO_CHANGE}function interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix){const bindingIndex=getBindingIndex();let different=bindingUpdated4(lView,bindingIndex,v0,v1,v2,v3);return different=bindingUpdated4(lView,bindingIndex+4,v4,v5,v6,v7)||different,incrementBindingIndex(8),different?prefix+renderStringify(v0)+i0+renderStringify(v1)+i1+renderStringify(v2)+i2+renderStringify(v3)+i3+renderStringify(v4)+i4+renderStringify(v5)+i5+renderStringify(v6)+i6+renderStringify(v7)+suffix:NO_CHANGE}function ɵɵattributeInterpolate1(attrName,prefix,v0,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation1(lView,prefix,v0,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-1,prefix,suffix)}return ɵɵattributeInterpolate1}function ɵɵattributeInterpolate2(attrName,prefix,v0,i0,v1,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation2(lView,prefix,v0,i0,v1,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-2,prefix,i0,suffix)}return ɵɵattributeInterpolate2}function ɵɵattributeInterpolate3(attrName,prefix,v0,i0,v1,i1,v2,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-3,prefix,i0,i1,suffix)}return ɵɵattributeInterpolate3}function ɵɵattributeInterpolate4(attrName,prefix,v0,i0,v1,i1,v2,i2,v3,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-4,prefix,i0,i1,i2,suffix)}return ɵɵattributeInterpolate4}function ɵɵattributeInterpolate5(attrName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-5,prefix,i0,i1,i2,i3,suffix)}return ɵɵattributeInterpolate5}function ɵɵattributeInterpolate6(attrName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-6,prefix,i0,i1,i2,i3,i4,suffix)}return ɵɵattributeInterpolate6}function ɵɵattributeInterpolate7(attrName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-7,prefix,i0,i1,i2,i3,i4,i5,suffix)}return ɵɵattributeInterpolate7}function ɵɵattributeInterpolate8(attrName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix,sanitizer,namespace){const lView=getLView(),interpolatedValue=interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix);if(interpolatedValue!==NO_CHANGE){const tNode=getSelectedTNode();elementAttributeInternal(tNode,lView,attrName,interpolatedValue,sanitizer,namespace),ngDevMode&&storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-8,prefix,i0,i1,i2,i3,i4,i5,i6,suffix)}return ɵɵattributeInterpolate8}function ɵɵattributeInterpolateV(attrName,values,sanitizer,namespace){const lView=getLView(),interpolated=interpolationV(lView,values);if(interpolated!==NO_CHANGE){const tNode=getSelectedTNode();if(elementAttributeInternal(tNode,lView,attrName,interpolated,sanitizer,namespace),ngDevMode){const interpolationInBetween=[values[0]];for(let i=2;i<values.length;i+=2)interpolationInBetween.push(values[i]);storePropertyBindingMetadata(getTView().data,tNode,"attr."+attrName,getBindingIndex()-interpolationInBetween.length+1,...interpolationInBetween)}}return ɵɵattributeInterpolateV}function toTStylingRange(prev,next){return ngDevMode&&assertNumberInRange(prev,0,32767),ngDevMode&&assertNumberInRange(next,0,32767),prev<<17|next<<2}function getTStylingRangePrev(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),tStylingRange>>17&32767}function setTStylingRangePrevDuplicate(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),2|tStylingRange}function getTStylingRangeNext(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),(131068&tStylingRange)>>2}function setTStylingRangeNext(tStylingRange,next){return ngDevMode&&assertNumber(tStylingRange,"expected number"),ngDevMode&&assertNumberInRange(next,0,32767),-131069&tStylingRange|next<<2}function setTStylingRangeNextDuplicate(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),1|tStylingRange}function insertTStylingBinding(tData,tNode,tStylingKeyWithStatic,index,isHostBinding,isClassBinding){ngDevMode&&assertFirstUpdatePass(getTView());let tBindings=isClassBinding?tNode.classBindings:tNode.styleBindings,tmplHead=getTStylingRangePrev(tBindings),tmplTail=getTStylingRangeNext(tBindings);tData[index]=tStylingKeyWithStatic;let tStylingKey,isKeyDuplicateOfStatic=!1;if(Array.isArray(tStylingKeyWithStatic)){const staticKeyValueArray=tStylingKeyWithStatic;tStylingKey=staticKeyValueArray[1],(null===tStylingKey||keyValueArrayIndexOf(staticKeyValueArray,tStylingKey)>0)&&(isKeyDuplicateOfStatic=!0)}else tStylingKey=tStylingKeyWithStatic;if(isHostBinding){if(0!==tmplTail){const previousNode=getTStylingRangePrev(tData[tmplHead+1]);tData[index+1]=toTStylingRange(previousNode,tmplHead),0!==previousNode&&(tData[previousNode+1]=setTStylingRangeNext(tData[previousNode+1],index)),tData[tmplHead+1]=function setTStylingRangePrev(tStylingRange,previous){return ngDevMode&&assertNumber(tStylingRange,"expected number"),ngDevMode&&assertNumberInRange(previous,0,32767),131071&tStylingRange|previous<<17}(tData[tmplHead+1],index)}else tData[index+1]=toTStylingRange(tmplHead,0),0!==tmplHead&&(tData[tmplHead+1]=setTStylingRangeNext(tData[tmplHead+1],index)),tmplHead=index}else tData[index+1]=toTStylingRange(tmplTail,0),ngDevMode&&assertEqual(0!==tmplHead&&0===tmplTail,!1,"Adding template bindings after hostBindings is not allowed."),0===tmplHead?tmplHead=index:tData[tmplTail+1]=setTStylingRangeNext(tData[tmplTail+1],index),tmplTail=index;isKeyDuplicateOfStatic&&(tData[index+1]=setTStylingRangePrevDuplicate(tData[index+1])),markDuplicates(tData,tStylingKey,index,!0),markDuplicates(tData,tStylingKey,index,!1),function markDuplicateOfResidualStyling(tNode,tStylingKey,tData,index,isClassBinding){const residual=isClassBinding?tNode.residualClasses:tNode.residualStyles;null!=residual&&"string"==typeof tStylingKey&&keyValueArrayIndexOf(residual,tStylingKey)>=0&&(tData[index+1]=setTStylingRangeNextDuplicate(tData[index+1]))}(tNode,tStylingKey,tData,index,isClassBinding),tBindings=toTStylingRange(tmplHead,tmplTail),isClassBinding?tNode.classBindings=tBindings:tNode.styleBindings=tBindings}function markDuplicates(tData,tStylingKey,index,isPrevDir){const tStylingAtIndex=tData[index+1],isMap=null===tStylingKey;let cursor=isPrevDir?getTStylingRangePrev(tStylingAtIndex):getTStylingRangeNext(tStylingAtIndex),foundDuplicate=!1;for(;0!==cursor&&(!1===foundDuplicate||isMap);){ngDevMode&&assertIndexInRange(tData,cursor);const tStylingValueAtCursor=tData[cursor],tStyleRangeAtCursor=tData[cursor+1];isStylingMatch(tStylingValueAtCursor,tStylingKey)&&(foundDuplicate=!0,tData[cursor+1]=isPrevDir?setTStylingRangeNextDuplicate(tStyleRangeAtCursor):setTStylingRangePrevDuplicate(tStyleRangeAtCursor)),cursor=isPrevDir?getTStylingRangePrev(tStyleRangeAtCursor):getTStylingRangeNext(tStyleRangeAtCursor)}foundDuplicate&&(tData[index+1]=isPrevDir?setTStylingRangePrevDuplicate(tStylingAtIndex):setTStylingRangeNextDuplicate(tStylingAtIndex))}function isStylingMatch(tStylingKeyCursor,tStylingKey){return ngDevMode&&assertNotEqual(Array.isArray(tStylingKey),!0,"Expected that 'tStylingKey' has been unwrapped"),null===tStylingKeyCursor||null==tStylingKey||(Array.isArray(tStylingKeyCursor)?tStylingKeyCursor[1]:tStylingKeyCursor)===tStylingKey||!(!Array.isArray(tStylingKeyCursor)||"string"!=typeof tStylingKey)&&keyValueArrayIndexOf(tStylingKeyCursor,tStylingKey)>=0}const parserState={textEnd:0,key:0,keyEnd:0,value:0,valueEnd:0};function getLastParsedKey(text){return text.substring(parserState.key,parserState.keyEnd)}function getLastParsedValue(text){return text.substring(parserState.value,parserState.valueEnd)}function parseClassNameNext(text,index){const end=parserState.textEnd;return end===index?-1:(index=parserState.keyEnd=function consumeClassToken(text,startIndex,endIndex){for(;startIndex<endIndex&&text.charCodeAt(startIndex)>32;)startIndex++;return startIndex}(text,parserState.key=index,end),consumeWhitespace(text,index,end))}function parseStyleNext(text,startIndex){const end=parserState.textEnd;let index=parserState.key=consumeWhitespace(text,startIndex,end);return end===index?-1:(index=parserState.keyEnd=function consumeStyleKey(text,startIndex,endIndex){let ch;for(;startIndex<endIndex&&(45===(ch=text.charCodeAt(startIndex))||95===ch||(-33&ch)>=65&&(-33&ch)<=90||ch>=48&&ch<=57);)startIndex++;return startIndex}(text,index,end),index=consumeSeparator(text,index,end,58),index=parserState.value=consumeWhitespace(text,index,end),index=parserState.valueEnd=function consumeStyleValue(text,startIndex,endIndex){let ch1=-1,ch2=-1,ch3=-1,i=startIndex,lastChIndex=i;for(;i<endIndex;){const ch=text.charCodeAt(i++);if(59===ch)return lastChIndex;34===ch||39===ch?lastChIndex=i=consumeQuotedText(text,ch,i,endIndex):startIndex===i-4&&85===ch3&&82===ch2&&76===ch1&&40===ch?lastChIndex=i=consumeQuotedText(text,41,i,endIndex):ch>32&&(lastChIndex=i),ch3=ch2,ch2=ch1,ch1=-33&ch}return lastChIndex}(text,index,end),consumeSeparator(text,index,end,59))}function resetParserState(text){parserState.key=0,parserState.keyEnd=0,parserState.value=0,parserState.valueEnd=0,parserState.textEnd=text.length}function consumeWhitespace(text,startIndex,endIndex){for(;startIndex<endIndex&&text.charCodeAt(startIndex)<=32;)startIndex++;return startIndex}function consumeSeparator(text,startIndex,endIndex,separator){return(startIndex=consumeWhitespace(text,startIndex,endIndex))<endIndex&&(ngDevMode&&text.charCodeAt(startIndex)!==separator&&malformedStyleError(text,String.fromCharCode(separator),startIndex),startIndex++),startIndex}function consumeQuotedText(text,quoteCharCode,startIndex,endIndex){let ch1=-1,index=startIndex;for(;index<endIndex;){const ch=text.charCodeAt(index++);if(ch==quoteCharCode&&92!==ch1)return index;ch1=92==ch&&92===ch1?0:ch}throw ngDevMode?malformedStyleError(text,String.fromCharCode(quoteCharCode),endIndex):new Error}function malformedStyleError(text,expecting,index){throw ngDevMode&&assertEqual("string"==typeof text,!0,"String expected here"),throwError(`Malformed style at location ${index} in string '`+text.substring(0,index)+"[>>"+text.substring(index,index+1)+"<<]"+text.slice(index+1)+`'. Expecting '${expecting}'.`)}function ɵɵproperty(propName,value,sanitizer){const lView=getLView(),bindingIndex=nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,value,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵproperty}function setDirectiveInputsWhichShadowsStyling(tView,tNode,lView,value,isClassBased){const property=isClassBased?"class":"style";setInputsForProperty(tView,lView,tNode.inputs[property],property,value)}function ɵɵstyleProp(prop,value,suffix){return checkStylingProperty(prop,value,suffix,!1),ɵɵstyleProp}function ɵɵclassProp(className,value){return checkStylingProperty(className,value,null,!0),ɵɵclassProp}function ɵɵstyleMap(styles){checkStylingMap(styleKeyValueArraySet,styleStringParser,styles,!1)}function styleStringParser(keyValueArray,text){for(let i=function parseStyle(text){return resetParserState(text),parseStyleNext(text,consumeWhitespace(text,0,parserState.textEnd))}(text);i>=0;i=parseStyleNext(text,i))styleKeyValueArraySet(keyValueArray,getLastParsedKey(text),getLastParsedValue(text))}function ɵɵclassMap(classes){checkStylingMap(classKeyValueArraySet,classStringParser,classes,!0)}function classStringParser(keyValueArray,text){for(let i=function parseClassName(text){return resetParserState(text),parseClassNameNext(text,consumeWhitespace(text,0,parserState.textEnd))}(text);i>=0;i=parseClassNameNext(text,i))keyValueArraySet(keyValueArray,getLastParsedKey(text),!0)}function checkStylingProperty(prop,value,suffix,isClassBased){const lView=getLView(),tView=getTView(),bindingIndex=incrementBindingIndex(2);if(tView.firstUpdatePass&&stylingFirstUpdatePass(tView,prop,bindingIndex,isClassBased),value!==NO_CHANGE&&bindingUpdated(lView,bindingIndex,value)){updateStyling(tView,tView.data[getSelectedIndex()],lView,lView[RENDERER],prop,lView[bindingIndex+1]=function normalizeSuffix(value,suffix){null==value||""===value||("string"==typeof suffix?value+=suffix:"object"==typeof value&&(value=stringify(unwrapSafeValue(value))));return value}(value,suffix),isClassBased,bindingIndex)}}function checkStylingMap(keyValueArraySet,stringParser,value,isClassBased){const tView=getTView(),bindingIndex=incrementBindingIndex(2);tView.firstUpdatePass&&stylingFirstUpdatePass(tView,null,bindingIndex,isClassBased);const lView=getLView();if(value!==NO_CHANGE&&bindingUpdated(lView,bindingIndex,value)){const tNode=tView.data[getSelectedIndex()];if(hasStylingInputShadow(tNode,isClassBased)&&!isInHostBindings(tView,bindingIndex)){if(ngDevMode){const tStylingKey=tView.data[bindingIndex];assertEqual(Array.isArray(tStylingKey)?tStylingKey[1]:tStylingKey,!1,"Styling linked list shadow input should be marked as 'false'")}let staticPrefix=isClassBased?tNode.classesWithoutHost:tNode.stylesWithoutHost;ngDevMode&&!1===isClassBased&&null!==staticPrefix&&assertEqual(staticPrefix.endsWith(";"),!0,"Expecting static portion to end with ';'"),null!==staticPrefix&&(value=concatStringsWithSpace(staticPrefix,value||"")),setDirectiveInputsWhichShadowsStyling(tView,tNode,lView,value,isClassBased)}else!function updateStylingMap(tView,tNode,lView,renderer,oldKeyValueArray,newKeyValueArray,isClassBased,bindingIndex){oldKeyValueArray===NO_CHANGE&&(oldKeyValueArray=EMPTY_ARRAY);let oldIndex=0,newIndex=0,oldKey=0<oldKeyValueArray.length?oldKeyValueArray[0]:null,newKey=0<newKeyValueArray.length?newKeyValueArray[0]:null;for(;null!==oldKey||null!==newKey;){ngDevMode&&assertLessThan(oldIndex,999,"Are we stuck in infinite loop?"),ngDevMode&&assertLessThan(newIndex,999,"Are we stuck in infinite loop?");const oldValue=oldIndex<oldKeyValueArray.length?oldKeyValueArray[oldIndex+1]:void 0,newValue=newIndex<newKeyValueArray.length?newKeyValueArray[newIndex+1]:void 0;let setValue,setKey=null;oldKey===newKey?(oldIndex+=2,newIndex+=2,oldValue!==newValue&&(setKey=newKey,setValue=newValue)):null===newKey||null!==oldKey&&oldKey<newKey?(oldIndex+=2,setKey=oldKey):(ngDevMode&&assertDefined(newKey,"Expecting to have a valid key"),newIndex+=2,setKey=newKey,setValue=newValue),null!==setKey&&updateStyling(tView,tNode,lView,renderer,setKey,setValue,isClassBased,bindingIndex),oldKey=oldIndex<oldKeyValueArray.length?oldKeyValueArray[oldIndex]:null,newKey=newIndex<newKeyValueArray.length?newKeyValueArray[newIndex]:null}}(tView,tNode,lView,lView[RENDERER],lView[bindingIndex+1],lView[bindingIndex+1]=function toStylingKeyValueArray(keyValueArraySet,stringParser,value){if(null==value||""===value)return EMPTY_ARRAY;const styleKeyValueArray=[],unwrappedValue=unwrapSafeValue(value);if(Array.isArray(unwrappedValue))for(let i=0;i<unwrappedValue.length;i++)keyValueArraySet(styleKeyValueArray,unwrappedValue[i],!0);else if("object"==typeof unwrappedValue)for(const key in unwrappedValue)unwrappedValue.hasOwnProperty(key)&&keyValueArraySet(styleKeyValueArray,key,unwrappedValue[key]);else"string"==typeof unwrappedValue?stringParser(styleKeyValueArray,unwrappedValue):ngDevMode&&throwError("Unsupported styling type "+typeof unwrappedValue+": "+unwrappedValue);return styleKeyValueArray}(keyValueArraySet,stringParser,value),isClassBased,bindingIndex)}}function isInHostBindings(tView,bindingIndex){return bindingIndex>=tView.expandoStartIndex}function stylingFirstUpdatePass(tView,tStylingKey,bindingIndex,isClassBased){ngDevMode&&assertFirstUpdatePass(tView);const tData=tView.data;if(null===tData[bindingIndex+1]){const tNode=tData[getSelectedIndex()];ngDevMode&&assertDefined(tNode,"TNode expected");const isHostBindings=isInHostBindings(tView,bindingIndex);hasStylingInputShadow(tNode,isClassBased)&&null===tStylingKey&&!isHostBindings&&(tStylingKey=!1),tStylingKey=function wrapInStaticStylingKey(tData,tNode,stylingKey,isClassBased){const hostDirectiveDef=getCurrentDirectiveDef(tData);let residual=isClassBased?tNode.residualClasses:tNode.residualStyles;if(null===hostDirectiveDef){0===(isClassBased?tNode.classBindings:tNode.styleBindings)&&(stylingKey=collectStylingFromTAttrs(stylingKey=collectStylingFromDirectives(null,tData,tNode,stylingKey,isClassBased),tNode.attrs,isClassBased),residual=null)}else{const directiveStylingLast=tNode.directiveStylingLast;if(-1===directiveStylingLast||tData[directiveStylingLast]!==hostDirectiveDef)if(stylingKey=collectStylingFromDirectives(hostDirectiveDef,tData,tNode,stylingKey,isClassBased),null===residual){let templateStylingKey=function getTemplateHeadTStylingKey(tData,tNode,isClassBased){const bindings=isClassBased?tNode.classBindings:tNode.styleBindings;if(0===getTStylingRangeNext(bindings))return;return tData[getTStylingRangePrev(bindings)]}(tData,tNode,isClassBased);void 0!==templateStylingKey&&Array.isArray(templateStylingKey)&&(templateStylingKey=collectStylingFromDirectives(null,tData,tNode,templateStylingKey[1],isClassBased),templateStylingKey=collectStylingFromTAttrs(templateStylingKey,tNode.attrs,isClassBased),function setTemplateHeadTStylingKey(tData,tNode,isClassBased,tStylingKey){const bindings=isClassBased?tNode.classBindings:tNode.styleBindings;ngDevMode&&assertNotEqual(getTStylingRangeNext(bindings),0,"Expecting to have at least one template styling binding."),tData[getTStylingRangePrev(bindings)]=tStylingKey}(tData,tNode,isClassBased,templateStylingKey))}else residual=function collectResidual(tData,tNode,isClassBased){let residual;const directiveEnd=tNode.directiveEnd;ngDevMode&&assertNotEqual(tNode.directiveStylingLast,-1,"By the time this function gets called at least one hostBindings-node styling instruction must have executed.");for(let i=1+tNode.directiveStylingLast;i<directiveEnd;i++){residual=collectStylingFromTAttrs(residual,tData[i].hostAttrs,isClassBased)}return collectStylingFromTAttrs(residual,tNode.attrs,isClassBased)}(tData,tNode,isClassBased)}void 0!==residual&&(isClassBased?tNode.residualClasses=residual:tNode.residualStyles=residual);return stylingKey}(tData,tNode,tStylingKey,isClassBased),insertTStylingBinding(tData,tNode,tStylingKey,bindingIndex,isHostBindings,isClassBased)}}function collectStylingFromDirectives(hostDirectiveDef,tData,tNode,stylingKey,isClassBased){let currentDirective=null;const directiveEnd=tNode.directiveEnd;let directiveStylingLast=tNode.directiveStylingLast;for(-1===directiveStylingLast?directiveStylingLast=tNode.directiveStart:directiveStylingLast++;directiveStylingLast<directiveEnd&&(currentDirective=tData[directiveStylingLast],ngDevMode&&assertDefined(currentDirective,"expected to be defined"),stylingKey=collectStylingFromTAttrs(stylingKey,currentDirective.hostAttrs,isClassBased),currentDirective!==hostDirectiveDef);)directiveStylingLast++;return null!==hostDirectiveDef&&(tNode.directiveStylingLast=directiveStylingLast),stylingKey}function collectStylingFromTAttrs(stylingKey,attrs,isClassBased){const desiredMarker=isClassBased?1:2;let currentMarker=-1;if(null!==attrs)for(let i=0;i<attrs.length;i++){const item=attrs[i];"number"==typeof item?currentMarker=item:currentMarker===desiredMarker&&(Array.isArray(stylingKey)||(stylingKey=void 0===stylingKey?[]:["",stylingKey]),keyValueArraySet(stylingKey,item,!!isClassBased||attrs[++i]))}return void 0===stylingKey?null:stylingKey}function styleKeyValueArraySet(keyValueArray,key,value){keyValueArraySet(keyValueArray,key,unwrapSafeValue(value))}function classKeyValueArraySet(keyValueArray,key,value){const stringKey=String(key);""===stringKey||stringKey.includes(" ")||keyValueArraySet(keyValueArray,stringKey,value)}function updateStyling(tView,tNode,lView,renderer,prop,value,isClassBased,bindingIndex){if(!(3&tNode.type))return;const tData=tView.data,tRange=tData[bindingIndex+1];if(!isStylingValuePresent(function getTStylingRangeNextDuplicate(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),!(1&~tStylingRange)}(tRange)?findStylingValue(tData,tNode,lView,prop,getTStylingRangeNext(tRange),isClassBased):void 0)){isStylingValuePresent(value)||function getTStylingRangePrevDuplicate(tStylingRange){return ngDevMode&&assertNumber(tStylingRange,"expected number"),!(2&~tStylingRange)}(tRange)&&(value=findStylingValue(tData,null,lView,prop,bindingIndex,isClassBased));!function applyStyling(renderer,isClassBased,rNode,prop,value){if(isClassBased)value?(ngDevMode&&ngDevMode.rendererAddClass++,renderer.addClass(rNode,prop)):(ngDevMode&&ngDevMode.rendererRemoveClass++,renderer.removeClass(rNode,prop));else{let flags=-1===prop.indexOf("-")?void 0:RendererStyleFlags2.DashCase;null==value?(ngDevMode&&ngDevMode.rendererRemoveStyle++,renderer.removeStyle(rNode,prop,flags)):("string"==typeof value&&value.endsWith("!important")&&(value=value.slice(0,-10),flags|=RendererStyleFlags2.Important),ngDevMode&&ngDevMode.rendererSetStyle++,renderer.setStyle(rNode,prop,value,flags))}}(renderer,isClassBased,getNativeByIndex(getSelectedIndex(),lView),prop,value)}}function findStylingValue(tData,tNode,lView,prop,index,isClassBased){const isPrevDirection=null===tNode;let value;for(;index>0;){const rawKey=tData[index],containsStatics=Array.isArray(rawKey),key=containsStatics?rawKey[1]:rawKey,isStylingMap=null===key;let valueAtLViewIndex=lView[index+1];valueAtLViewIndex===NO_CHANGE&&(valueAtLViewIndex=isStylingMap?EMPTY_ARRAY:void 0);let currentValue=isStylingMap?keyValueArrayGet(valueAtLViewIndex,prop):key===prop?valueAtLViewIndex:void 0;if(containsStatics&&!isStylingValuePresent(currentValue)&&(currentValue=keyValueArrayGet(rawKey,prop)),isStylingValuePresent(currentValue)&&(value=currentValue,isPrevDirection))return value;const tRange=tData[index+1];index=isPrevDirection?getTStylingRangePrev(tRange):getTStylingRangeNext(tRange)}if(null!==tNode){let residual=isClassBased?tNode.residualClasses:tNode.residualStyles;null!=residual&&(value=keyValueArrayGet(residual,prop))}return value}function isStylingValuePresent(value){return void 0!==value}function hasStylingInputShadow(tNode,isClassBased){return!!(tNode.flags&(isClassBased?8:16))}function ɵɵclassMapInterpolate1(prefix,v0,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation1(getLView(),prefix,v0,suffix),!0)}function ɵɵclassMapInterpolate2(prefix,v0,i0,v1,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation2(getLView(),prefix,v0,i0,v1,suffix),!0)}function ɵɵclassMapInterpolate3(prefix,v0,i0,v1,i1,v2,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation3(getLView(),prefix,v0,i0,v1,i1,v2,suffix),!0)}function ɵɵclassMapInterpolate4(prefix,v0,i0,v1,i1,v2,i2,v3,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation4(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,suffix),!0)}function ɵɵclassMapInterpolate5(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation5(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix),!0)}function ɵɵclassMapInterpolate6(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation6(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix),!0)}function ɵɵclassMapInterpolate7(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation7(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix),!0)}function ɵɵclassMapInterpolate8(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix){checkStylingMap(keyValueArraySet,classStringParser,interpolation8(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix),!0)}function ɵɵclassMapInterpolateV(values){checkStylingMap(keyValueArraySet,classStringParser,interpolationV(getLView(),values),!0)}function ɵɵcomponentInstance(){const instance=getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];return ngDevMode&&assertDefined(instance,"Expected component instance to be defined"),instance}class LiveCollection{destroy(item){}updateValue(index,value){}swap(index1,index2){const startIdx=Math.min(index1,index2),endIdx=Math.max(index1,index2),endItem=this.detach(endIdx);if(endIdx-startIdx>1){const startItem=this.detach(startIdx);this.attach(startIdx,endItem),this.attach(endIdx,startItem)}else this.attach(startIdx,endItem)}move(prevIndex,newIdx){this.attach(newIdx,this.detach(prevIndex))}}function valuesMatching(liveIdx,liveValue,newIdx,newValue,trackBy){return liveIdx===newIdx&&Object.is(liveValue,newValue)?1:Object.is(trackBy(liveIdx,liveValue),trackBy(newIdx,newValue))?-1:0}function attachPreviouslyDetached(prevCollection,detachedItems,index,key){return!(void 0===detachedItems||!detachedItems.has(key))&&(prevCollection.attach(index,detachedItems.get(key)),detachedItems.delete(key),!0)}function createOrAttach(liveCollection,detachedItems,trackByFn,index,value){if(attachPreviouslyDetached(liveCollection,detachedItems,index,trackByFn(index,value)))liveCollection.updateValue(index,value);else{const newItem=liveCollection.create(index,value);liveCollection.attach(index,newItem)}}function initLiveItemsInTheFuture(liveCollection,start,end,trackByFn){const keys=new Set;for(let i=start;i<=end;i++)keys.add(trackByFn(i,liveCollection.at(i)));return keys}class UniqueValueMultiKeyMap{constructor(){this.kvMap=new Map,this._vMap=void 0}has(key){return this.kvMap.has(key)}delete(key){if(!this.has(key))return!1;const value=this.kvMap.get(key);return void 0!==this._vMap&&this._vMap.has(value)?(this.kvMap.set(key,this._vMap.get(value)),this._vMap.delete(value)):this.kvMap.delete(key),!0}get(key){return this.kvMap.get(key)}set(key,value){if(this.kvMap.has(key)){let prevValue=this.kvMap.get(key);ngDevMode&&assertNotSame(prevValue,value,`Detected a duplicated value ${value} for the key ${key}`),void 0===this._vMap&&(this._vMap=new Map);const vMap=this._vMap;for(;vMap.has(prevValue);)prevValue=vMap.get(prevValue);vMap.set(prevValue,value)}else this.kvMap.set(key,value)}forEach(cb){for(let[key,value]of this.kvMap)if(cb(value,key),void 0!==this._vMap){const vMap=this._vMap;for(;vMap.has(value);)value=vMap.get(value),cb(value,key)}}}function ɵɵconditional(containerIndex,matchingTemplateIndex,value){performanceMarkFeature("NgControlFlow");const hostLView=getLView(),bindingIndex=nextBindingIndex(),lContainer=getLContainer(hostLView,HEADER_OFFSET+containerIndex);if(bindingUpdated(hostLView,bindingIndex,matchingTemplateIndex)){const prevConsumer=setActiveConsumer(null);try{if(removeLViewFromLContainer(lContainer,0),-1!==matchingTemplateIndex){const templateTNode=getExistingTNode(hostLView[TVIEW],HEADER_OFFSET+matchingTemplateIndex),dehydratedView=findMatchingDehydratedView(lContainer,templateTNode.tView.ssrId);addLViewToLContainer(lContainer,createAndRenderEmbeddedLView(hostLView,templateTNode,value,{dehydratedView}),0,shouldAddViewToDom(templateTNode,dehydratedView))}}finally{setActiveConsumer(prevConsumer)}}else{const lView=getLViewFromLContainer(lContainer,0);void 0!==lView&&(lView[CONTEXT]=value)}}class RepeaterContext{constructor(lContainer,$implicit,$index){this.lContainer=lContainer,this.$implicit=$implicit,this.$index=$index}get $count(){return this.lContainer.length-CONTAINER_HEADER_OFFSET}}function ɵɵrepeaterTrackByIndex(index){return index}function ɵɵrepeaterTrackByIdentity(_,value){return value}class RepeaterMetadata{constructor(hasEmptyBlock,trackByFn,liveCollection){this.hasEmptyBlock=hasEmptyBlock,this.trackByFn=trackByFn,this.liveCollection=liveCollection}}function ɵɵrepeaterCreate(index,templateFn,decls,vars,tagName,attrsIndex,trackByFn,trackByUsesComponentInstance,emptyTemplateFn,emptyDecls,emptyVars,emptyTagName,emptyAttrsIndex){performanceMarkFeature("NgControlFlow"),ngDevMode&&assertFunction(trackByFn,`A track expression must be a function, was ${typeof trackByFn} instead.`);const hasEmptyBlock=void 0!==emptyTemplateFn,hostLView=getLView(),boundTrackBy=trackByUsesComponentInstance?trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT]):trackByFn,metadata=new RepeaterMetadata(hasEmptyBlock,boundTrackBy);hostLView[HEADER_OFFSET+index]=metadata,ɵɵtemplate(index+1,templateFn,decls,vars,tagName,attrsIndex),hasEmptyBlock&&(ngDevMode&&assertDefined(emptyDecls,"Missing number of declarations for the empty repeater block."),ngDevMode&&assertDefined(emptyVars,"Missing number of bindings for the empty repeater block."),ɵɵtemplate(index+2,emptyTemplateFn,emptyDecls,emptyVars,emptyTagName,emptyAttrsIndex))}class LiveCollectionLContainerImpl extends LiveCollection{constructor(lContainer,hostLView,templateTNode){super(),this.lContainer=lContainer,this.hostLView=hostLView,this.templateTNode=templateTNode,this.needsIndexUpdate=!1}get length(){return this.lContainer.length-CONTAINER_HEADER_OFFSET}at(index){return this.getLView(index)[CONTEXT].$implicit}attach(index,lView){const dehydratedView=lView[HYDRATION];this.needsIndexUpdate||=index!==this.length,addLViewToLContainer(this.lContainer,lView,index,shouldAddViewToDom(this.templateTNode,dehydratedView))}detach(index){return this.needsIndexUpdate||=index!==this.length-1,function detachExistingView(lContainer,index){const existingLView=detachView(lContainer,index);return ngDevMode&&assertLView(existingLView),existingLView}(this.lContainer,index)}create(index,value){const dehydratedView=findMatchingDehydratedView(this.lContainer,this.templateTNode.tView.ssrId);return createAndRenderEmbeddedLView(this.hostLView,this.templateTNode,new RepeaterContext(this.lContainer,value,index),{dehydratedView})}destroy(lView){destroyLView(lView[TVIEW],lView)}updateValue(index,value){this.getLView(index)[CONTEXT].$implicit=value}reset(){this.needsIndexUpdate=!1}updateIndexes(){if(this.needsIndexUpdate)for(let i=0;i<this.length;i++)this.getLView(i)[CONTEXT].$index=i}getLView(index){return function getExistingLViewFromLContainer(lContainer,index){const existingLView=getLViewFromLContainer(lContainer,index);return ngDevMode&&assertLView(existingLView),existingLView}(this.lContainer,index)}}function ɵɵrepeater(collection){const prevConsumer=setActiveConsumer(null),metadataSlotIdx=getSelectedIndex();try{const hostLView=getLView(),hostTView=hostLView[TVIEW],metadata=hostLView[metadataSlotIdx];if(void 0===metadata.liveCollection){const containerIndex=metadataSlotIdx+1,lContainer=getLContainer(hostLView,containerIndex),itemTemplateTNode=getExistingTNode(hostTView,containerIndex);metadata.liveCollection=new LiveCollectionLContainerImpl(lContainer,hostLView,itemTemplateTNode)}else metadata.liveCollection.reset();const liveCollection=metadata.liveCollection;if(function reconcile(liveCollection,newCollection,trackByFn){let detachedItems,liveKeysInTheFuture,liveStartIdx=0,liveEndIdx=liveCollection.length-1;if(Array.isArray(newCollection)){let newEndIdx=newCollection.length-1;for(;liveStartIdx<=liveEndIdx&&liveStartIdx<=newEndIdx;){const liveStartValue=liveCollection.at(liveStartIdx),newStartValue=newCollection[liveStartIdx],isStartMatching=valuesMatching(liveStartIdx,liveStartValue,liveStartIdx,newStartValue,trackByFn);if(0!==isStartMatching){isStartMatching<0&&liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++;continue}const liveEndValue=liveCollection.at(liveEndIdx),newEndValue=newCollection[newEndIdx],isEndMatching=valuesMatching(liveEndIdx,liveEndValue,newEndIdx,newEndValue,trackByFn);if(0!==isEndMatching){isEndMatching<0&&liveCollection.updateValue(liveEndIdx,newEndValue),liveEndIdx--,newEndIdx--;continue}const liveStartKey=trackByFn(liveStartIdx,liveStartValue),liveEndKey=trackByFn(liveEndIdx,liveEndValue),newStartKey=trackByFn(liveStartIdx,newStartValue);if(Object.is(newStartKey,liveEndKey)){const newEndKey=trackByFn(newEndIdx,newEndValue);Object.is(newEndKey,liveStartKey)?(liveCollection.swap(liveStartIdx,liveEndIdx),liveCollection.updateValue(liveEndIdx,newEndValue),newEndIdx--,liveEndIdx--):liveCollection.move(liveEndIdx,liveStartIdx),liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++}else if(detachedItems??=new UniqueValueMultiKeyMap,liveKeysInTheFuture??=initLiveItemsInTheFuture(liveCollection,liveStartIdx,liveEndIdx,trackByFn),attachPreviouslyDetached(liveCollection,detachedItems,liveStartIdx,newStartKey))liveCollection.updateValue(liveStartIdx,newStartValue),liveStartIdx++,liveEndIdx++;else if(liveKeysInTheFuture.has(newStartKey))detachedItems.set(liveStartKey,liveCollection.detach(liveStartIdx)),liveEndIdx--;else{const newItem=liveCollection.create(liveStartIdx,newCollection[liveStartIdx]);liveCollection.attach(liveStartIdx,newItem),liveStartIdx++,liveEndIdx++}}for(;liveStartIdx<=newEndIdx;)createOrAttach(liveCollection,detachedItems,trackByFn,liveStartIdx,newCollection[liveStartIdx]),liveStartIdx++}else if(null!=newCollection){const newCollectionIterator=newCollection[Symbol.iterator]();let newIterationResult=newCollectionIterator.next();for(;!newIterationResult.done&&liveStartIdx<=liveEndIdx;){const liveValue=liveCollection.at(liveStartIdx),newValue=newIterationResult.value,isStartMatching=valuesMatching(liveStartIdx,liveValue,liveStartIdx,newValue,trackByFn);if(0!==isStartMatching)isStartMatching<0&&liveCollection.updateValue(liveStartIdx,newValue),liveStartIdx++,newIterationResult=newCollectionIterator.next();else{detachedItems??=new UniqueValueMultiKeyMap,liveKeysInTheFuture??=initLiveItemsInTheFuture(liveCollection,liveStartIdx,liveEndIdx,trackByFn);const newKey=trackByFn(liveStartIdx,newValue);if(attachPreviouslyDetached(liveCollection,detachedItems,liveStartIdx,newKey))liveCollection.updateValue(liveStartIdx,newValue),liveStartIdx++,liveEndIdx++,newIterationResult=newCollectionIterator.next();else if(liveKeysInTheFuture.has(newKey)){const liveKey=trackByFn(liveStartIdx,liveValue);detachedItems.set(liveKey,liveCollection.detach(liveStartIdx)),liveEndIdx--}else liveCollection.attach(liveStartIdx,liveCollection.create(liveStartIdx,newValue)),liveStartIdx++,liveEndIdx++,newIterationResult=newCollectionIterator.next()}}for(;!newIterationResult.done;)createOrAttach(liveCollection,detachedItems,trackByFn,liveCollection.length,newIterationResult.value),newIterationResult=newCollectionIterator.next()}for(;liveStartIdx<=liveEndIdx;)liveCollection.destroy(liveCollection.detach(liveEndIdx--));detachedItems?.forEach((item=>{liveCollection.destroy(item)}))}(liveCollection,collection,metadata.trackByFn),liveCollection.updateIndexes(),metadata.hasEmptyBlock){const bindingIndex=nextBindingIndex(),isCollectionEmpty=0===liveCollection.length;if(bindingUpdated(hostLView,bindingIndex,isCollectionEmpty)){const emptyTemplateIndex=metadataSlotIdx+2,lContainerForEmpty=getLContainer(hostLView,emptyTemplateIndex);if(isCollectionEmpty){const emptyTemplateTNode=getExistingTNode(hostTView,emptyTemplateIndex),dehydratedView=findMatchingDehydratedView(lContainerForEmpty,emptyTemplateTNode.tView.ssrId);addLViewToLContainer(lContainerForEmpty,createAndRenderEmbeddedLView(hostLView,emptyTemplateTNode,void 0,{dehydratedView}),0,shouldAddViewToDom(emptyTemplateTNode,dehydratedView))}else removeLViewFromLContainer(lContainerForEmpty,0)}}}finally{setActiveConsumer(prevConsumer)}}function getLContainer(lView,index){const lContainer=lView[index];return ngDevMode&&assertLContainer(lContainer),lContainer}function getExistingTNode(tView,index){const tNode=getTNode(tView,index);return ngDevMode&&assertTNode(tNode),tNode}function ɵɵelementStart(index,name,attrsIndex,localRefsIndex){const lView=getLView(),tView=getTView(),adjustedIndex=HEADER_OFFSET+index;ngDevMode&&assertEqual(getBindingIndex(),tView.bindingStartIndex,"elements should be created before any bindings"),ngDevMode&&assertIndexInRange(lView,adjustedIndex);const renderer=lView[RENDERER],tNode=tView.firstCreatePass?function elementStartFirstCreatePass(index,tView,lView,name,attrsIndex,localRefsIndex){ngDevMode&&assertFirstCreatePass(tView),ngDevMode&&ngDevMode.firstCreatePass++;const tViewConsts=tView.consts,tNode=getOrCreateTNode(tView,index,2,name,getConstant(tViewConsts,attrsIndex));return resolveDirectives(tView,lView,tNode,getConstant(tViewConsts,localRefsIndex)),null!==tNode.attrs&&computeStaticStyling(tNode,tNode.attrs,!1),null!==tNode.mergedAttrs&&computeStaticStyling(tNode,tNode.mergedAttrs,!0),null!==tView.queries&&tView.queries.elementStart(tView,tNode),tNode}(adjustedIndex,tView,lView,name,attrsIndex,localRefsIndex):tView.data[adjustedIndex],native=_locateOrCreateElementNode(tView,lView,tNode,renderer,name,index);lView[adjustedIndex]=native;const hasDirectives=isDirectiveHost(tNode);return ngDevMode&&tView.firstCreatePass&&function validateElementIsKnown(element,lView,tagName,schemas,hasDirectives){if(null!==schemas&&!hasDirectives&&null!==tagName&&("undefined"!=typeof HTMLUnknownElement&&HTMLUnknownElement&&element instanceof HTMLUnknownElement||"undefined"!=typeof customElements&&tagName.indexOf("-")>-1&&!customElements.get(tagName))&&!matchingSchemas(schemas,tagName)){const isHostStandalone=isHostComponentStandalone(lView),schemas=`'${isHostStandalone?"@Component":"@NgModule"}.schemas'`;let message=`'${tagName}' is not a known element${getTemplateLocationDetails(lView)}:\n`;if(message+=`1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone?"included in the '@Component.imports' of this component":"a part of an @NgModule where this component is declared"}.\n`,tagName&&tagName.indexOf("-")>-1?message+=`2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`:message+=`2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`,shouldThrowErrorOnUnknownElement)throw new RuntimeError(304,message);console.error(formatRuntimeError(304,message))}}(native,lView,tNode.value,tView.schemas,hasDirectives),setCurrentTNode(tNode,!0),setupStaticAttributes(renderer,native,tNode),!isDetachedByI18n(tNode)&&wasLastNodeCreated()&&appendChild(tView,lView,native,tNode),0===function getElementDepthCount(){return instructionState.lFrame.elementDepthCount}()&&attachPatchData(native,lView),function increaseElementDepthCount(){instructionState.lFrame.elementDepthCount++}(),hasDirectives&&(createDirectivesInstances(tView,lView,tNode),executeContentQueries(tView,tNode,lView)),null!==localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ɵɵelementStart}function ɵɵelementEnd(){let currentTNode=getCurrentTNode();ngDevMode&&assertDefined(currentTNode,"No parent node to close."),isCurrentTNodeParent()?setCurrentTNodeAsNotParent():(ngDevMode&&assertHasParent(getCurrentTNode()),currentTNode=currentTNode.parent,setCurrentTNode(currentTNode,!1));const tNode=currentTNode;ngDevMode&&assertTNodeType(tNode,3),function isSkipHydrationRootTNode(tNode){return instructionState.skipHydrationRootTNode===tNode}(tNode)&&function leaveSkipHydrationBlock(){instructionState.skipHydrationRootTNode=null}(),function decreaseElementDepthCount(){instructionState.lFrame.elementDepthCount--}();const tView=getTView();return tView.firstCreatePass&&(registerPostOrderHooks(tView,currentTNode),isContentQueryHost(currentTNode)&&tView.queries.elementEnd(currentTNode)),null!=tNode.classesWithoutHost&&function hasClassInput(tNode){return!!(8&tNode.flags)}(tNode)&&setDirectiveInputsWhichShadowsStyling(tView,tNode,getLView(),tNode.classesWithoutHost,!0),null!=tNode.stylesWithoutHost&&function hasStyleInput(tNode){return!!(16&tNode.flags)}(tNode)&&setDirectiveInputsWhichShadowsStyling(tView,tNode,getLView(),tNode.stylesWithoutHost,!1),ɵɵelementEnd}function ɵɵelement(index,name,attrsIndex,localRefsIndex){return ɵɵelementStart(index,name,attrsIndex,localRefsIndex),ɵɵelementEnd(),ɵɵelement}let _locateOrCreateElementNode=(tView,lView,tNode,renderer,name,index)=>(lastNodeWasCreated(!0),createElementNode(renderer,name,getNamespace$1()));function ɵɵelementContainerStart(index,attrsIndex,localRefsIndex){const lView=getLView(),tView=getTView(),adjustedIndex=index+HEADER_OFFSET;ngDevMode&&assertIndexInRange(lView,adjustedIndex),ngDevMode&&assertEqual(getBindingIndex(),tView.bindingStartIndex,"element containers should be created before any bindings");const tNode=tView.firstCreatePass?function elementContainerStartFirstCreatePass(index,tView,lView,attrsIndex,localRefsIndex){ngDevMode&&ngDevMode.firstCreatePass++;const tViewConsts=tView.consts,attrs=getConstant(tViewConsts,attrsIndex),tNode=getOrCreateTNode(tView,index,8,"ng-container",attrs);return null!==attrs&&computeStaticStyling(tNode,attrs,!0),resolveDirectives(tView,lView,tNode,getConstant(tViewConsts,localRefsIndex)),null!==tView.queries&&tView.queries.elementStart(tView,tNode),tNode}(adjustedIndex,tView,lView,attrsIndex,localRefsIndex):tView.data[adjustedIndex];setCurrentTNode(tNode,!0);const comment=_locateOrCreateElementContainerNode(tView,lView,tNode,index);return lView[adjustedIndex]=comment,wasLastNodeCreated()&&appendChild(tView,lView,comment,tNode),attachPatchData(comment,lView),isDirectiveHost(tNode)&&(createDirectivesInstances(tView,lView,tNode),executeContentQueries(tView,tNode,lView)),null!=localRefsIndex&&saveResolvedLocalsInData(lView,tNode),ɵɵelementContainerStart}function ɵɵelementContainerEnd(){let currentTNode=getCurrentTNode();const tView=getTView();return isCurrentTNodeParent()?setCurrentTNodeAsNotParent():(ngDevMode&&assertHasParent(currentTNode),currentTNode=currentTNode.parent,setCurrentTNode(currentTNode,!1)),ngDevMode&&assertTNodeType(currentTNode,8),tView.firstCreatePass&&(registerPostOrderHooks(tView,currentTNode),isContentQueryHost(currentTNode)&&tView.queries.elementEnd(currentTNode)),ɵɵelementContainerEnd}function ɵɵelementContainer(index,attrsIndex,localRefsIndex){return ɵɵelementContainerStart(index,attrsIndex,localRefsIndex),ɵɵelementContainerEnd(),ɵɵelementContainer}let _locateOrCreateElementContainerNode=(tView,lView,tNode,index)=>(lastNodeWasCreated(!0),createCommentNode(lView[RENDERER],ngDevMode?"ng-container":""));function ɵɵgetCurrentView(){return getLView()}function ɵɵhostProperty(propName,value,sanitizer){const lView=getLView(),bindingIndex=nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,value,lView[RENDERER],sanitizer,!0),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵhostProperty}function ɵɵsyntheticHostProperty(propName,value,sanitizer){const lView=getLView(),bindingIndex=nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,value,loadComponentRenderer(getCurrentDirectiveDef(tView.data),tNode,lView),sanitizer,!0),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵsyntheticHostProperty}"undefined"==typeof ngI18nClosureMode&&(_global.ngI18nClosureMode="undefined"!=typeof goog&&"function"==typeof goog.getMsg);const u=void 0;var localeEn=["en",[["a","p"],["AM","PM"],u],[["AM","PM"],u,u],[["S","M","T","W","T","F","S"],["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],["Su","Mo","Tu","We","Th","Fr","Sa"]],u,[["J","F","M","A","M","J","J","A","S","O","N","D"],["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],["January","February","March","April","May","June","July","August","September","October","November","December"]],u,[["B","A"],["BC","AD"],["Before Christ","Anno Domini"]],0,[6,0],["M/d/yy","MMM d, y","MMMM d, y","EEEE, MMMM d, y"],["h:mm a","h:mm:ss a","h:mm:ss a z","h:mm:ss a zzzz"],["{1}, {0}",u,"{1} 'at' {0}",u],[".",",",";","%","+","-","E","×","‰","∞","NaN",":"],["#,##0.###","#,##0%","¤#,##0.00","#E0"],"USD","$","US Dollar",{},"ltr",function plural(val){const i=Math.floor(Math.abs(val)),v=val.toString().replace(/^[^.]*\.?/,"").length;return 1===i&&0===v?1:5}];let LOCALE_DATA={};function findLocaleData(locale){const normalizedLocale=function normalizeLocale(locale){return locale.toLowerCase().replace(/_/g,"-")}(locale);let match=getLocaleData(normalizedLocale);if(match)return match;const parentLocale=normalizedLocale.split("-")[0];if(match=getLocaleData(parentLocale),match)return match;if("en"===parentLocale)return localeEn;throw new RuntimeError(701,ngDevMode&&`Missing locale data for the locale "${locale}".`)}function getLocalePluralCase(locale){return findLocaleData(locale)[LocaleDataIndex.PluralCase]}function getLocaleData(normalizedLocale){return normalizedLocale in LOCALE_DATA||(LOCALE_DATA[normalizedLocale]=_global.ng&&_global.ng.common&&_global.ng.common.locales&&_global.ng.common.locales[normalizedLocale]),LOCALE_DATA[normalizedLocale]}var LocaleDataIndex;!function(LocaleDataIndex){LocaleDataIndex[LocaleDataIndex.LocaleId=0]="LocaleId",LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat=1]="DayPeriodsFormat",LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone=2]="DayPeriodsStandalone",LocaleDataIndex[LocaleDataIndex.DaysFormat=3]="DaysFormat",LocaleDataIndex[LocaleDataIndex.DaysStandalone=4]="DaysStandalone",LocaleDataIndex[LocaleDataIndex.MonthsFormat=5]="MonthsFormat",LocaleDataIndex[LocaleDataIndex.MonthsStandalone=6]="MonthsStandalone",LocaleDataIndex[LocaleDataIndex.Eras=7]="Eras",LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek=8]="FirstDayOfWeek",LocaleDataIndex[LocaleDataIndex.WeekendRange=9]="WeekendRange",LocaleDataIndex[LocaleDataIndex.DateFormat=10]="DateFormat",LocaleDataIndex[LocaleDataIndex.TimeFormat=11]="TimeFormat",LocaleDataIndex[LocaleDataIndex.DateTimeFormat=12]="DateTimeFormat",LocaleDataIndex[LocaleDataIndex.NumberSymbols=13]="NumberSymbols",LocaleDataIndex[LocaleDataIndex.NumberFormats=14]="NumberFormats",LocaleDataIndex[LocaleDataIndex.CurrencyCode=15]="CurrencyCode",LocaleDataIndex[LocaleDataIndex.CurrencySymbol=16]="CurrencySymbol",LocaleDataIndex[LocaleDataIndex.CurrencyName=17]="CurrencyName",LocaleDataIndex[LocaleDataIndex.Currencies=18]="Currencies",LocaleDataIndex[LocaleDataIndex.Directionality=19]="Directionality",LocaleDataIndex[LocaleDataIndex.PluralCase=20]="PluralCase",LocaleDataIndex[LocaleDataIndex.ExtraData=21]="ExtraData"}(LocaleDataIndex||(LocaleDataIndex={}));const pluralMapping=["zero","one","two","few","many"];const ELEMENT_MARKER={marker:"element"},ICU_MARKER={marker:"ICU"};var I18nCreateOpCode;!function(I18nCreateOpCode){I18nCreateOpCode[I18nCreateOpCode.SHIFT=2]="SHIFT",I18nCreateOpCode[I18nCreateOpCode.APPEND_EAGERLY=1]="APPEND_EAGERLY",I18nCreateOpCode[I18nCreateOpCode.COMMENT=2]="COMMENT"}(I18nCreateOpCode||(I18nCreateOpCode={}));let LOCALE_ID$1="en-US";function setLocaleId(localeId){ngDevMode&&assertDefined(localeId,"Expected localeId to be defined"),"string"==typeof localeId&&(LOCALE_ID$1=localeId.toLowerCase().replace(/_/g,"-"))}function getInsertInFrontOfRNodeWithI18n(parentTNode,currentTNode,lView){const tNodeInsertBeforeIndex=currentTNode.insertBeforeIndex,insertBeforeIndex=Array.isArray(tNodeInsertBeforeIndex)?tNodeInsertBeforeIndex[0]:tNodeInsertBeforeIndex;return null===insertBeforeIndex?getInsertInFrontOfRNodeWithNoI18n(parentTNode,0,lView):(ngDevMode&&assertIndexInRange(lView,insertBeforeIndex),unwrapRNode(lView[insertBeforeIndex]))}function processI18nInsertBefore(renderer,childTNode,lView,childRNode,parentRElement){const tNodeInsertBeforeIndex=childTNode.insertBeforeIndex;if(Array.isArray(tNodeInsertBeforeIndex)){ngDevMode&&assertDomNode(childRNode);let i18nParent=childRNode,anchorRNode=null;if(3&childTNode.type||(anchorRNode=i18nParent,i18nParent=parentRElement),null!==i18nParent&&-1===childTNode.componentOffset)for(let i=1;i<tNodeInsertBeforeIndex.length;i++){nativeInsertBefore(renderer,i18nParent,lView[tNodeInsertBeforeIndex[i]],anchorRNode,!1)}}}function addTNodeAndUpdateInsertBeforeIndex(previousTNodes,newTNode){if(ngDevMode&&assertEqual(newTNode.insertBeforeIndex,null,"We expect that insertBeforeIndex is not set"),previousTNodes.push(newTNode),previousTNodes.length>1)for(let i=previousTNodes.length-2;i>=0;i--){const existingTNode=previousTNodes[i];isI18nText(existingTNode)||isNewTNodeCreatedBefore(existingTNode,newTNode)&&null===getInsertBeforeIndex(existingTNode)&&setInsertBeforeIndex(existingTNode,newTNode.index)}}function isI18nText(tNode){return!(64&tNode.type)}function isNewTNodeCreatedBefore(existingTNode,newTNode){return isI18nText(newTNode)||existingTNode.index>newTNode.index}function getInsertBeforeIndex(tNode){const index=tNode.insertBeforeIndex;return Array.isArray(index)?index[0]:index}function setInsertBeforeIndex(tNode,value){const index=tNode.insertBeforeIndex;Array.isArray(index)?index[0]=value:(setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore),tNode.insertBeforeIndex=value)}function getTIcu(tView,index){const value=tView.data[index];if(null===value||"string"==typeof value)return null;!ngDevMode||value.hasOwnProperty("tView")||value.hasOwnProperty("currentCaseLViewIndex")||throwError("We expect to get 'null'|'TIcu'|'TIcuContainer', but got: "+value);const tIcu=value.hasOwnProperty("currentCaseLViewIndex")?value:value.value;return ngDevMode&&assertTIcu(tIcu),tIcu}function createTNodePlaceholder(tView,previousTNodes,index){const tNode=createTNodeAtIndex(tView,index,64,null,null);return addTNodeAndUpdateInsertBeforeIndex(previousTNodes,tNode),tNode}function getCurrentICUCaseIndex(tIcu,lView){const currentCase=lView[tIcu.currentCaseLViewIndex];return null===currentCase?currentCase:currentCase<0?~currentCase:currentCase}function getParentFromIcuCreateOpCode(mergedCode){return mergedCode>>>17}function getRefFromIcuCreateOpCode(mergedCode){return(131070&mergedCode)>>>1}function getInstructionFromIcuCreateOpCode(mergedCode){return 1&mergedCode}let changeMask=0,changeMaskCounter=0;function createNodeWithoutHydration(lView,textOrName,nodeType){const renderer=lView[RENDERER];switch(nodeType){case Node.COMMENT_NODE:return createCommentNode(renderer,textOrName);case Node.TEXT_NODE:return createTextNode(renderer,textOrName);case Node.ELEMENT_NODE:return createElementNode(renderer,textOrName,null)}}let _locateOrCreateNode=(lView,index,textOrName,nodeType)=>(lastNodeWasCreated(!0),createNodeWithoutHydration(lView,textOrName,nodeType));function applyMutableOpCodes(tView,mutableOpCodes,lView,anchorRNode){ngDevMode&&assertDomNode(anchorRNode);const renderer=lView[RENDERER];let rootRNode,rootIdx=null;for(let i=0;i<mutableOpCodes.length;i++){const opCode=mutableOpCodes[i];if("string"==typeof opCode){const textNodeIndex=mutableOpCodes[++i];null===lView[textNodeIndex]&&(ngDevMode&&ngDevMode.rendererCreateTextNode++,ngDevMode&&assertIndexInRange(lView,textNodeIndex),lView[textNodeIndex]=_locateOrCreateNode(lView,textNodeIndex,opCode,Node.TEXT_NODE))}else if("number"==typeof opCode)switch(1&opCode){case 0:const parentIdx=getParentFromIcuCreateOpCode(opCode);let insertInFrontOf,parentRNode;if(null===rootIdx&&(rootIdx=parentIdx,rootRNode=nativeParentNode(renderer,anchorRNode)),parentIdx===rootIdx?(insertInFrontOf=anchorRNode,parentRNode=rootRNode):(insertInFrontOf=null,parentRNode=unwrapRNode(lView[parentIdx])),null!==parentRNode){ngDevMode&&assertDomNode(parentRNode);const refIdx=getRefFromIcuCreateOpCode(opCode);ngDevMode&&assertGreaterThan(refIdx,HEADER_OFFSET,"Missing ref");const child=lView[refIdx];ngDevMode&&assertDomNode(child),nativeInsertBefore(renderer,parentRNode,child,insertInFrontOf,!1);const tIcu=getTIcu(tView,refIdx);if(null!==tIcu&&"object"==typeof tIcu){ngDevMode&&assertTIcu(tIcu);const caseIndex=getCurrentICUCaseIndex(tIcu,lView);null!==caseIndex&&applyMutableOpCodes(tView,tIcu.create[caseIndex],lView,lView[tIcu.anchorIdx])}}break;case 1:const elementNodeIndex=opCode>>>1,attrName=mutableOpCodes[++i],attrValue=mutableOpCodes[++i];setElementAttribute(renderer,getNativeByIndex(elementNodeIndex,lView),null,null,attrName,attrValue,null);break;default:if(ngDevMode)throw new RuntimeError(700,`Unable to determine the type of mutate operation for "${opCode}"`)}else switch(opCode){case ICU_MARKER:const commentValue=mutableOpCodes[++i],commentNodeIndex=mutableOpCodes[++i];if(null===lView[commentNodeIndex]){ngDevMode&&assertEqual(typeof commentValue,"string",`Expected "${commentValue}" to be a comment node value`),ngDevMode&&ngDevMode.rendererCreateComment++,ngDevMode&&assertIndexInExpandoRange(lView,commentNodeIndex);attachPatchData(lView[commentNodeIndex]=_locateOrCreateNode(lView,commentNodeIndex,commentValue,Node.COMMENT_NODE),lView)}break;case ELEMENT_MARKER:const tagName=mutableOpCodes[++i],elementNodeIndex=mutableOpCodes[++i];if(null===lView[elementNodeIndex]){ngDevMode&&assertEqual(typeof tagName,"string",`Expected "${tagName}" to be an element node tag name`),ngDevMode&&ngDevMode.rendererCreateElement++,ngDevMode&&assertIndexInExpandoRange(lView,elementNodeIndex);attachPatchData(lView[elementNodeIndex]=_locateOrCreateNode(lView,elementNodeIndex,tagName,Node.ELEMENT_NODE),lView)}break;default:ngDevMode&&throwError(`Unable to determine the type of mutate operation for "${opCode}"`)}}}function applyUpdateOpCodes(tView,lView,updateOpCodes,bindingsStartIndex,changeMask){for(let i=0;i<updateOpCodes.length;i++){const checkBit=updateOpCodes[i],skipCodes=updateOpCodes[++i];if(checkBit&changeMask){let value="";for(let j=i+1;j<=i+skipCodes;j++){const opCode=updateOpCodes[j];if("string"==typeof opCode)value+=opCode;else if("number"==typeof opCode)if(opCode<0)value+=renderStringify(lView[bindingsStartIndex-opCode]);else{const nodeIndex=opCode>>>2;switch(3&opCode){case 1:const propName=updateOpCodes[++j],sanitizeFn=updateOpCodes[++j],tNodeOrTagName=tView.data[nodeIndex];ngDevMode&&assertDefined(tNodeOrTagName,"Experting TNode or string"),"string"==typeof tNodeOrTagName?setElementAttribute(lView[RENDERER],lView[nodeIndex],null,tNodeOrTagName,propName,value,sanitizeFn):elementPropertyInternal(tView,tNodeOrTagName,lView,propName,value,lView[RENDERER],sanitizeFn,!1);break;case 0:const rText=lView[nodeIndex];null!==rText&&updateTextNode(lView[RENDERER],rText,value);break;case 2:applyIcuSwitchCase(tView,getTIcu(tView,nodeIndex),lView,value);break;case 3:applyIcuUpdateCase(tView,getTIcu(tView,nodeIndex),bindingsStartIndex,lView)}}}}else{const opCode=updateOpCodes[i+1];if(opCode>0&&!(3&~opCode)){const tIcu=getTIcu(tView,opCode>>>2);lView[tIcu.currentCaseLViewIndex]<0&&applyIcuUpdateCase(tView,tIcu,bindingsStartIndex,lView)}}i+=skipCodes}}function applyIcuUpdateCase(tView,tIcu,bindingsStartIndex,lView){ngDevMode&&assertIndexInRange(lView,tIcu.currentCaseLViewIndex);let activeCaseIndex=lView[tIcu.currentCaseLViewIndex];if(null!==activeCaseIndex){let mask=changeMask;activeCaseIndex<0&&(activeCaseIndex=lView[tIcu.currentCaseLViewIndex]=~activeCaseIndex,mask=-1),applyUpdateOpCodes(tView,lView,tIcu.update[activeCaseIndex],bindingsStartIndex,mask)}}function applyIcuSwitchCase(tView,tIcu,lView,value){const caseIndex=function getCaseIndex(icuExpression,bindingValue){let index=icuExpression.cases.indexOf(bindingValue);if(-1===index)switch(icuExpression.type){case 1:{const resolvedCase=function getPluralCase(value,locale){const plural=getLocalePluralCase(locale)(parseInt(value,10)),result=pluralMapping[plural];return void 0!==result?result:"other"}(bindingValue,function getLocaleId(){return LOCALE_ID$1}());index=icuExpression.cases.indexOf(resolvedCase),-1===index&&"other"!==resolvedCase&&(index=icuExpression.cases.indexOf("other"));break}case 0:index=icuExpression.cases.indexOf("other")}return-1===index?null:index}(tIcu,value);if(getCurrentICUCaseIndex(tIcu,lView)!==caseIndex&&(applyIcuSwitchCaseRemove(tView,tIcu,lView),lView[tIcu.currentCaseLViewIndex]=null===caseIndex?null:~caseIndex,null!==caseIndex)){const anchorRNode=lView[tIcu.anchorIdx];anchorRNode&&(ngDevMode&&assertDomNode(anchorRNode),applyMutableOpCodes(tView,tIcu.create[caseIndex],lView,anchorRNode))}}function applyIcuSwitchCaseRemove(tView,tIcu,lView){let activeCaseIndex=getCurrentICUCaseIndex(tIcu,lView);if(null!==activeCaseIndex){const removeCodes=tIcu.remove[activeCaseIndex];for(let i=0;i<removeCodes.length;i++){const nodeOrIcuIndex=removeCodes[i];if(nodeOrIcuIndex>0){const rNode=getNativeByIndex(nodeOrIcuIndex,lView);null!==rNode&&nativeRemoveNode(lView[RENDERER],rNode)}else applyIcuSwitchCaseRemove(tView,getTIcu(tView,~nodeOrIcuIndex),lView)}}}function loadIcuContainerVisitor(){const _stack=[];let _lView,_removes,_index=-1;function enterIcu(tIcu,lView){_index=0;const currentCase=getCurrentICUCaseIndex(tIcu,lView);null!==currentCase?(ngDevMode&&assertNumberInRange(currentCase,0,tIcu.cases.length-1),_removes=tIcu.remove[currentCase]):_removes=EMPTY_ARRAY}function icuContainerIteratorNext(){if(_index<_removes.length){const removeOpCode=_removes[_index++];if(ngDevMode&&assertNumber(removeOpCode,"Expecting OpCode number"),removeOpCode>0){const rNode=_lView[removeOpCode];return ngDevMode&&assertDomNode(rNode),rNode}{_stack.push(_index,_removes);const tIcuIndex=~removeOpCode,tIcu=_lView[TVIEW].data[tIcuIndex];return ngDevMode&&assertTIcu(tIcu),enterIcu(tIcu,_lView),icuContainerIteratorNext()}}return 0===_stack.length?null:(_removes=_stack.pop(),_index=_stack.pop(),icuContainerIteratorNext())}return function icuContainerIteratorStart(tIcuContainerNode,lView){for(_lView=lView;_stack.length;)_stack.pop();return ngDevMode&&assertTNodeForLView(tIcuContainerNode,lView),enterIcu(tIcuContainerNode.value,lView),icuContainerIteratorNext}}function i18nCreateOpCodesToString(opcodes){const createOpCodes=opcodes||(Array.isArray(this)?this:[]);let lines=[];for(let i=0;i<createOpCodes.length;i++){const opCode=createOpCodes[i++],text=createOpCodes[i],isComment=(opCode&I18nCreateOpCode.COMMENT)===I18nCreateOpCode.COMMENT,appendNow=(opCode&I18nCreateOpCode.APPEND_EAGERLY)===I18nCreateOpCode.APPEND_EAGERLY,index=opCode>>>I18nCreateOpCode.SHIFT;lines.push(`lView[${index}] = document.${isComment?"createComment":"createText"}(${JSON.stringify(text)});`),appendNow&&lines.push(`parent.appendChild(lView[${index}]);`)}return lines}function i18nUpdateOpCodesToString(opcodes){const parser=new OpCodeParser(opcodes||(Array.isArray(this)?this:[]));let lines=[];function consumeOpCode(value){const ref=value>>>2,opCode=3&value;switch(opCode){case 0:return`(lView[${ref}] as Text).textContent = $$$`;case 1:const attrName=parser.consumeString(),sanitizationFn=parser.consumeFunction();return`(lView[${ref}] as Element).setAttribute('${attrName}', ${sanitizationFn?`(${sanitizationFn})($$$)`:"$$$"})`;case 2:return`icuSwitchCase(${ref}, $$$)`;case 3:return`icuUpdateCase(${ref})`}throw new Error("unexpected OpCode")}for(;parser.hasMore();){let mask=parser.consumeNumber(),size=parser.consumeNumber();const end=parser.i+size,statements=[];let statement="";for(;parser.i<end;){let value=parser.consumeNumberOrString();if("string"==typeof value)statement+=value;else if(value<0)statement+="${lView[i"+value+"]}";else{const opCodeText=consumeOpCode(value);statements.push(opCodeText.replace("$$$","`"+statement+"`")+";"),statement=""}}lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(" ")} }`)}return lines}function icuCreateOpCodesToString(opcodes){const parser=new OpCodeParser(opcodes||(Array.isArray(this)?this:[]));let lines=[];function consumeOpCode(opCode){const parent=getParentFromIcuCreateOpCode(opCode),ref=getRefFromIcuCreateOpCode(opCode);switch(getInstructionFromIcuCreateOpCode(opCode)){case 0:return`(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;case 1:return`(lView[${ref}] as Element).setAttribute("${parser.consumeString()}", "${parser.consumeString()}")`}throw new Error("Unexpected OpCode: "+getInstructionFromIcuCreateOpCode(opCode))}let lastRef=-1;for(;parser.hasMore();){let value=parser.consumeNumberStringOrMarker();if(value===ICU_MARKER){const text=parser.consumeString();lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createComment("${text}")`)}else if(value===ELEMENT_MARKER){const text=parser.consumeString();lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createElement("${text}")`)}else if("string"==typeof value)lastRef=parser.consumeNumber(),lines.push(`lView[${lastRef}] = document.createTextNode("${value}")`);else{if("number"!=typeof value)throw new Error("Unexpected value");{const line=consumeOpCode(value);line&&lines.push(line)}}}return lines}function i18nRemoveOpCodesToString(opcodes){const removeCodes=opcodes||(Array.isArray(this)?this:[]);let lines=[];for(let i=0;i<removeCodes.length;i++){const nodeOrIcuIndex=removeCodes[i];nodeOrIcuIndex>0?lines.push(`remove(lView[${nodeOrIcuIndex}])`):lines.push(`removeNestedICU(${~nodeOrIcuIndex})`)}return lines}class OpCodeParser{constructor(codes){this.i=0,this.codes=codes}hasMore(){return this.i<this.codes.length}consumeNumber(){let value=this.codes[this.i++];return assertNumber(value,"expecting number in OpCode"),value}consumeString(){let value=this.codes[this.i++];return assertString(value,"expecting string in OpCode"),value}consumeFunction(){let value=this.codes[this.i++];if(null===value||"function"==typeof value)return value;throw new Error("expecting function in OpCode")}consumeNumberOrString(){let value=this.codes[this.i++];return"string"==typeof value||assertNumber(value,"expecting number or string in OpCode"),value}consumeNumberStringOrMarker(){let value=this.codes[this.i++];return"string"==typeof value||"number"==typeof value||value==ICU_MARKER||value==ELEMENT_MARKER||assertNumber(value,"expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode"),value}}const BINDING_REGEXP=/�(\d+):?\d*�/gi,ICU_REGEXP=/({\s*�\d+:?\d*�\s*,\s*\S{6}\s*,[\s\S]*})/gi,NESTED_ICU=/�(\d+)�/,ICU_BLOCK_REGEXP=/^\s*(�\d+:?\d*�)\s*,\s*(select|plural)\s*,/,MARKER="�",SUBTEMPLATE_REGEXP=/�\/?\*(\d+:\d+)�/gi,PH_REGEXP=/�(\/?[#*]\d+):?\d*�/gi,NGSP_UNICODE_REGEXP=/\uE500/g;function attachDebugGetter(obj,debugGetter){if(!ngDevMode)throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");Object.defineProperty(obj,"debug",{get:debugGetter,enumerable:!1})}function i18nStartFirstCreatePass(tView,parentTNodeIndex,lView,index,message,subTemplateIndex){const rootTNode=getCurrentParentTNode(),createOpCodes=[],updateOpCodes=[],existingTNodeStack=[[]],astStack=[[]];ngDevMode&&(attachDebugGetter(createOpCodes,i18nCreateOpCodesToString),attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString)),message=function getTranslationForTemplate(message,subTemplateIndex){if(function isRootTemplateMessage(subTemplateIndex){return-1===subTemplateIndex}(subTemplateIndex))return removeInnerTemplateTranslation(message);{const start=message.indexOf(`:${subTemplateIndex}${MARKER}`)+2+subTemplateIndex.toString().length,end=message.search(new RegExp(`${MARKER}\\/\\*\\d+:${subTemplateIndex}${MARKER}`));return removeInnerTemplateTranslation(message.substring(start,end))}}(message,subTemplateIndex);const msgParts=function replaceNgsp(value){return value.replace(NGSP_UNICODE_REGEXP," ")}(message).split(PH_REGEXP);for(let i=0;i<msgParts.length;i++){let value=msgParts[i];if(1&i){const isClosing=47===value.charCodeAt(0),type=value.charCodeAt(isClosing?1:0);ngDevMode&&assertOneOf(type,42,35);const index=HEADER_OFFSET+Number.parseInt(value.substring(isClosing?2:1));if(isClosing)existingTNodeStack.shift(),astStack.shift(),setCurrentTNode(getCurrentParentTNode(),!1);else{const tNode=createTNodePlaceholder(tView,existingTNodeStack[0],index);existingTNodeStack.unshift([]),setCurrentTNode(tNode,!0);const placeholderNode={kind:2,index,children:[],type:35===type?0:1};astStack[0].push(placeholderNode),astStack.unshift(placeholderNode.children)}}else{const parts=i18nParseTextIntoPartsAndICU(value);for(let j=0;j<parts.length;j++){let part=parts[j];if(1&j){const icuExpression=part;if("object"!=typeof icuExpression)throw new Error(`Unable to parse ICU expression in "${message}" message.`);const icuNodeIndex=createTNodeAndAddOpCode(tView,rootTNode,existingTNodeStack[0],lView,createOpCodes,ngDevMode?`ICU ${index}:${icuExpression.mainBinding}`:"",!0).index;ngDevMode&&assertGreaterThanOrEqual(icuNodeIndex,HEADER_OFFSET,"Index must be in absolute LView offset"),icuStart(astStack[0],tView,lView,updateOpCodes,parentTNodeIndex,icuExpression,icuNodeIndex)}else{const text=part;ngDevMode&&assertString(text,"Parsed ICU part should be string"),""!==text&&i18nStartFirstCreatePassProcessTextNode(astStack[0],tView,rootTNode,existingTNodeStack[0],createOpCodes,updateOpCodes,lView,text)}}}}tView.data[index]={create:createOpCodes,update:updateOpCodes,ast:astStack[0]}}function createTNodeAndAddOpCode(tView,rootTNode,existingTNodes,lView,createOpCodes,text,isICU){const i18nNodeIdx=allocExpando(tView,lView,1,null);let opCode=i18nNodeIdx<<I18nCreateOpCode.SHIFT,parentTNode=getCurrentParentTNode();rootTNode===parentTNode&&(parentTNode=null),null===parentTNode&&(opCode|=I18nCreateOpCode.APPEND_EAGERLY),isICU&&(opCode|=I18nCreateOpCode.COMMENT,function ensureIcuContainerVisitorLoaded(loader){void 0===_icuContainerIterate&&(_icuContainerIterate=loader())}(loadIcuContainerVisitor)),createOpCodes.push(opCode,null===text?"":text);const tNode=createTNodeAtIndex(tView,i18nNodeIdx,isICU?32:1,null===text?ngDevMode?"{{?}}":"":text,null);addTNodeAndUpdateInsertBeforeIndex(existingTNodes,tNode);const tNodeIdx=tNode.index;return setCurrentTNode(tNode,!1),null!==parentTNode&&rootTNode!==parentTNode&&function setTNodeInsertBeforeIndex(tNode,index){ngDevMode&&assertTNode(tNode);let insertBeforeIndex=tNode.insertBeforeIndex;null===insertBeforeIndex?(setI18nHandling(getInsertInFrontOfRNodeWithI18n,processI18nInsertBefore),insertBeforeIndex=tNode.insertBeforeIndex=[null,index]):(assertEqual(Array.isArray(insertBeforeIndex),!0,"Expecting array here"),insertBeforeIndex.push(index))}(parentTNode,tNodeIdx),tNode}function i18nStartFirstCreatePassProcessTextNode(ast,tView,rootTNode,existingTNodes,createOpCodes,updateOpCodes,lView,text){const hasBinding=text.match(BINDING_REGEXP),index=createTNodeAndAddOpCode(tView,rootTNode,existingTNodes,lView,createOpCodes,hasBinding?null:text,!1).index;hasBinding&&generateBindingUpdateOpCodes(updateOpCodes,text,index,null,0,null),ast.push({kind:0,index})}function generateBindingUpdateOpCodes(updateOpCodes,str,destinationNode,attrName,bindingStart,sanitizeFn){ngDevMode&&assertGreaterThanOrEqual(destinationNode,HEADER_OFFSET,"Index must be in absolute LView offset");const maskIndex=updateOpCodes.length,sizeIndex=maskIndex+1;updateOpCodes.push(null,null);const startIndex=maskIndex+2;ngDevMode&&attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString);const textParts=str.split(BINDING_REGEXP);let mask=0;for(let j=0;j<textParts.length;j++){const textValue=textParts[j];if(1&j){const bindingIndex=bindingStart+parseInt(textValue,10);updateOpCodes.push(-1-bindingIndex),mask|=toMaskBit(bindingIndex)}else""!==textValue&&updateOpCodes.push(textValue)}return updateOpCodes.push(destinationNode<<2|(attrName?1:0)),attrName&&updateOpCodes.push(attrName,sanitizeFn),updateOpCodes[maskIndex]=mask,updateOpCodes[sizeIndex]=updateOpCodes.length-startIndex,mask}function countBindings(opCodes){let count=0;for(let i=0;i<opCodes.length;i++){const opCode=opCodes[i];"number"==typeof opCode&&opCode<0&&count++}return count}function toMaskBit(bindingIndex){return 1<<Math.min(bindingIndex,31)}function removeInnerTemplateTranslation(message){let match,tagMatched,res="",index=0,inTemplate=!1;for(;null!==(match=SUBTEMPLATE_REGEXP.exec(message));)inTemplate?match[0]===`${MARKER}/*${tagMatched}${MARKER}`&&(index=match.index,inTemplate=!1):(res+=message.substring(index,match.index+match[0].length),tagMatched=match[1],inTemplate=!0);return ngDevMode&&assertEqual(inTemplate,!1,`Tag mismatch: unable to find the end of the sub-template in the translation "${message}"`),res+=message.slice(index),res}function icuStart(ast,tView,lView,updateOpCodes,parentIdx,icuExpression,anchorIdx){ngDevMode&&assertDefined(icuExpression,"ICU expression must be defined");let bindingMask=0;const tIcu={type:icuExpression.type,currentCaseLViewIndex:allocExpando(tView,lView,1,null),anchorIdx,cases:[],create:[],remove:[],update:[]};!function addUpdateIcuSwitch(update,icuExpression,index){update.push(toMaskBit(icuExpression.mainBinding),2,-1-icuExpression.mainBinding,index<<2|2)}(updateOpCodes,icuExpression,anchorIdx),function setTIcu(tView,index,tIcu){const tNode=tView.data[index];ngDevMode&&assertEqual(null===tNode||tNode.hasOwnProperty("tView"),!0,"We expect to get 'null'|'TIcuContainer'"),null===tNode?tView.data[index]=tIcu:(ngDevMode&&assertTNodeType(tNode,32),tNode.value=tIcu)}(tView,anchorIdx,tIcu);const values=icuExpression.values,cases=[];for(let i=0;i<values.length;i++){const valueArr=values[i],nestedIcus=[];for(let j=0;j<valueArr.length;j++){const value=valueArr[j];if("string"!=typeof value){const icuIndex=nestedIcus.push(value)-1;valueArr[j]=`\x3c!--�${icuIndex}�--\x3e`}}const caseAst=[];cases.push(caseAst),bindingMask=parseIcuCase(caseAst,tView,tIcu,lView,updateOpCodes,parentIdx,icuExpression.cases[i],valueArr.join(""),nestedIcus)|bindingMask}bindingMask&&function addUpdateIcuUpdate(update,bindingMask,index){update.push(bindingMask,1,index<<2|3)}(updateOpCodes,bindingMask,anchorIdx),ast.push({kind:3,index:anchorIdx,cases,currentCaseLViewIndex:tIcu.currentCaseLViewIndex})}function parseICUBlock(pattern){const cases=[],values=[];let icuType=1,mainBinding=0;const parts=i18nParseTextIntoPartsAndICU(pattern=pattern.replace(ICU_BLOCK_REGEXP,(function(str,binding,type){return icuType="select"===type?0:1,mainBinding=parseInt(binding.slice(1),10),""})));for(let pos=0;pos<parts.length;){let key=parts[pos++].trim();1===icuType&&(key=key.replace(/\s*(?:=)?(\w+)\s*/,"$1")),key.length&&cases.push(key);const blocks=i18nParseTextIntoPartsAndICU(parts[pos++]);cases.length>values.length&&values.push(blocks)}return{type:icuType,mainBinding,cases,values}}function i18nParseTextIntoPartsAndICU(pattern){if(!pattern)return[];let prevPos=0;const braceStack=[],results=[],braces=/[{}]/g;let match;for(braces.lastIndex=0;match=braces.exec(pattern);){const pos=match.index;if("}"==match[0]){if(braceStack.pop(),0==braceStack.length){const block=pattern.substring(prevPos,pos);ICU_BLOCK_REGEXP.test(block)?results.push(parseICUBlock(block)):results.push(block),prevPos=pos+1}}else{if(0==braceStack.length){const substring=pattern.substring(prevPos,pos);results.push(substring),prevPos=pos+1}braceStack.push("{")}}const substring=pattern.substring(prevPos);return results.push(substring),results}function parseIcuCase(ast,tView,tIcu,lView,updateOpCodes,parentIdx,caseName,unsafeCaseHtml,nestedIcus){const create=[],remove=[],update=[];ngDevMode&&(attachDebugGetter(create,icuCreateOpCodesToString),attachDebugGetter(remove,i18nRemoveOpCodesToString),attachDebugGetter(update,i18nUpdateOpCodesToString)),tIcu.cases.push(caseName),tIcu.create.push(create),tIcu.remove.push(remove),tIcu.update.push(update);const inertBodyElement=getInertBodyHelper(getDocument()).getInertBodyElement(unsafeCaseHtml);ngDevMode&&assertDefined(inertBodyElement,"Unable to generate inert body element");const inertRootNode=getTemplateContent(inertBodyElement)||inertBodyElement;return inertRootNode?walkIcuTree(ast,tView,tIcu,lView,updateOpCodes,create,remove,update,inertRootNode,parentIdx,nestedIcus,0):0}function walkIcuTree(ast,tView,tIcu,lView,sharedUpdateOpCodes,create,remove,update,parentNode,parentIdx,nestedIcus,depth){let bindingMask=0,currentNode=parentNode.firstChild;for(;currentNode;){const newIndex=allocExpando(tView,lView,1,null);switch(currentNode.nodeType){case Node.ELEMENT_NODE:const element=currentNode,tagName=element.tagName.toLowerCase();if(VALID_ELEMENTS.hasOwnProperty(tagName)){addCreateNodeAndAppend(create,ELEMENT_MARKER,tagName,parentIdx,newIndex),tView.data[newIndex]=tagName;const elAttrs=element.attributes;for(let i=0;i<elAttrs.length;i++){const attr=elAttrs.item(i),lowerAttrName=attr.name.toLowerCase();!!attr.value.match(BINDING_REGEXP)?VALID_ATTRS.hasOwnProperty(lowerAttrName)?URI_ATTRS[lowerAttrName]?generateBindingUpdateOpCodes(update,attr.value,newIndex,attr.name,0,_sanitizeUrl):generateBindingUpdateOpCodes(update,attr.value,newIndex,attr.name,0,null):ngDevMode&&console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`):addCreateAttribute(create,newIndex,attr)}const elementNode={kind:1,index:newIndex,children:[]};ast.push(elementNode),bindingMask=walkIcuTree(elementNode.children,tView,tIcu,lView,sharedUpdateOpCodes,create,remove,update,currentNode,newIndex,nestedIcus,depth+1)|bindingMask,addRemoveNode(remove,newIndex,depth)}break;case Node.TEXT_NODE:const value=currentNode.textContent||"",hasBinding=value.match(BINDING_REGEXP);addCreateNodeAndAppend(create,null,hasBinding?"":value,parentIdx,newIndex),addRemoveNode(remove,newIndex,depth),hasBinding&&(bindingMask=generateBindingUpdateOpCodes(update,value,newIndex,null,0,null)|bindingMask),ast.push({kind:0,index:newIndex});break;case Node.COMMENT_NODE:const isNestedIcu=NESTED_ICU.exec(currentNode.textContent||"");if(isNestedIcu){const nestedIcuIndex=parseInt(isNestedIcu[1],10),icuExpression=nestedIcus[nestedIcuIndex];addCreateNodeAndAppend(create,ICU_MARKER,ngDevMode?`nested ICU ${nestedIcuIndex}`:"",parentIdx,newIndex),icuStart(ast,tView,lView,sharedUpdateOpCodes,parentIdx,icuExpression,newIndex),addRemoveNestedIcu(remove,newIndex,depth)}}currentNode=currentNode.nextSibling}return bindingMask}function addRemoveNode(remove,index,depth){0===depth&&remove.push(index)}function addRemoveNestedIcu(remove,index,depth){0===depth&&(remove.push(~index),remove.push(index))}function addCreateNodeAndAppend(create,marker,text,appendToParentIdx,createAtIdx){null!==marker&&create.push(marker),create.push(text,createAtIdx,function icuCreateOpCode(opCode,parentIdx,refIdx){return ngDevMode&&assertGreaterThanOrEqual(parentIdx,0,"Missing parent index"),ngDevMode&&assertGreaterThan(refIdx,0,"Missing ref index"),opCode|parentIdx<<17|refIdx<<1}(0,appendToParentIdx,createAtIdx))}function addCreateAttribute(create,newIndex,attr){create.push(newIndex<<1|1,attr.name,attr.value)}const ROOT_TEMPLATE_ID=0,PP_MULTI_VALUE_PLACEHOLDERS_REGEXP=/\[(�.+?�?)\]/,PP_PLACEHOLDERS_REGEXP=/\[(�.+?�?)\]|(�\/?\*\d+:\d+�)/g,PP_ICU_VARS_REGEXP=/({\s*)(VAR_(PLURAL|SELECT)(_\d+)?)(\s*,)/g,PP_ICU_PLACEHOLDERS_REGEXP=/{([A-Z0-9_]+)}/g,PP_ICUS_REGEXP=/�I18N_EXP_(ICU(_\d+)?)�/g,PP_CLOSE_TEMPLATE_REGEXP=/\/\*/,PP_TEMPLATE_ID_REGEXP=/\d+\:(\d+)/;function ɵɵi18nStart(index,messageIndex,subTemplateIndex=-1){const tView=getTView(),lView=getLView(),adjustedIndex=HEADER_OFFSET+index;ngDevMode&&assertDefined(tView,"tView should be defined");const message=getConstant(tView.consts,messageIndex),parentTNode=getCurrentParentTNode();if(tView.firstCreatePass&&i18nStartFirstCreatePass(tView,null===parentTNode?0:parentTNode.index,lView,adjustedIndex,message,subTemplateIndex),2===tView.type){lView[DECLARATION_COMPONENT_VIEW][FLAGS]|=32}else lView[FLAGS]|=32;const tI18n=tView.data[adjustedIndex],parentRNode=getClosestRElement(tView,parentTNode===lView[T_HOST]?null:parentTNode,lView),insertInFrontOf=parentTNode&&8&parentTNode.type?lView[parentTNode.index]:null;!function applyCreateOpCodes(lView,createOpCodes,parentRNode,insertInFrontOf){const renderer=lView[RENDERER];for(let i=0;i<createOpCodes.length;i++){const opCode=createOpCodes[i++],text=createOpCodes[i],isComment=(opCode&I18nCreateOpCode.COMMENT)===I18nCreateOpCode.COMMENT,appendNow=(opCode&I18nCreateOpCode.APPEND_EAGERLY)===I18nCreateOpCode.APPEND_EAGERLY,index=opCode>>>I18nCreateOpCode.SHIFT;let rNode=lView[index],lastNodeWasCreated=!1;null===rNode&&(rNode=lView[index]=_locateOrCreateNode(lView,index,text,isComment?Node.COMMENT_NODE:Node.TEXT_NODE),lastNodeWasCreated=wasLastNodeCreated()),appendNow&&null!==parentRNode&&lastNodeWasCreated&&nativeInsertBefore(renderer,parentRNode,rNode,insertInFrontOf,!1)}}(lView,tI18n.create,parentRNode,insertInFrontOf),setInI18nBlock(!0)}function ɵɵi18nEnd(){setInI18nBlock(!1)}function ɵɵi18n(index,messageIndex,subTemplateIndex){ɵɵi18nStart(index,messageIndex,subTemplateIndex),ɵɵi18nEnd()}function ɵɵi18nAttributes(index,attrsIndex){const tView=getTView();ngDevMode&&assertDefined(tView,"tView should be defined");const attrs=getConstant(tView.consts,attrsIndex);!function i18nAttributesFirstPass(tView,index,values){const previousElementIndex=getCurrentTNode().index,updateOpCodes=[];if(ngDevMode&&attachDebugGetter(updateOpCodes,i18nUpdateOpCodesToString),tView.firstCreatePass&&null===tView.data[index]){for(let i=0;i<values.length;i+=2){const attrName=values[i],message=values[i+1];if(""!==message){if(ICU_REGEXP.test(message))throw new Error(`ICU expressions are not supported in attributes. Message: "${message}".`);generateBindingUpdateOpCodes(updateOpCodes,message,previousElementIndex,attrName,countBindings(updateOpCodes),null)}}tView.data[index]=updateOpCodes}}(tView,index+HEADER_OFFSET,attrs)}function ɵɵi18nExp(value){return function setMaskBit(hasChange){hasChange&&(changeMask|=1<<Math.min(changeMaskCounter,31)),changeMaskCounter++}(bindingUpdated(getLView(),nextBindingIndex(),value)),ɵɵi18nExp}function ɵɵi18nApply(index){!function applyI18n(tView,lView,index){if(changeMaskCounter>0){ngDevMode&&assertDefined(tView,"tView should be defined");const tI18n=tView.data[index];applyUpdateOpCodes(tView,lView,Array.isArray(tI18n)?tI18n:tI18n.update,getBindingIndex()-changeMaskCounter-1,changeMask)}changeMask=0,changeMaskCounter=0}(getTView(),getLView(),index+HEADER_OFFSET)}function ɵɵi18nPostprocess(message,replacements={}){return function i18nPostprocess(message,replacements={}){let result=message;if(PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)){const matches={},templateIdsStack=[ROOT_TEMPLATE_ID];result=result.replace(PP_PLACEHOLDERS_REGEXP,((m,phs,tmpl)=>{const content=phs||tmpl,placeholders=matches[content]||[];if(placeholders.length||(content.split("|").forEach((placeholder=>{const match=placeholder.match(PP_TEMPLATE_ID_REGEXP),templateId=match?parseInt(match[1],10):ROOT_TEMPLATE_ID,isCloseTemplateTag=PP_CLOSE_TEMPLATE_REGEXP.test(placeholder);placeholders.push([templateId,isCloseTemplateTag,placeholder])})),matches[content]=placeholders),!placeholders.length)throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);const currentTemplateId=templateIdsStack[templateIdsStack.length-1];let idx=0;for(let i=0;i<placeholders.length;i++)if(placeholders[i][0]===currentTemplateId){idx=i;break}const[templateId,isCloseTemplateTag,placeholder]=placeholders[idx];return isCloseTemplateTag?templateIdsStack.pop():currentTemplateId!==templateId&&templateIdsStack.push(templateId),placeholders.splice(idx,1),placeholder}))}return Object.keys(replacements).length?(result=result.replace(PP_ICU_VARS_REGEXP,((match,start,key,_type,_idx,end)=>replacements.hasOwnProperty(key)?`${start}${replacements[key]}${end}`:match)),result=result.replace(PP_ICU_PLACEHOLDERS_REGEXP,((match,key)=>replacements.hasOwnProperty(key)?replacements[key]:match)),result=result.replace(PP_ICUS_REGEXP,((match,key)=>{if(replacements.hasOwnProperty(key)){const list=replacements[key];if(!list.length)throw new Error(`i18n postprocess: unmatched ICU - ${match} with key: ${key}`);return list.shift()}return match})),result):result}(message,replacements)}function ɵɵlistener(eventName,listenerFn,useCapture,eventTargetResolver){const lView=getLView(),tView=getTView(),tNode=getCurrentTNode();return listenerInternal(tView,lView,lView[RENDERER],tNode,eventName,listenerFn,eventTargetResolver),ɵɵlistener}function ɵɵsyntheticHostListener(eventName,listenerFn){const tNode=getCurrentTNode(),lView=getLView(),tView=getTView();return listenerInternal(tView,lView,loadComponentRenderer(getCurrentDirectiveDef(tView.data),tNode,lView),tNode,eventName,listenerFn),ɵɵsyntheticHostListener}function listenerInternal(tView,lView,renderer,tNode,eventName,listenerFn,eventTargetResolver){const isTNodeDirectiveHost=isDirectiveHost(tNode),tCleanup=tView.firstCreatePass&&getOrCreateTViewCleanup(tView),context=lView[CONTEXT],lCleanup=getOrCreateLViewCleanup(lView);ngDevMode&&assertTNodeType(tNode,15);let processOutputs=!0;if(3&tNode.type||eventTargetResolver){const native=getNativeByTNode(tNode,lView),target=eventTargetResolver?eventTargetResolver(native):native,lCleanupIndex=lCleanup.length,idxOrTargetGetter=eventTargetResolver?_lView=>eventTargetResolver(unwrapRNode(_lView[tNode.index])):tNode.index;let existingListener=null;if(!eventTargetResolver&&isTNodeDirectiveHost&&(existingListener=function findExistingListener(tView,lView,eventName,tNodeIdx){const tCleanup=tView.cleanup;if(null!=tCleanup)for(let i=0;i<tCleanup.length-1;i+=2){const cleanupEventName=tCleanup[i];if(cleanupEventName===eventName&&tCleanup[i+1]===tNodeIdx){const lCleanup=lView[CLEANUP],listenerIdxInLCleanup=tCleanup[i+2];return lCleanup.length>listenerIdxInLCleanup?lCleanup[listenerIdxInLCleanup]:null}"string"==typeof cleanupEventName&&(i+=2)}return null}(tView,lView,eventName,tNode.index)),null!==existingListener){(existingListener.__ngLastListenerFn__||existingListener).__ngNextListenerFn__=listenerFn,existingListener.__ngLastListenerFn__=listenerFn,processOutputs=!1}else{listenerFn=wrapListener(tNode,lView,context,listenerFn,!1);const cleanupFn=renderer.listen(target,eventName,listenerFn);ngDevMode&&ngDevMode.rendererAddEventListener++,lCleanup.push(listenerFn,cleanupFn),tCleanup&&tCleanup.push(eventName,idxOrTargetGetter,lCleanupIndex,lCleanupIndex+1)}}else listenerFn=wrapListener(tNode,lView,context,listenerFn,!1);const outputs=tNode.outputs;let props;if(processOutputs&&null!==outputs&&(props=outputs[eventName])){const propsLength=props.length;if(propsLength)for(let i=0;i<propsLength;i+=2){const index=props[i];ngDevMode&&assertIndexInRange(lView,index);const minifiedName=props[i+1],directiveInstance=lView[index],output=directiveInstance[minifiedName];if(ngDevMode&&(null==(value=output)||"function"!=typeof value.subscribe))throw new Error(`@Output ${minifiedName} not initialized in '${directiveInstance.constructor.name}'.`);const subscription=output.subscribe(listenerFn),idx=lCleanup.length;lCleanup.push(listenerFn,subscription),tCleanup&&tCleanup.push(eventName,tNode.index,idx,-(idx+1))}}var value}function executeListenerWithErrorHandling(lView,context,listenerFn,e){const prevConsumer=setActiveConsumer(null);try{return profiler(6,context,listenerFn),!1!==listenerFn(e)}catch(error){return handleError(lView,error),!1}finally{profiler(7,context,listenerFn),setActiveConsumer(prevConsumer)}}function wrapListener(tNode,lView,context,listenerFn,wrapWithPreventDefault){return function wrapListenerIn_markDirtyAndPreventDefault(e){if(e===Function)return listenerFn;markViewDirty(tNode.componentOffset>-1?getComponentLViewByIndex(tNode.index,lView):lView);let result=executeListenerWithErrorHandling(lView,context,listenerFn,e),nextListenerFn=wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;for(;nextListenerFn;)result=executeListenerWithErrorHandling(lView,context,nextListenerFn,e)&&result,nextListenerFn=nextListenerFn.__ngNextListenerFn__;return wrapWithPreventDefault&&!1===result&&e.preventDefault(),result}}function ɵɵnextContext(level=1){return function nextContextImpl(level){return(instructionState.lFrame.contextLView=walkUpViews(level,instructionState.lFrame.contextLView))[CONTEXT]}(level)}function matchingProjectionSlotIndex(tNode,projectionSlots){let wildcardNgContentIndex=null;const ngProjectAsAttrVal=function getProjectAsAttrValue(tNode){const nodeAttrs=tNode.attrs;if(null!=nodeAttrs){const ngProjectAsAttrIdx=nodeAttrs.indexOf(5);if(!(1&ngProjectAsAttrIdx))return nodeAttrs[ngProjectAsAttrIdx+1]}return null}(tNode);for(let i=0;i<projectionSlots.length;i++){const slotValue=projectionSlots[i];if("*"!==slotValue){if(null===ngProjectAsAttrVal?isNodeMatchingSelectorList(tNode,slotValue,!0):isSelectorInSelectorList(ngProjectAsAttrVal,slotValue))return i}else wildcardNgContentIndex=i}return wildcardNgContentIndex}function ɵɵprojectionDef(projectionSlots){const componentNode=getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];if(!componentNode.projection){const numProjectionSlots=projectionSlots?projectionSlots.length:1,projectionHeads=componentNode.projection=newArray(numProjectionSlots,null),tails=projectionHeads.slice();let componentChild=componentNode.child;for(;null!==componentChild;){const slotIndex=projectionSlots?matchingProjectionSlotIndex(componentChild,projectionSlots):0;null!==slotIndex&&(tails[slotIndex]?tails[slotIndex].projectionNext=componentChild:projectionHeads[slotIndex]=componentChild,tails[slotIndex]=componentChild),componentChild=componentChild.next}}}function ɵɵprojection(nodeIndex,selectorIndex=0,attrs){const lView=getLView(),tView=getTView(),tProjectionNode=getOrCreateTNode(tView,HEADER_OFFSET+nodeIndex,16,null,attrs||null);null===tProjectionNode.projection&&(tProjectionNode.projection=selectorIndex),setCurrentTNodeAsNotParent();(!lView[HYDRATION]||isInSkipHydrationBlock$1())&&32&~tProjectionNode.flags&&function applyProjection(tView,lView,tProjectionNode){applyProjectionRecursive(lView[RENDERER],0,lView,tProjectionNode,getParentRElement(tView,tProjectionNode,lView),getInsertInFrontOfRNode(tProjectionNode.parent||lView[T_HOST],tProjectionNode,lView))}(tView,lView,tProjectionNode)}function ɵɵpropertyInterpolate(propName,v0,sanitizer){return ɵɵpropertyInterpolate1(propName,"",v0,"",sanitizer),ɵɵpropertyInterpolate}function ɵɵpropertyInterpolate1(propName,prefix,v0,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation1(lView,prefix,v0,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-1,prefix,suffix)}return ɵɵpropertyInterpolate1}function ɵɵpropertyInterpolate2(propName,prefix,v0,i0,v1,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation2(lView,prefix,v0,i0,v1,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-2,prefix,i0,suffix)}return ɵɵpropertyInterpolate2}function ɵɵpropertyInterpolate3(propName,prefix,v0,i0,v1,i1,v2,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-3,prefix,i0,i1,suffix)}return ɵɵpropertyInterpolate3}function ɵɵpropertyInterpolate4(propName,prefix,v0,i0,v1,i1,v2,i2,v3,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-4,prefix,i0,i1,i2,suffix)}return ɵɵpropertyInterpolate4}function ɵɵpropertyInterpolate5(propName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-5,prefix,i0,i1,i2,i3,suffix)}return ɵɵpropertyInterpolate5}function ɵɵpropertyInterpolate6(propName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-6,prefix,i0,i1,i2,i3,i4,suffix)}return ɵɵpropertyInterpolate6}function ɵɵpropertyInterpolate7(propName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-7,prefix,i0,i1,i2,i3,i4,i5,suffix)}return ɵɵpropertyInterpolate7}function ɵɵpropertyInterpolate8(propName,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix,sanitizer){const lView=getLView(),interpolatedValue=interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-8,prefix,i0,i1,i2,i3,i4,i5,i6,suffix)}return ɵɵpropertyInterpolate8}function ɵɵpropertyInterpolateV(propName,values,sanitizer){const lView=getLView(),interpolatedValue=interpolationV(lView,values);if(interpolatedValue!==NO_CHANGE){const tView=getTView(),tNode=getSelectedTNode();if(elementPropertyInternal(tView,tNode,lView,propName,interpolatedValue,lView[RENDERER],sanitizer,!1),ngDevMode){const interpolationInBetween=[values[0]];for(let i=2;i<values.length;i+=2)interpolationInBetween.push(values[i]);storePropertyBindingMetadata(tView.data,tNode,propName,getBindingIndex()-interpolationInBetween.length+1,...interpolationInBetween)}}return ɵɵpropertyInterpolateV}function ɵɵcontentQuery(directiveIndex,predicate,flags,read){createContentQuery(directiveIndex,predicate,flags,read)}function ɵɵviewQuery(predicate,flags,read){createViewQuery(predicate,flags,read)}function ɵɵqueryRefresh(queryList){const lView=getLView(),tView=getTView(),queryIndex=getCurrentQueryIndex();setCurrentQueryIndex(queryIndex+1);const tQuery=getTQuery(tView,queryIndex);if(queryList.dirty&&isCreationMode(lView)===!(2&~tQuery.metadata.flags)){if(null===tQuery.matches)queryList.reset([]);else{const result=getQueryResults(lView,queryIndex);queryList.reset(result,unwrapElementRef),queryList.notifyOnChanges()}return!0}return!1}function ɵɵloadQuery(){return loadQueryInternal(getLView(),getCurrentQueryIndex())}function ɵɵcontentQuerySignal(directiveIndex,target,predicate,flags,read){bindQueryToSignal(target,createContentQuery(directiveIndex,predicate,flags,read))}function ɵɵviewQuerySignal(target,predicate,flags,read){bindQueryToSignal(target,createViewQuery(predicate,flags,read))}function ɵɵqueryAdvance(indexOffset=1){setCurrentQueryIndex(getCurrentQueryIndex()+indexOffset)}function ɵɵreference(index){return load(function getContextLView(){const contextLView=instructionState.lFrame.contextLView;return ngDevMode&&assertDefined(contextLView,"contextLView must be defined."),contextLView}(),HEADER_OFFSET+index)}function ɵɵstyleMapInterpolate1(prefix,v0,suffix){ɵɵstyleMap(interpolation1(getLView(),prefix,v0,suffix))}function ɵɵstyleMapInterpolate2(prefix,v0,i0,v1,suffix){ɵɵstyleMap(interpolation2(getLView(),prefix,v0,i0,v1,suffix))}function ɵɵstyleMapInterpolate3(prefix,v0,i0,v1,i1,v2,suffix){ɵɵstyleMap(interpolation3(getLView(),prefix,v0,i0,v1,i1,v2,suffix))}function ɵɵstyleMapInterpolate4(prefix,v0,i0,v1,i1,v2,i2,v3,suffix){ɵɵstyleMap(interpolation4(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,suffix))}function ɵɵstyleMapInterpolate5(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix){ɵɵstyleMap(interpolation5(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix))}function ɵɵstyleMapInterpolate6(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix){ɵɵstyleMap(interpolation6(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix))}function ɵɵstyleMapInterpolate7(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix){ɵɵstyleMap(interpolation7(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix))}function ɵɵstyleMapInterpolate8(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix){ɵɵstyleMap(interpolation8(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix))}function ɵɵstyleMapInterpolateV(values){ɵɵstyleMap(interpolationV(getLView(),values))}function ɵɵstylePropInterpolate1(prop,prefix,v0,suffix,valueSuffix){return checkStylingProperty(prop,interpolation1(getLView(),prefix,v0,suffix),valueSuffix,!1),ɵɵstylePropInterpolate1}function ɵɵstylePropInterpolate2(prop,prefix,v0,i0,v1,suffix,valueSuffix){return checkStylingProperty(prop,interpolation2(getLView(),prefix,v0,i0,v1,suffix),valueSuffix,!1),ɵɵstylePropInterpolate2}function ɵɵstylePropInterpolate3(prop,prefix,v0,i0,v1,i1,v2,suffix,valueSuffix){return checkStylingProperty(prop,interpolation3(getLView(),prefix,v0,i0,v1,i1,v2,suffix),valueSuffix,!1),ɵɵstylePropInterpolate3}function ɵɵstylePropInterpolate4(prop,prefix,v0,i0,v1,i1,v2,i2,v3,suffix,valueSuffix){return checkStylingProperty(prop,interpolation4(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,suffix),valueSuffix,!1),ɵɵstylePropInterpolate4}function ɵɵstylePropInterpolate5(prop,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix,valueSuffix){return checkStylingProperty(prop,interpolation5(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix),valueSuffix,!1),ɵɵstylePropInterpolate5}function ɵɵstylePropInterpolate6(prop,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix,valueSuffix){return checkStylingProperty(prop,interpolation6(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix),valueSuffix,!1),ɵɵstylePropInterpolate6}function ɵɵstylePropInterpolate7(prop,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix,valueSuffix){return checkStylingProperty(prop,interpolation7(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix),valueSuffix,!1),ɵɵstylePropInterpolate7}function ɵɵstylePropInterpolate8(prop,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix,valueSuffix){return checkStylingProperty(prop,interpolation8(getLView(),prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix),valueSuffix,!1),ɵɵstylePropInterpolate8}function ɵɵstylePropInterpolateV(prop,values,valueSuffix){return checkStylingProperty(prop,interpolationV(getLView(),values),valueSuffix,!1),ɵɵstylePropInterpolateV}function ɵɵtext(index,value=""){const lView=getLView(),tView=getTView(),adjustedIndex=index+HEADER_OFFSET;ngDevMode&&assertEqual(getBindingIndex(),tView.bindingStartIndex,"text nodes should be created before any bindings"),ngDevMode&&assertIndexInRange(lView,adjustedIndex);const tNode=tView.firstCreatePass?getOrCreateTNode(tView,adjustedIndex,1,value,null):tView.data[adjustedIndex],textNative=_locateOrCreateTextNode(tView,lView,tNode,value,index);lView[adjustedIndex]=textNative,wasLastNodeCreated()&&appendChild(tView,lView,textNative,tNode),setCurrentTNode(tNode,!1)}let _locateOrCreateTextNode=(tView,lView,tNode,value,index)=>(lastNodeWasCreated(!0),createTextNode(lView[RENDERER],value));function ɵɵtextInterpolate(v0){return ɵɵtextInterpolate1("",v0,""),ɵɵtextInterpolate}function ɵɵtextInterpolate1(prefix,v0,suffix){const lView=getLView(),interpolated=interpolation1(lView,prefix,v0,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate1}function ɵɵtextInterpolate2(prefix,v0,i0,v1,suffix){const lView=getLView(),interpolated=interpolation2(lView,prefix,v0,i0,v1,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate2}function ɵɵtextInterpolate3(prefix,v0,i0,v1,i1,v2,suffix){const lView=getLView(),interpolated=interpolation3(lView,prefix,v0,i0,v1,i1,v2,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate3}function ɵɵtextInterpolate4(prefix,v0,i0,v1,i1,v2,i2,v3,suffix){const lView=getLView(),interpolated=interpolation4(lView,prefix,v0,i0,v1,i1,v2,i2,v3,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate4}function ɵɵtextInterpolate5(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix){const lView=getLView(),interpolated=interpolation5(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate5}function ɵɵtextInterpolate6(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix){const lView=getLView(),interpolated=interpolation6(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate6}function ɵɵtextInterpolate7(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix){const lView=getLView(),interpolated=interpolation7(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate7}function ɵɵtextInterpolate8(prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix){const lView=getLView(),interpolated=interpolation8(lView,prefix,v0,i0,v1,i1,v2,i2,v3,i3,v4,i4,v5,i5,v6,i6,v7,suffix);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolate8}function ɵɵtextInterpolateV(values){const lView=getLView(),interpolated=interpolationV(lView,values);return interpolated!==NO_CHANGE&&textBindingInternal(lView,getSelectedIndex(),interpolated),ɵɵtextInterpolateV}function ɵɵtwoWayProperty(propName,value,sanitizer){isWritableSignal(value)&&(value=value());const lView=getLView(),bindingIndex=nextBindingIndex();if(bindingUpdated(lView,bindingIndex,value)){const tView=getTView(),tNode=getSelectedTNode();elementPropertyInternal(tView,tNode,lView,propName,value,lView[RENDERER],sanitizer,!1),ngDevMode&&storePropertyBindingMetadata(tView.data,tNode,propName,bindingIndex)}return ɵɵtwoWayProperty}function ɵɵtwoWayBindingSet(target,value){const canWrite=isWritableSignal(target);return canWrite&&target.set(value),canWrite}function ɵɵtwoWayListener(eventName,listenerFn){const lView=getLView(),tView=getTView(),tNode=getCurrentTNode();return listenerInternal(tView,lView,lView[RENDERER],tNode,eventName,listenerFn),ɵɵtwoWayListener}function resolveProvider(provider,tInjectables,lInjectablesBlueprint,isComponent,isViewProvider){if(provider=resolveForwardRef(provider),Array.isArray(provider))for(let i=0;i<provider.length;i++)resolveProvider(provider[i],tInjectables,lInjectablesBlueprint,isComponent,isViewProvider);else{const tView=getTView(),lView=getLView(),tNode=getCurrentTNode();let token=isTypeProvider(provider)?provider:resolveForwardRef(provider.provide);const providerFactory=providerToFactory(provider);if(ngDevMode){runInInjectorProfilerContext(new NodeInjector(tNode,lView),token,(()=>{emitProviderConfiguredEvent(provider,isViewProvider)}))}const beginIndex=1048575&tNode.providerIndexes,endIndex=tNode.directiveStart,cptViewProvidersCount=tNode.providerIndexes>>20;if(isTypeProvider(provider)||!provider.multi){const factory=new NodeInjectorFactory(providerFactory,isViewProvider,ɵɵdirectiveInject),existingFactoryIndex=indexOf(token,tInjectables,isViewProvider?beginIndex:beginIndex+cptViewProvidersCount,endIndex);-1===existingFactoryIndex?(diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,token),registerDestroyHooksIfSupported(tView,provider,tInjectables.length),tInjectables.push(token),tNode.directiveStart++,tNode.directiveEnd++,isViewProvider&&(tNode.providerIndexes+=1048576),lInjectablesBlueprint.push(factory),lView.push(factory)):(lInjectablesBlueprint[existingFactoryIndex]=factory,lView[existingFactoryIndex]=factory)}else{const existingProvidersFactoryIndex=indexOf(token,tInjectables,beginIndex+cptViewProvidersCount,endIndex),existingViewProvidersFactoryIndex=indexOf(token,tInjectables,beginIndex,beginIndex+cptViewProvidersCount),doesProvidersFactoryExist=existingProvidersFactoryIndex>=0&&lInjectablesBlueprint[existingProvidersFactoryIndex],doesViewProvidersFactoryExist=existingViewProvidersFactoryIndex>=0&&lInjectablesBlueprint[existingViewProvidersFactoryIndex];if(isViewProvider&&!doesViewProvidersFactoryExist||!isViewProvider&&!doesProvidersFactoryExist){diPublicInInjector(getOrCreateNodeInjectorForNode(tNode,lView),tView,token);const factory=function multiFactory(factoryFn,index,isViewProvider,isComponent,f){const factory=new NodeInjectorFactory(factoryFn,isViewProvider,ɵɵdirectiveInject);return factory.multi=[],factory.index=index,factory.componentProviders=0,multiFactoryAdd(factory,f,isComponent&&!isViewProvider),factory}(isViewProvider?multiViewProvidersFactoryResolver:multiProvidersFactoryResolver,lInjectablesBlueprint.length,isViewProvider,isComponent,providerFactory);!isViewProvider&&doesViewProvidersFactoryExist&&(lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory=factory),registerDestroyHooksIfSupported(tView,provider,tInjectables.length,0),tInjectables.push(token),tNode.directiveStart++,tNode.directiveEnd++,isViewProvider&&(tNode.providerIndexes+=1048576),lInjectablesBlueprint.push(factory),lView.push(factory)}else{const indexInFactory=multiFactoryAdd(lInjectablesBlueprint[isViewProvider?existingViewProvidersFactoryIndex:existingProvidersFactoryIndex],providerFactory,!isViewProvider&&isComponent);registerDestroyHooksIfSupported(tView,provider,existingProvidersFactoryIndex>-1?existingProvidersFactoryIndex:existingViewProvidersFactoryIndex,indexInFactory)}!isViewProvider&&isComponent&&doesViewProvidersFactoryExist&&lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++}}}function registerDestroyHooksIfSupported(tView,provider,contextIndex,indexInFactory){const providerIsTypeProvider=isTypeProvider(provider),providerIsClassProvider=function isClassProvider(value){return!!value.useClass}(provider);if(providerIsTypeProvider||providerIsClassProvider){const ngOnDestroy=(providerIsClassProvider?resolveForwardRef(provider.useClass):provider).prototype.ngOnDestroy;if(ngOnDestroy){const hooks=tView.destroyHooks||(tView.destroyHooks=[]);if(!providerIsTypeProvider&&provider.multi){ngDevMode&&assertDefined(indexInFactory,"indexInFactory when registering multi factory destroy hook");const existingCallbacksIndex=hooks.indexOf(contextIndex);-1===existingCallbacksIndex?hooks.push(contextIndex,[indexInFactory,ngOnDestroy]):hooks[existingCallbacksIndex+1].push(indexInFactory,ngOnDestroy)}else hooks.push(contextIndex,ngOnDestroy)}}}function multiFactoryAdd(multiFactory,factory,isComponentProvider){return isComponentProvider&&multiFactory.componentProviders++,multiFactory.multi.push(factory)-1}function indexOf(item,arr,begin,end){for(let i=begin;i<end;i++)if(arr[i]===item)return i;return-1}function multiProvidersFactoryResolver(_,tData,lData,tNode){return multiResolve(this.multi,[])}function multiViewProvidersFactoryResolver(_,tData,lView,tNode){const factories=this.multi;let result;if(this.providerFactory){const componentCount=this.providerFactory.componentProviders,multiProviders=getNodeInjectable(lView,lView[TVIEW],this.providerFactory.index,tNode);result=multiProviders.slice(0,componentCount),multiResolve(factories,result);for(let i=componentCount;i<multiProviders.length;i++)result.push(multiProviders[i])}else result=[],multiResolve(factories,result);return result}function multiResolve(factories,result){for(let i=0;i<factories.length;i++){const factory=factories[i];result.push(factory())}return result}function ɵɵProvidersFeature(providers,viewProviders=[]){return definition=>{definition.providersResolver=(def,processProvidersFn)=>function providersResolver(def,providers,viewProviders){const tView=getTView();if(tView.firstCreatePass){const isComponent=isComponentDef(def);resolveProvider(viewProviders,tView.data,tView.blueprint,isComponent,!0),resolveProvider(providers,tView.data,tView.blueprint,isComponent,!1)}}(def,processProvidersFn?processProvidersFn(providers):providers,viewProviders)}}class StandaloneService{constructor(_injector){this._injector=_injector,this.cachedInjectors=new Map}getOrCreateStandaloneInjector(componentDef){if(!componentDef.standalone)return null;if(!this.cachedInjectors.has(componentDef)){const providers=internalImportProvidersFrom(!1,componentDef.type),standaloneInjector=providers.length>0?createEnvironmentInjector([providers],this._injector,`Standalone[${componentDef.type.name}]`):null;this.cachedInjectors.set(componentDef,standaloneInjector)}return this.cachedInjectors.get(componentDef)}ngOnDestroy(){try{for(const injector of this.cachedInjectors.values())null!==injector&&injector.destroy()}finally{this.cachedInjectors.clear()}}static#_=this.ɵprov=ɵɵdefineInjectable({token:StandaloneService,providedIn:"environment",factory:()=>new StandaloneService(ɵɵinject(EnvironmentInjector))})}function ɵɵStandaloneFeature(definition){performanceMarkFeature("NgStandalone"),definition.getStandaloneInjector=parentInjector=>parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(definition)}function ɵɵsetComponentScope(type,directives,pipes){const def=type.ɵcmp;def.directiveDefs=extractDefListOrFactory(directives,!1),def.pipeDefs=extractDefListOrFactory(pipes,!0)}function ɵɵsetNgModuleScope(type,scope){return noSideEffects((()=>{const ngModuleDef=getNgModuleDef(type,!0);ngModuleDef.declarations=convertToTypeArray(scope.declarations||EMPTY_ARRAY),ngModuleDef.imports=convertToTypeArray(scope.imports||EMPTY_ARRAY),ngModuleDef.exports=convertToTypeArray(scope.exports||EMPTY_ARRAY),scope.bootstrap&&(ngModuleDef.bootstrap=convertToTypeArray(scope.bootstrap)),depsTracker.registerNgModule(type,scope)}))}function convertToTypeArray(values){if("function"==typeof values)return values;const flattenValues=flatten(values);return flattenValues.some(isForwardRef)?()=>flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders):flattenValues.map(maybeUnwrapModuleWithProviders)}function maybeUnwrapModuleWithProviders(value){return isModuleWithProviders(value)?value.ngModule:value}function ɵɵpureFunction0(slotOffset,pureFn,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=getLView();return lView[bindingIndex]===NO_CHANGE?updateBinding(lView,bindingIndex,thisArg?pureFn.call(thisArg):pureFn()):getBinding(lView,bindingIndex)}function ɵɵpureFunction1(slotOffset,pureFn,exp,thisArg){return pureFunction1Internal(getLView(),getBindingRoot(),slotOffset,pureFn,exp,thisArg)}function ɵɵpureFunction2(slotOffset,pureFn,exp1,exp2,thisArg){return pureFunction2Internal(getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,thisArg)}function ɵɵpureFunction3(slotOffset,pureFn,exp1,exp2,exp3,thisArg){return pureFunction3Internal(getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,exp3,thisArg)}function ɵɵpureFunction4(slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg){return pureFunction4Internal(getLView(),getBindingRoot(),slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg)}function ɵɵpureFunction5(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated(lView,bindingIndex+4,exp5)||different?updateBinding(lView,bindingIndex+5,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5):pureFn(exp1,exp2,exp3,exp4,exp5)):getBinding(lView,bindingIndex+5)}function ɵɵpureFunction6(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated2(lView,bindingIndex+4,exp5,exp6)||different?updateBinding(lView,bindingIndex+6,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6):pureFn(exp1,exp2,exp3,exp4,exp5,exp6)):getBinding(lView,bindingIndex+6)}function ɵɵpureFunction7(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,exp7,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=getLView();let different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated3(lView,bindingIndex+4,exp5,exp6,exp7)||different?updateBinding(lView,bindingIndex+7,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6,exp7):pureFn(exp1,exp2,exp3,exp4,exp5,exp6,exp7)):getBinding(lView,bindingIndex+7)}function ɵɵpureFunction8(slotOffset,pureFn,exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8,thisArg){const bindingIndex=getBindingRoot()+slotOffset,lView=getLView(),different=bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4);return bindingUpdated4(lView,bindingIndex+4,exp5,exp6,exp7,exp8)||different?updateBinding(lView,bindingIndex+8,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8):pureFn(exp1,exp2,exp3,exp4,exp5,exp6,exp7,exp8)):getBinding(lView,bindingIndex+8)}function ɵɵpureFunctionV(slotOffset,pureFn,exps,thisArg){return pureFunctionVInternal(getLView(),getBindingRoot(),slotOffset,pureFn,exps,thisArg)}function getPureFunctionReturnValue(lView,returnValueIndex){ngDevMode&&assertIndexInRange(lView,returnValueIndex);const lastReturnValue=lView[returnValueIndex];return lastReturnValue===NO_CHANGE?void 0:lastReturnValue}function pureFunction1Internal(lView,bindingRoot,slotOffset,pureFn,exp,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated(lView,bindingIndex,exp)?updateBinding(lView,bindingIndex+1,thisArg?pureFn.call(thisArg,exp):pureFn(exp)):getPureFunctionReturnValue(lView,bindingIndex+1)}function pureFunction2Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated2(lView,bindingIndex,exp1,exp2)?updateBinding(lView,bindingIndex+2,thisArg?pureFn.call(thisArg,exp1,exp2):pureFn(exp1,exp2)):getPureFunctionReturnValue(lView,bindingIndex+2)}function pureFunction3Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,exp3,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated3(lView,bindingIndex,exp1,exp2,exp3)?updateBinding(lView,bindingIndex+3,thisArg?pureFn.call(thisArg,exp1,exp2,exp3):pureFn(exp1,exp2,exp3)):getPureFunctionReturnValue(lView,bindingIndex+3)}function pureFunction4Internal(lView,bindingRoot,slotOffset,pureFn,exp1,exp2,exp3,exp4,thisArg){const bindingIndex=bindingRoot+slotOffset;return bindingUpdated4(lView,bindingIndex,exp1,exp2,exp3,exp4)?updateBinding(lView,bindingIndex+4,thisArg?pureFn.call(thisArg,exp1,exp2,exp3,exp4):pureFn(exp1,exp2,exp3,exp4)):getPureFunctionReturnValue(lView,bindingIndex+4)}function pureFunctionVInternal(lView,bindingRoot,slotOffset,pureFn,exps,thisArg){let bindingIndex=bindingRoot+slotOffset,different=!1;for(let i=0;i<exps.length;i++)bindingUpdated(lView,bindingIndex++,exps[i])&&(different=!0);return different?updateBinding(lView,bindingIndex,pureFn.apply(thisArg,exps)):getPureFunctionReturnValue(lView,bindingIndex)}function ɵɵpipe(index,pipeName){const tView=getTView();let pipeDef;const adjustedIndex=index+HEADER_OFFSET;tView.firstCreatePass?(pipeDef=function getPipeDef(name,registry){if(registry){if(ngDevMode){registry.filter((pipe=>pipe.name===name)).length>1&&console.warn(formatRuntimeError(313,function getMultipleMatchingPipesMessage(name){const lView=getLView(),context=lView[DECLARATION_COMPONENT_VIEW][CONTEXT],hostIsStandalone=isHostComponentStandalone(lView),componentInfoMessage=context?` in the '${context.constructor.name}' component`:"",errorMessage=`Multiple pipes match the name \`${name}\`${componentInfoMessage}. ${"check "+(hostIsStandalone?"'@Component.imports' of this component":"the imports of this module")}`;return errorMessage}(name)))}for(let i=registry.length-1;i>=0;i--){const pipeDef=registry[i];if(name===pipeDef.name)return pipeDef}}if(ngDevMode)throw new RuntimeError(-302,function getPipeNotFoundErrorMessage(name){const lView=getLView(),context=lView[DECLARATION_COMPONENT_VIEW][CONTEXT],hostIsStandalone=isHostComponentStandalone(lView),componentInfoMessage=context?` in the '${context.constructor.name}' component`:"",errorMessage=`The pipe '${name}' could not be found${componentInfoMessage}. ${"Verify that it is "+(hostIsStandalone?"included in the '@Component.imports' of this component":"declared or imported in this module")}`;return errorMessage}(name));return}(pipeName,tView.pipeRegistry),tView.data[adjustedIndex]=pipeDef,pipeDef.onDestroy&&(tView.destroyHooks??=[]).push(adjustedIndex,pipeDef.onDestroy)):pipeDef=tView.data[adjustedIndex];const pipeFactory=pipeDef.factory||(pipeDef.factory=getFactoryDef(pipeDef.type,!0));let previousInjectorProfilerContext;ngDevMode&&(previousInjectorProfilerContext=setInjectorProfilerContext({injector:new NodeInjector(getCurrentTNode(),getLView()),token:pipeDef.type}));const previousInjectImplementation=setInjectImplementation(ɵɵdirectiveInject);try{const previousIncludeViewProviders=setIncludeViewProviders(!1),pipeInstance=pipeFactory();return setIncludeViewProviders(previousIncludeViewProviders),function store(tView,lView,index,value){index>=tView.data.length&&(tView.data[index]=null,tView.blueprint[index]=null),lView[index]=value}(tView,getLView(),adjustedIndex,pipeInstance),pipeInstance}finally{setInjectImplementation(previousInjectImplementation),ngDevMode&&setInjectorProfilerContext(previousInjectorProfilerContext)}}function ɵɵpipeBind1(index,offset,v1){const adjustedIndex=index+HEADER_OFFSET,lView=getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction1Internal(lView,getBindingRoot(),offset,pipeInstance.transform,v1,pipeInstance):pipeInstance.transform(v1)}function ɵɵpipeBind2(index,slotOffset,v1,v2){const adjustedIndex=index+HEADER_OFFSET,lView=getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction2Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,pipeInstance):pipeInstance.transform(v1,v2)}function ɵɵpipeBind3(index,slotOffset,v1,v2,v3){const adjustedIndex=index+HEADER_OFFSET,lView=getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction3Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,v3,pipeInstance):pipeInstance.transform(v1,v2,v3)}function ɵɵpipeBind4(index,slotOffset,v1,v2,v3,v4){const adjustedIndex=index+HEADER_OFFSET,lView=getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunction4Internal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,v1,v2,v3,v4,pipeInstance):pipeInstance.transform(v1,v2,v3,v4)}function ɵɵpipeBindV(index,slotOffset,values){const adjustedIndex=index+HEADER_OFFSET,lView=getLView(),pipeInstance=load(lView,adjustedIndex);return isPure(lView,adjustedIndex)?pureFunctionVInternal(lView,getBindingRoot(),slotOffset,pipeInstance.transform,values,pipeInstance):pipeInstance.transform.apply(pipeInstance,values)}function isPure(lView,index){return lView[TVIEW].data[index].pure}function ɵɵtemplateRefExtractor(tNode,lView){return createTemplateRef(tNode,lView)}function ɵɵgetComponentDepsFactory(type,rawImports){return()=>{try{return depsTracker.getComponentDependencies(type,rawImports).dependencies}catch(e){throw console.error(`Computing dependencies in local compilation mode for the component "${type.name}" failed with the exception:`,e),e}}}function ɵsetClassDebugInfo(type,debugInfo){const def=getComponentDef(type);null!==def&&(def.debugInfo=debugInfo)}const angularCoreEnv={ɵɵattribute,ɵɵattributeInterpolate1,ɵɵattributeInterpolate2,ɵɵattributeInterpolate3,ɵɵattributeInterpolate4,ɵɵattributeInterpolate5,ɵɵattributeInterpolate6,ɵɵattributeInterpolate7,ɵɵattributeInterpolate8,ɵɵattributeInterpolateV,ɵɵdefineComponent,ɵɵdefineDirective,ɵɵdefineInjectable,ɵɵdefineInjector,ɵɵdefineNgModule,ɵɵdefinePipe,ɵɵdirectiveInject,ɵɵgetInheritedFactory,ɵɵinject,ɵɵinjectAttribute,ɵɵinvalidFactory,ɵɵinvalidFactoryDep,ɵɵtemplateRefExtractor,ɵɵresetView,ɵɵHostDirectivesFeature,ɵɵNgOnChangesFeature,ɵɵProvidersFeature,ɵɵCopyDefinitionFeature,ɵɵInheritDefinitionFeature,ɵɵInputTransformsFeature,ɵɵStandaloneFeature,ɵɵnextContext,ɵɵnamespaceHTML,ɵɵnamespaceMathML,ɵɵnamespaceSVG,ɵɵenableBindings,ɵɵdisableBindings,ɵɵelementStart,ɵɵelementEnd,ɵɵelement,ɵɵelementContainerStart,ɵɵelementContainerEnd,ɵɵelementContainer,ɵɵpureFunction0,ɵɵpureFunction1,ɵɵpureFunction2,ɵɵpureFunction3,ɵɵpureFunction4,ɵɵpureFunction5,ɵɵpureFunction6,ɵɵpureFunction7,ɵɵpureFunction8,ɵɵpureFunctionV,ɵɵgetCurrentView,ɵɵrestoreView,ɵɵlistener,ɵɵprojection,ɵɵsyntheticHostProperty,ɵɵsyntheticHostListener,ɵɵpipeBind1,ɵɵpipeBind2,ɵɵpipeBind3,ɵɵpipeBind4,ɵɵpipeBindV,ɵɵprojectionDef,ɵɵhostProperty,ɵɵproperty,ɵɵpropertyInterpolate,ɵɵpropertyInterpolate1,ɵɵpropertyInterpolate2,ɵɵpropertyInterpolate3,ɵɵpropertyInterpolate4,ɵɵpropertyInterpolate5,ɵɵpropertyInterpolate6,ɵɵpropertyInterpolate7,ɵɵpropertyInterpolate8,ɵɵpropertyInterpolateV,ɵɵpipe,ɵɵqueryRefresh,ɵɵqueryAdvance,ɵɵviewQuery,ɵɵviewQuerySignal,ɵɵloadQuery,ɵɵcontentQuery,ɵɵcontentQuerySignal,ɵɵreference,ɵɵclassMap,ɵɵclassMapInterpolate1,ɵɵclassMapInterpolate2,ɵɵclassMapInterpolate3,ɵɵclassMapInterpolate4,ɵɵclassMapInterpolate5,ɵɵclassMapInterpolate6,ɵɵclassMapInterpolate7,ɵɵclassMapInterpolate8,ɵɵclassMapInterpolateV,ɵɵstyleMap,ɵɵstyleMapInterpolate1,ɵɵstyleMapInterpolate2,ɵɵstyleMapInterpolate3,ɵɵstyleMapInterpolate4,ɵɵstyleMapInterpolate5,ɵɵstyleMapInterpolate6,ɵɵstyleMapInterpolate7,ɵɵstyleMapInterpolate8,ɵɵstyleMapInterpolateV,ɵɵstyleProp,ɵɵstylePropInterpolate1,ɵɵstylePropInterpolate2,ɵɵstylePropInterpolate3,ɵɵstylePropInterpolate4,ɵɵstylePropInterpolate5,ɵɵstylePropInterpolate6,ɵɵstylePropInterpolate7,ɵɵstylePropInterpolate8,ɵɵstylePropInterpolateV,ɵɵclassProp,ɵɵadvance,ɵɵtemplate,ɵɵconditional,ɵɵdefer,ɵɵdeferWhen,ɵɵdeferOnIdle,ɵɵdeferOnImmediate,ɵɵdeferOnTimer,ɵɵdeferOnHover,ɵɵdeferOnInteraction,ɵɵdeferOnViewport,ɵɵdeferPrefetchWhen,ɵɵdeferPrefetchOnIdle,ɵɵdeferPrefetchOnImmediate,ɵɵdeferPrefetchOnTimer,ɵɵdeferPrefetchOnHover,ɵɵdeferPrefetchOnInteraction,ɵɵdeferPrefetchOnViewport,ɵɵdeferEnableTimerScheduling,ɵɵrepeater,ɵɵrepeaterCreate,ɵɵrepeaterTrackByIndex,ɵɵrepeaterTrackByIdentity,ɵɵcomponentInstance,ɵɵtext,ɵɵtextInterpolate,ɵɵtextInterpolate1,ɵɵtextInterpolate2,ɵɵtextInterpolate3,ɵɵtextInterpolate4,ɵɵtextInterpolate5,ɵɵtextInterpolate6,ɵɵtextInterpolate7,ɵɵtextInterpolate8,ɵɵtextInterpolateV,ɵɵi18n,ɵɵi18nAttributes,ɵɵi18nExp,ɵɵi18nStart,ɵɵi18nEnd,ɵɵi18nApply,ɵɵi18nPostprocess,ɵɵresolveWindow,ɵɵresolveDocument,ɵɵresolveBody,ɵɵsetComponentScope,ɵɵsetNgModuleScope,ɵɵregisterNgModuleType:registerNgModuleType,ɵɵgetComponentDepsFactory,ɵsetClassDebugInfo,ɵɵsanitizeHtml,ɵɵsanitizeStyle,ɵɵsanitizeResourceUrl,ɵɵsanitizeScript,ɵɵsanitizeUrl,ɵɵsanitizeUrlOrResourceUrl,ɵɵtrustConstantHtml,ɵɵtrustConstantResourceUrl,ɵɵvalidateIframeAttribute,forwardRef,resolveForwardRef,ɵɵtwoWayProperty,ɵɵtwoWayBindingSet,ɵɵtwoWayListener,ɵɵInputFlags:InputFlags};let jitOptions=null;const moduleQueue=[];let flushingModuleQueue=!1;function isResolvedDeclaration(declaration){return Array.isArray(declaration)?declaration.every(isResolvedDeclaration):!!resolveForwardRef(declaration)}function compileNgModule(moduleType,ngModule={}){!function compileNgModuleDefs(moduleType,ngModule,allowDuplicateDeclarationsInRoot=!1){ngDevMode&&assertDefined(moduleType,"Required value moduleType"),ngDevMode&&assertDefined(ngModule,"Required value ngModule");const declarations=flatten(ngModule.declarations||EMPTY_ARRAY);let ngModuleDef=null;Object.defineProperty(moduleType,NG_MOD_DEF,{configurable:!0,get:()=>{if(null===ngModuleDef){if(ngDevMode&&ngModule.imports&&ngModule.imports.indexOf(moduleType)>-1)throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);const compiler=getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngModuleDef=compiler.compileNgModule(angularCoreEnv,`ng:///${moduleType.name}/ɵmod.js`,{type:moduleType,bootstrap:flatten(ngModule.bootstrap||EMPTY_ARRAY).map(resolveForwardRef),declarations:declarations.map(resolveForwardRef),imports:flatten(ngModule.imports||EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),exports:flatten(ngModule.exports||EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),schemas:ngModule.schemas?flatten(ngModule.schemas):null,id:ngModule.id||null}),ngModuleDef.schemas||(ngModuleDef.schemas=[])}return ngModuleDef}});let ngFactoryDef=null;Object.defineProperty(moduleType,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const compiler=getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngFactoryDef=compiler.compileFactory(angularCoreEnv,`ng:///${moduleType.name}/ɵfac.js`,{name:moduleType.name,type:moduleType,deps:reflectDependencies(moduleType),target:compiler.FactoryTarget.NgModule,typeArgumentCount:0})}return ngFactoryDef},configurable:!!ngDevMode});let ngInjectorDef=null;Object.defineProperty(moduleType,NG_INJ_DEF,{get:()=>{if(null===ngInjectorDef){ngDevMode&&verifySemanticsOfNgModuleDef(moduleType,allowDuplicateDeclarationsInRoot);const meta={name:moduleType.name,type:moduleType,providers:ngModule.providers||EMPTY_ARRAY,imports:[(ngModule.imports||EMPTY_ARRAY).map(resolveForwardRef),(ngModule.exports||EMPTY_ARRAY).map(resolveForwardRef)]},compiler=getCompilerFacade({usage:0,kind:"NgModule",type:moduleType});ngInjectorDef=compiler.compileInjector(angularCoreEnv,`ng:///${moduleType.name}/ɵinj.js`,meta)}return ngInjectorDef},configurable:!!ngDevMode})}(moduleType,ngModule),void 0!==ngModule.id&&registerNgModuleType(moduleType,ngModule.id),function enqueueModuleForDelayedScoping(moduleType,ngModule){moduleQueue.push({moduleType,ngModule})}(moduleType,ngModule)}function verifySemanticsOfNgModuleDef(moduleType,allowDuplicateDeclarationsInRoot,importingModule){if(verifiedNgModule.get(moduleType))return;if(isStandalone(moduleType))return;let ngModuleDef;if(verifiedNgModule.set(moduleType,!0),moduleType=resolveForwardRef(moduleType),importingModule){if(ngModuleDef=getNgModuleDef(moduleType),!ngModuleDef)throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`)}else ngModuleDef=getNgModuleDef(moduleType,!0);const errors=[],declarations=maybeUnwrapFn(ngModuleDef.declarations),imports=maybeUnwrapFn(ngModuleDef.imports);flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt=>{verifySemanticsOfNgModuleImport(modOrStandaloneCmpt,moduleType),verifySemanticsOfNgModuleDef(modOrStandaloneCmpt,!1,moduleType)}));const exports=maybeUnwrapFn(ngModuleDef.exports);declarations.forEach((function verifyDeclarationsHaveDefinitions(type){type=resolveForwardRef(type);getComponentDef(type)||getDirectiveDef(type)||getPipeDef$1(type)||errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`)})),declarations.forEach((function verifyDirectivesHaveSelector(type){const def=getDirectiveDef(type=resolveForwardRef(type));!getComponentDef(type)&&def&&0==def.selectors.length&&errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`)})),declarations.forEach((declarationType=>function verifyNotStandalone(type,moduleType){const def=getComponentDef(type=resolveForwardRef(type))||getDirectiveDef(type)||getPipeDef$1(type);if(def?.standalone){const location=`"${stringifyForError(moduleType)}" NgModule`;errors.push(function generateStandaloneInDeclarationsError(type,location){return`Unexpected "${stringifyForError(type)}" found in the "declarations" array of the ${location}, "${stringifyForError(type)}" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the "imports" array)?`}(type,location))}}(declarationType,moduleType)));const combinedDeclarations=[...declarations.map(resolveForwardRef),...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];exports.forEach((function verifyExportsAreDeclaredOrReExported(type){const kind=(getComponentDef(type=resolveForwardRef(type))?"component":getDirectiveDef(type)&&"directive")||getPipeDef$1(type)&&"pipe";kind&&-1===combinedDeclarations.lastIndexOf(type)&&errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`)})),declarations.forEach((decl=>function verifyDeclarationIsUnique(type,suppressErrors){type=resolveForwardRef(type);const existingModule=ownerNgModule.get(type);if(existingModule&&existingModule!==moduleType){if(!suppressErrors){const modules=[existingModule,moduleType].map(stringifyForError).sort();errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules[0]} and ${modules[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules[0]} and ${modules[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules[0]} and ${modules[1]}.`)}}else ownerNgModule.set(type,moduleType)}(decl,allowDuplicateDeclarationsInRoot)));const ngModule=function getAnnotation(type,name){let annotation=null;return collect(type.__annotations__),collect(type.decorators),annotation;function collect(annotations){annotations&&annotations.forEach(readAnnotation)}function readAnnotation(decorator){if(!annotation){if(Object.getPrototypeOf(decorator).ngMetadataName==name)annotation=decorator;else if(decorator.type){Object.getPrototypeOf(decorator.type).ngMetadataName==name&&(annotation=decorator.args[0])}}}}(moduleType,"NgModule");if(ngModule&&(ngModule.imports&&flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod=>{verifySemanticsOfNgModuleImport(mod,moduleType),verifySemanticsOfNgModuleDef(mod,!1,moduleType)})),ngModule.bootstrap&&deepForEach(ngModule.bootstrap,(function verifyCorrectBootstrapType(type){getComponentDef(type=resolveForwardRef(type))||errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);isStandalone(type)&&errors.push(`The \`${stringifyForError(type)}\` class is a standalone component, which can not be used in the \`@NgModule.bootstrap\` array. Use the \`bootstrapApplication\` function for bootstrap instead.`)})),ngModule.bootstrap&&deepForEach(ngModule.bootstrap,(function verifyComponentIsPartOfNgModule(type){type=resolveForwardRef(type);ownerNgModule.get(type)||isStandalone(type)||errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`)}))),errors.length)throw new Error(errors.join("\n"));function verifySemanticsOfNgModuleImport(type,importingModule){const directiveDef=getComponentDef(type=resolveForwardRef(type))||getDirectiveDef(type);if(null!==directiveDef&&!directiveDef.standalone)throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);const pipeDef=getPipeDef$1(type);if(null!==pipeDef&&!pipeDef.standalone)throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`)}}function unwrapModuleWithProvidersImports(typeOrWithProviders){return(typeOrWithProviders=resolveForwardRef(typeOrWithProviders)).ngModule||typeOrWithProviders}let ownerNgModule=new WeakMap,verifiedNgModule=new WeakMap;function computeCombinedExports(type){const ngModuleDef=getNgModuleDef(type=resolveForwardRef(type));return null===ngModuleDef?[type]:flatten(maybeUnwrapFn(ngModuleDef.exports).map((type=>getNgModuleDef(type)?(verifySemanticsOfNgModuleDef(type,!1),computeCombinedExports(type)):type)))}function setScopeOnDeclaredComponents(moduleType,ngModule){const declarations=flatten(ngModule.declarations||EMPTY_ARRAY),transitiveScopes=transitiveScopesFor(moduleType);declarations.forEach((declaration=>{if((declaration=resolveForwardRef(declaration)).hasOwnProperty(NG_COMP_DEF)){patchComponentDefWithScope(getComponentDef(declaration),transitiveScopes)}else declaration.hasOwnProperty(NG_DIR_DEF)||declaration.hasOwnProperty(NG_PIPE_DEF)||(declaration.ngSelectorScope=moduleType)}))}function patchComponentDefWithScope(componentDef,transitiveScopes){componentDef.directiveDefs=()=>Array.from(transitiveScopes.compilation.directives).map((dir=>dir.hasOwnProperty(NG_COMP_DEF)?getComponentDef(dir):getDirectiveDef(dir))).filter((def=>!!def)),componentDef.pipeDefs=()=>Array.from(transitiveScopes.compilation.pipes).map((pipe=>getPipeDef$1(pipe))),componentDef.schemas=transitiveScopes.schemas,componentDef.tView=null}function transitiveScopesFor(type){if(isNgModule(type)){if(USE_RUNTIME_DEPS_TRACKER_FOR_JIT){const scope=depsTracker.getNgModuleScope(type);return{schemas:getNgModuleDef(type,!0).schemas||null,...scope}}return function transitiveScopesForNgModule(moduleType){const def=getNgModuleDef(moduleType,!0);if(null!==def.transitiveCompileScopes)return def.transitiveCompileScopes;const scopes={schemas:def.schemas||null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set,pipes:new Set}};return maybeUnwrapFn(def.imports).forEach((imported=>{const importedScope=transitiveScopesFor(imported);importedScope.exported.directives.forEach((entry=>scopes.compilation.directives.add(entry))),importedScope.exported.pipes.forEach((entry=>scopes.compilation.pipes.add(entry)))})),maybeUnwrapFn(def.declarations).forEach((declared=>{getPipeDef$1(declared)?scopes.compilation.pipes.add(declared):scopes.compilation.directives.add(declared)})),maybeUnwrapFn(def.exports).forEach((exported=>{const exportedType=exported;if(isNgModule(exportedType)){const exportedScope=transitiveScopesFor(exportedType);exportedScope.exported.directives.forEach((entry=>{scopes.compilation.directives.add(entry),scopes.exported.directives.add(entry)})),exportedScope.exported.pipes.forEach((entry=>{scopes.compilation.pipes.add(entry),scopes.exported.pipes.add(entry)}))}else getPipeDef$1(exportedType)?scopes.exported.pipes.add(exportedType):scopes.exported.directives.add(exportedType)})),def.transitiveCompileScopes=scopes,scopes}(type)}if(isStandalone(type)){if(null!==(getComponentDef(type)||getDirectiveDef(type)))return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set([type]),pipes:new Set}};if(null!==getPipeDef$1(type))return{schemas:null,compilation:{directives:new Set,pipes:new Set},exported:{directives:new Set,pipes:new Set([type])}}}throw new Error(`${type.name} does not have a module def (ɵmod property)`)}function expandModuleWithProviders(value){return isModuleWithProviders(value)?value.ngModule:value}let compilationDepth=0;function compileComponent(type,metadata){("undefined"==typeof ngDevMode||ngDevMode)&&initNgDevMode();let ngComponentDef=null;!function maybeQueueResolutionOfComponentResources(type,metadata){componentNeedsResolution(metadata)&&(componentResourceResolutionQueue.set(type,metadata),componentDefPendingResolution.add(type))}(type,metadata),addDirectiveFactoryDef(type,metadata),Object.defineProperty(type,NG_COMP_DEF,{get:()=>{if(null===ngComponentDef){const compiler=getCompilerFacade({usage:0,kind:"component",type});if(componentNeedsResolution(metadata)){const error=[`Component '${type.name}' is not resolved:`];throw metadata.templateUrl&&error.push(` - templateUrl: ${metadata.templateUrl}`),metadata.styleUrls&&metadata.styleUrls.length&&error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`),metadata.styleUrl&&error.push(` - styleUrl: ${metadata.styleUrl}`),error.push("Did you run and wait for 'resolveComponentResources()'?"),new Error(error.join("\n"))}const options=function getJitOptions(){return jitOptions}();let preserveWhitespaces=metadata.preserveWhitespaces;void 0===preserveWhitespaces&&(preserveWhitespaces=null!==options&&void 0!==options.preserveWhitespaces&&options.preserveWhitespaces);let encapsulation=metadata.encapsulation;void 0===encapsulation&&(encapsulation=null!==options&&void 0!==options.defaultEncapsulation?options.defaultEncapsulation:ViewEncapsulation$1.Emulated);const templateUrl=metadata.templateUrl||`ng:///${type.name}/template.html`,meta={...directiveMetadata(type,metadata),typeSourceSpan:compiler.createParseSourceSpan("Component",type.name,templateUrl),template:metadata.template||"",preserveWhitespaces,styles:"string"==typeof metadata.styles?[metadata.styles]:metadata.styles||EMPTY_ARRAY,animations:metadata.animations,declarations:[],changeDetection:metadata.changeDetection,encapsulation,interpolation:metadata.interpolation,viewProviders:metadata.viewProviders||null};compilationDepth++;try{if(meta.usesInheritance&&addDirectiveDefToUndecoratedParents(type),ngComponentDef=compiler.compileComponent(angularCoreEnv,templateUrl,meta),metadata.standalone){const imports=flatten(metadata.imports||EMPTY_ARRAY),{directiveDefs,pipeDefs}=function getStandaloneDefFunctions(type,imports){let cachedDirectiveDefs=null,cachedPipeDefs=null;const directiveDefs=()=>{if(USE_RUNTIME_DEPS_TRACKER_FOR_JIT){if(ngDevMode)for(const rawDep of imports)verifyStandaloneImport(rawDep,type);if(!isComponent(type))return[];return[...depsTracker.getStandaloneComponentScope(type,imports).compilation.directives].map((p=>getComponentDef(p)||getDirectiveDef(p))).filter((d=>null!==d))}if(null===cachedDirectiveDefs){cachedDirectiveDefs=[getComponentDef(type)];const seen=new Set([type]);for(const rawDep of imports){ngDevMode&&verifyStandaloneImport(rawDep,type);const dep=resolveForwardRef(rawDep);if(!seen.has(dep))if(seen.add(dep),getNgModuleDef(dep)){const scope=transitiveScopesFor(dep);for(const dir of scope.exported.directives){const def=getComponentDef(dir)||getDirectiveDef(dir);def&&!seen.has(dir)&&(seen.add(dir),cachedDirectiveDefs.push(def))}}else{const def=getComponentDef(dep)||getDirectiveDef(dep);def&&cachedDirectiveDefs.push(def)}}}return cachedDirectiveDefs},pipeDefs=()=>{if(USE_RUNTIME_DEPS_TRACKER_FOR_JIT){if(ngDevMode)for(const rawDep of imports)verifyStandaloneImport(rawDep,type);if(!isComponent(type))return[];return[...depsTracker.getStandaloneComponentScope(type,imports).compilation.pipes].map((p=>getPipeDef$1(p))).filter((d=>null!==d))}if(null===cachedPipeDefs){cachedPipeDefs=[];const seen=new Set;for(const rawDep of imports){const dep=resolveForwardRef(rawDep);if(!seen.has(dep))if(seen.add(dep),getNgModuleDef(dep)){const scope=transitiveScopesFor(dep);for(const pipe of scope.exported.pipes){const def=getPipeDef$1(pipe);def&&!seen.has(pipe)&&(seen.add(pipe),cachedPipeDefs.push(def))}}else{const def=getPipeDef$1(dep);def&&cachedPipeDefs.push(def)}}}return cachedPipeDefs};return{directiveDefs,pipeDefs}}(type,imports);ngComponentDef.directiveDefs=directiveDefs,ngComponentDef.pipeDefs=pipeDefs,ngComponentDef.dependencies=()=>imports.map(resolveForwardRef)}}finally{compilationDepth--}if(0===compilationDepth&&function flushModuleScopingQueueAsMuchAsPossible(){if(!flushingModuleQueue){flushingModuleQueue=!0;try{for(let i=moduleQueue.length-1;i>=0;i--){const{moduleType,ngModule}=moduleQueue[i];ngModule.declarations&&ngModule.declarations.every(isResolvedDeclaration)&&(moduleQueue.splice(i,1),setScopeOnDeclaredComponents(moduleType,ngModule))}}finally{flushingModuleQueue=!1}}}(),function hasSelectorScope(component){return void 0!==component.ngSelectorScope}(type)){const scopes=transitiveScopesFor(type.ngSelectorScope);patchComponentDefWithScope(ngComponentDef,scopes)}if(metadata.schemas){if(!metadata.standalone)throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);ngComponentDef.schemas=metadata.schemas}else metadata.standalone&&(ngComponentDef.schemas=[])}return ngComponentDef},configurable:!!ngDevMode})}function compileDirective(type,directive){let ngDirectiveDef=null;addDirectiveFactoryDef(type,directive||{}),Object.defineProperty(type,NG_DIR_DEF,{get:()=>{if(null===ngDirectiveDef){const meta=getDirectiveMetadata(type,directive||{}),compiler=getCompilerFacade({usage:0,kind:"directive",type});ngDirectiveDef=compiler.compileDirective(angularCoreEnv,meta.sourceMapUrl,meta.metadata)}return ngDirectiveDef},configurable:!!ngDevMode})}function getDirectiveMetadata(type,metadata){const name=type&&type.name,sourceMapUrl=`ng:///${name}/ɵdir.js`,compiler=getCompilerFacade({usage:0,kind:"directive",type}),facade=directiveMetadata(type,metadata);return facade.typeSourceSpan=compiler.createParseSourceSpan("Directive",name,sourceMapUrl),facade.usesInheritance&&addDirectiveDefToUndecoratedParents(type),{metadata:facade,sourceMapUrl}}function addDirectiveFactoryDef(type,metadata){let ngFactoryDef=null;Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const meta=getDirectiveMetadata(type,metadata),compiler=getCompilerFacade({usage:0,kind:"directive",type});ngFactoryDef=compiler.compileFactory(angularCoreEnv,`ng:///${type.name}/ɵfac.js`,{name:meta.metadata.name,type:meta.metadata.type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Directive})}return ngFactoryDef},configurable:!!ngDevMode})}function extendsDirectlyFromObject(type){return Object.getPrototypeOf(type.prototype)===Object.prototype}function directiveMetadata(type,metadata){const reflect=getReflect(),propMetadata=reflect.ownPropMetadata(type);return{name:type.name,type,selector:void 0!==metadata.selector?metadata.selector:null,host:metadata.host||EMPTY_OBJ,propMetadata,inputs:metadata.inputs||EMPTY_ARRAY,outputs:metadata.outputs||EMPTY_ARRAY,queries:extractQueriesMetadata(type,propMetadata,isContentQuery),lifecycle:{usesOnChanges:reflect.hasLifecycleHook(type,"ngOnChanges")},typeSourceSpan:null,usesInheritance:!extendsDirectlyFromObject(type),exportAs:(exportAs=metadata.exportAs,void 0===exportAs?null:splitByComma(exportAs)),providers:metadata.providers||null,viewQueries:extractQueriesMetadata(type,propMetadata,isViewQuery),isStandalone:!!metadata.standalone,isSignal:!!metadata.signals,hostDirectives:metadata.hostDirectives?.map((directive=>"function"==typeof directive?{directive}:directive))||null};var exportAs}function addDirectiveDefToUndecoratedParents(type){const objPrototype=Object.prototype;let parent=Object.getPrototypeOf(type.prototype).constructor;for(;parent&&parent!==objPrototype;)getDirectiveDef(parent)||getComponentDef(parent)||!shouldAddAbstractDirective(parent)||compileDirective(parent,null),parent=Object.getPrototypeOf(parent)}function convertToR3QueryMetadata(propertyName,ann){return{propertyName,predicate:(selector=ann.selector,"string"==typeof selector?splitByComma(selector):resolveForwardRef(selector)),descendants:ann.descendants,first:ann.first,read:ann.read?ann.read:null,static:!!ann.static,emitDistinctChangesOnly:!!ann.emitDistinctChangesOnly,isSignal:!!ann.isSignal};var selector}function extractQueriesMetadata(type,propMetadata,isQueryAnn){const queriesMeta=[];for(const field in propMetadata)if(propMetadata.hasOwnProperty(field)){const annotations=propMetadata[field];annotations.forEach((ann=>{if(isQueryAnn(ann)){if(!ann.selector)throw new Error(`Can't construct a query for the property "${field}" of "${stringifyForError(type)}" since the query selector wasn't defined.`);if(annotations.some(isInputAnnotation))throw new Error("Cannot combine @Input decorators with query decorators");queriesMeta.push(convertToR3QueryMetadata(field,ann))}}))}return queriesMeta}function isContentQuery(value){const name=value.ngMetadataName;return"ContentChild"===name||"ContentChildren"===name}function isViewQuery(value){const name=value.ngMetadataName;return"ViewChild"===name||"ViewChildren"===name}function isInputAnnotation(value){return"Input"===value.ngMetadataName}function splitByComma(value){return value.split(",").map((piece=>piece.trim()))}const LIFECYCLE_HOOKS=["ngOnChanges","ngOnInit","ngOnDestroy","ngDoCheck","ngAfterViewInit","ngAfterViewChecked","ngAfterContentInit","ngAfterContentChecked"];function shouldAddAbstractDirective(type){const reflect=getReflect();if(LIFECYCLE_HOOKS.some((hookName=>reflect.hasLifecycleHook(type,hookName))))return!0;const propMetadata=reflect.propMetadata(type);for(const field in propMetadata){const annotations=propMetadata[field];for(let i=0;i<annotations.length;i++){const current=annotations[i],metadataName=current.ngMetadataName;if(isInputAnnotation(current)||isContentQuery(current)||isViewQuery(current)||"Output"===metadataName||"HostBinding"===metadataName||"HostListener"===metadataName)return!0}}return!1}function getPipeMetadata(type,meta){return{type,name:type.name,pipeName:meta.name,pure:void 0===meta.pure||meta.pure,isStandalone:!!meta.standalone}}const Directive=makeDecorator("Directive",((dir={})=>dir),void 0,void 0,((type,meta)=>compileDirective(type,meta))),Component=makeDecorator("Component",((c={})=>({changeDetection:ChangeDetectionStrategy.Default,...c})),Directive,void 0,((type,meta)=>compileComponent(type,meta))),Pipe=makeDecorator("Pipe",(p=>({pure:!0,...p})),void 0,void 0,((type,meta)=>function compilePipe(type,meta){let ngPipeDef=null,ngFactoryDef=null;Object.defineProperty(type,NG_FACTORY_DEF,{get:()=>{if(null===ngFactoryDef){const metadata=getPipeMetadata(type,meta),compiler=getCompilerFacade({usage:0,kind:"pipe",type:metadata.type});ngFactoryDef=compiler.compileFactory(angularCoreEnv,`ng:///${metadata.name}/ɵfac.js`,{name:metadata.name,type:metadata.type,typeArgumentCount:0,deps:reflectDependencies(type),target:compiler.FactoryTarget.Pipe})}return ngFactoryDef},configurable:!!ngDevMode}),Object.defineProperty(type,NG_PIPE_DEF,{get:()=>{if(null===ngPipeDef){const metadata=getPipeMetadata(type,meta),compiler=getCompilerFacade({usage:0,kind:"pipe",type:metadata.type});ngPipeDef=compiler.compilePipe(angularCoreEnv,`ng:///${metadata.name}/ɵpipe.js`,metadata)}return ngPipeDef},configurable:!!ngDevMode})}(type,meta))),Input=makePropDecorator("Input",(arg=>arg?"string"==typeof arg?{alias:arg}:arg:{})),NgModule=(makePropDecorator("Output",(alias=>({alias}))),makePropDecorator("HostBinding",(hostPropertyName=>({hostPropertyName}))),makePropDecorator("HostListener",((eventName,args)=>({eventName,args}))),makeDecorator("NgModule",(ngModule=>ngModule),void 0,void 0,((type,meta)=>compileNgModule(type,meta))));class Version{constructor(full){this.full=full;const parts=full.split(".");this.major=parts[0],this.minor=parts[1],this.patch=parts.slice(2).join(".")}}new Version("17.3.11");class Console{log(message){console.log(message)}warn(message){console.warn(message)}static#_=this.ɵfac=function Console_Factory(t){return new(t||Console)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:Console,factory:Console.ɵfac,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(Console,[{type:Injectable,args:[{providedIn:"platform"}]}],null,null);let frameworkDIDebugData=new class DIDebugData{constructor(){this.resolverToTokenToDependencies=new WeakMap,this.resolverToProviders=new WeakMap,this.standaloneInjectorToComponent=new WeakMap}reset(){this.resolverToTokenToDependencies=new WeakMap,this.resolverToProviders=new WeakMap,this.standaloneInjectorToComponent=new WeakMap}};function getFrameworkDIDebugData(){return frameworkDIDebugData}function setupFrameworkInjectorProfiler(){frameworkDIDebugData.reset(),setInjectorProfiler((injectorProfilerEvent=>function handleInjectorProfilerEvent(injectorProfilerEvent){const{context,type}=injectorProfilerEvent;0===type?function handleInjectEvent(context,data){const diResolver=getDIResolver(context.injector);null===diResolver&&throwError("An Inject event must be run within an injection context.");const diResolverToInstantiatedToken=frameworkDIDebugData.resolverToTokenToDependencies;diResolverToInstantiatedToken.has(diResolver)||diResolverToInstantiatedToken.set(diResolver,new WeakMap);if(!function canBeHeldWeakly(value){return null!==value&&("object"==typeof value||"function"==typeof value||"symbol"==typeof value)}(context.token))return;const instantiatedTokenToDependencies=diResolverToInstantiatedToken.get(diResolver);instantiatedTokenToDependencies.has(context.token)||instantiatedTokenToDependencies.set(context.token,[]);const{token,value,flags}=data;assertDefined(context.token,"Injector profiler context token is undefined.");const dependencies=instantiatedTokenToDependencies.get(context.token);assertDefined(dependencies,"Could not resolve dependencies for token."),context.injector instanceof NodeInjector?dependencies.push({token,value,flags,injectedIn:getNodeInjectorContext(context.injector)}):dependencies.push({token,value,flags})}(context,injectorProfilerEvent.service):1===type?function handleInstanceCreatedByInjectorEvent(context,data){const{value}=data;null===getDIResolver(context.injector)&&throwError("An InjectorCreatedInstance event must be run within an injection context.");let standaloneComponent;"object"==typeof value&&(standaloneComponent=value?.constructor);if(void 0===standaloneComponent||!function isStandaloneComponent(value){const def=getComponentDef(value);return!!def?.standalone}(standaloneComponent))return;const environmentInjector=context.injector.get(EnvironmentInjector,null,{optional:!0});if(null===environmentInjector)return;const{standaloneInjectorToComponent}=frameworkDIDebugData;if(standaloneInjectorToComponent.has(environmentInjector))return;standaloneInjectorToComponent.set(environmentInjector,standaloneComponent)}(context,injectorProfilerEvent.instance):2===type&&function handleProviderConfiguredEvent(context,data){const{resolverToProviders}=frameworkDIDebugData;let diResolver;diResolver=context?.injector instanceof NodeInjector?getNodeInjectorTNode(context.injector):context.injector;null===diResolver&&throwError("A ProviderConfigured event must be run within an injection context.");resolverToProviders.has(diResolver)||resolverToProviders.set(diResolver,[]);resolverToProviders.get(diResolver).push(data)}(context,injectorProfilerEvent.providerRecord)}(injectorProfilerEvent)))}function getNodeInjectorContext(injector){injector instanceof NodeInjector||throwError("getNodeInjectorContext must be called with a NodeInjector");const lView=getNodeInjectorLView(injector),tNode=getNodeInjectorTNode(injector);if(null!==tNode)return assertTNodeForLView(tNode,lView),{lView,tNode}}function getDIResolver(injector){let diResolver=null;return void 0===injector||(diResolver=injector instanceof NodeInjector?getNodeInjectorLView(injector):injector),diResolver}function getProviderImportPaths(providerImportsContainer){const providerToPath=new Map,visitor=function walkProviderTreeToDiscoverImportPaths(providerToPath,visitedContainers){return(provider,container)=>{if(providerToPath.has(provider)||providerToPath.set(provider,[container]),!visitedContainers.has(container))for(const prov of providerToPath.keys()){const existingImportPath=providerToPath.get(prov);let containerDef=getInjectorDef(container);if(!containerDef){containerDef=getInjectorDef(container.ngModule)}if(!containerDef)return;const lastContainerAddedToPath=existingImportPath[0];let isNextStepInPath=!1;deepForEach(containerDef.imports,(moduleImport=>{isNextStepInPath||(isNextStepInPath=moduleImport.ngModule===lastContainerAddedToPath||moduleImport===lastContainerAddedToPath,isNextStepInPath&&providerToPath.get(prov)?.unshift(container))}))}visitedContainers.add(container)}}(providerToPath,new Set);return walkProviderTree(providerImportsContainer,visitor,[],new Set),providerToPath}function getEnvironmentInjectorProviders(injector){const providerRecordsWithoutImportPaths=getFrameworkDIDebugData().resolverToProviders.get(injector)??[];if(function isPlatformInjector(injector){return injector instanceof R3Injector&&injector.scopes.has("platform")}(injector))return providerRecordsWithoutImportPaths;const providerImportsContainer=function getProviderImportsContainer(injector){const{standaloneInjectorToComponent}=getFrameworkDIDebugData();if(standaloneInjectorToComponent.has(injector))return standaloneInjectorToComponent.get(injector);const defTypeRef=injector.get(NgModuleRef$1,null,{self:!0,optional:!0});return null===defTypeRef||null===defTypeRef.instance?null:defTypeRef.instance.constructor}(injector);if(null===providerImportsContainer)return providerRecordsWithoutImportPaths;const providerToPath=getProviderImportPaths(providerImportsContainer),providerRecords=[];for(const providerRecord of providerRecordsWithoutImportPaths){const provider=providerRecord.provider,token=provider.provide;if(token===ENVIRONMENT_INITIALIZER||token===INJECTOR_DEF_TYPES)continue;let importPath=providerToPath.get(provider)??[];const def=getComponentDef(providerImportsContainer);!!def?.standalone&&(importPath=[providerImportsContainer,...importPath]),providerRecords.push({...providerRecord,importPath})}return providerRecords}function getInjectorResolutionPath(injector){const resolutionPath=[injector];return getInjectorResolutionPathHelper(injector,resolutionPath),resolutionPath}function getInjectorResolutionPathHelper(injector,resolutionPath){const parent=function getInjectorParent(injector){if(injector instanceof R3Injector)return injector.parent;let tNode,lView;if(injector instanceof NodeInjector)tNode=getNodeInjectorTNode(injector),lView=getNodeInjectorLView(injector);else{if(injector instanceof NullInjector)return null;if(injector instanceof ChainedInjector)return injector.parentInjector;throwError("getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector, ChainedInjector")}const parentLocation=getParentInjectorLocation(tNode,lView);if(hasParentInjector(parentLocation)){const parentInjectorIndex=getParentInjectorIndex(parentLocation),parentLView=getParentInjectorView(parentLocation,lView),parentTNode=parentLView[TVIEW].data[parentInjectorIndex+8];return new NodeInjector(parentTNode,parentLView)}{const chainedInjector=lView[INJECTOR],injectorParent=chainedInjector.injector?.parent;if(injectorParent instanceof NodeInjector)return injectorParent}return null}(injector);if(null===parent){if(injector instanceof NodeInjector){const firstInjector=resolutionPath[0];if(firstInjector instanceof NodeInjector){const moduleInjector=function getModuleInjectorOfNodeInjector(injector){let lView;injector instanceof NodeInjector?lView=getNodeInjectorLView(injector):throwError("getModuleInjectorOfNodeInjector must be called with a NodeInjector");const inj=lView[INJECTOR],moduleInjector=inj instanceof ChainedInjector?inj.parentInjector:inj.parent;moduleInjector||throwError("NodeInjector must have some connection to the module injector tree");return moduleInjector}(firstInjector);null===moduleInjector&&throwError("NodeInjector must have some connection to the module injector tree"),resolutionPath.push(moduleInjector),getInjectorResolutionPathHelper(moduleInjector,resolutionPath)}return resolutionPath}}else resolutionPath.push(parent),getInjectorResolutionPathHelper(parent,resolutionPath);return resolutionPath}const GLOBAL_PUBLISH_EXPANDO_KEY="ng",globalUtilsFunctions={ɵgetDependenciesFromInjectable:function getDependenciesFromInjectable(injector,token){const instance=injector.get(token,null,{self:!0,optional:!0});if(null===instance)throw new Error(`Unable to determine instance of ${token} in given injector`);const unformattedDependencies=function getDependenciesForTokenInInjector(token,injector){const{resolverToTokenToDependencies}=getFrameworkDIDebugData();if(!(injector instanceof NodeInjector))return resolverToTokenToDependencies.get(injector)?.get?.(token)??[];const lView=getNodeInjectorLView(injector),tokenDependencyMap=resolverToTokenToDependencies.get(lView),dependencies=tokenDependencyMap?.get(token)??[];return dependencies.filter((dependency=>{const dependencyNode=dependency.injectedIn?.tNode;if(void 0===dependencyNode)return!1;const instanceNode=getNodeInjectorTNode(injector);return assertTNode(dependencyNode),assertTNode(instanceNode),dependencyNode===instanceNode}))}(token,injector),resolutionPath=getInjectorResolutionPath(injector);return{instance,dependencies:unformattedDependencies.map((dep=>{const formattedDependency={value:dep.value},flags=dep.flags;formattedDependency.flags={optional:!(8&~flags),host:!(1&~flags),self:!(2&~flags),skipSelf:!(4&~flags)};for(let i=0;i<resolutionPath.length;i++){const injectorToCheck=resolutionPath[i];if(0===i&&formattedDependency.flags.skipSelf)continue;if(formattedDependency.flags.host&&injectorToCheck instanceof EnvironmentInjector)break;if(null!==injectorToCheck.get(dep.token,null,{self:!0,optional:!0})){if(formattedDependency.flags.host){null!==resolutionPath[0].get(dep.token,null,{...formattedDependency.flags,optional:!0})&&(formattedDependency.providedIn=injectorToCheck);break}formattedDependency.providedIn=injectorToCheck;break}if(0===i&&formattedDependency.flags.self)break}return dep.token&&(formattedDependency.token=dep.token),formattedDependency}))}},ɵgetInjectorProviders:function getInjectorProviders(injector){return injector instanceof NodeInjector?function getNodeInjectorProviders(injector){const diResolver=getNodeInjectorTNode(injector),{resolverToProviders}=getFrameworkDIDebugData();return resolverToProviders.get(diResolver)??[]}(injector):injector instanceof EnvironmentInjector?getEnvironmentInjectorProviders(injector):void throwError("getInjectorProviders only supports NodeInjector and EnvironmentInjector")},ɵgetInjectorResolutionPath:getInjectorResolutionPath,ɵgetInjectorMetadata:function getInjectorMetadata(injector){if(injector instanceof NodeInjector){const lView=getNodeInjectorLView(injector),tNode=getNodeInjectorTNode(injector);return assertTNodeForLView(tNode,lView),{type:"element",source:getNativeByTNode(tNode,lView)}}return injector instanceof R3Injector?{type:"environment",source:injector.source??null}:injector instanceof NullInjector?{type:"null",source:null}:null},ɵsetProfiler:profiler=>{profilerCallback=profiler},getDirectiveMetadata:function getDirectiveMetadata$1(directiveOrComponentInstance){const{constructor}=directiveOrComponentInstance;if(!constructor)throw new Error("Unable to find the instance constructor");const componentDef=getComponentDef(constructor);if(componentDef){return{inputs:extractInputDebugMetadata(componentDef.inputs),outputs:componentDef.outputs,encapsulation:componentDef.encapsulation,changeDetection:componentDef.onPush?ChangeDetectionStrategy.OnPush:ChangeDetectionStrategy.Default}}const directiveDef=getDirectiveDef(constructor);if(directiveDef){return{inputs:extractInputDebugMetadata(directiveDef.inputs),outputs:directiveDef.outputs}}return null},getComponent:getComponent$1,getContext,getListeners,getOwningComponent,getHostElement,getInjector,getRootComponents,getDirectives:function getDirectives(node){if(node instanceof Text)return[];const context=getLContext(node),lView=context?context.lView:null;if(null===lView)return[];const tView=lView[TVIEW],nodeIndex=context.nodeIndex;return tView?.data[nodeIndex]?(void 0===context.directives&&(context.directives=getDirectivesAtNodeIndex(nodeIndex,lView)),null===context.directives?[]:[...context.directives]):[]},applyChanges:function applyChanges(component){ngDevMode&&assertDefined(component,"component"),markViewDirty(getComponentViewByInstance(component)),getRootComponents(component).forEach((rootComponent=>function detectChanges(component){const view=getComponentViewByInstance(component);view[FLAGS]|=1024,detectChangesInternal(view)}(rootComponent)))},isSignal};let _published=!1;function publishGlobalUtil(name,fn){if("undefined"==typeof COMPILED||!COMPILED){const w=_global;ngDevMode&&assertDefined(fn,"function not defined"),w[GLOBAL_PUBLISH_EXPANDO_KEY]??={},w[GLOBAL_PUBLISH_EXPANDO_KEY][name]=fn}}const TESTABILITY=new InjectionToken(""),TESTABILITY_GETTER=new InjectionToken("");class Testability{constructor(_ngZone,registry,testabilityGetter){this._ngZone=_ngZone,this.registry=registry,this._pendingCount=0,this._isZoneStable=!0,this._callbacks=[],this.taskTrackingZone=null,_testabilityGetter||(!function setTestabilityGetter(getter){_testabilityGetter=getter}(testabilityGetter),testabilityGetter.addToWindow(registry)),this._watchAngularEvents(),_ngZone.run((()=>{this.taskTrackingZone="undefined"==typeof Zone?null:Zone.current.get("TaskTrackingZone")}))}_watchAngularEvents(){this._ngZone.onUnstable.subscribe({next:()=>{this._isZoneStable=!1}}),this._ngZone.runOutsideAngular((()=>{this._ngZone.onStable.subscribe({next:()=>{NgZone.assertNotInAngularZone(),queueMicrotask((()=>{this._isZoneStable=!0,this._runCallbacksIfReady()}))}})}))}increasePendingRequestCount(){return this._pendingCount+=1,this._pendingCount}decreasePendingRequestCount(){if(this._pendingCount-=1,this._pendingCount<0)throw new Error("pending async requests below zero");return this._runCallbacksIfReady(),this._pendingCount}isStable(){return this._isZoneStable&&0===this._pendingCount&&!this._ngZone.hasPendingMacrotasks}_runCallbacksIfReady(){if(this.isStable())queueMicrotask((()=>{for(;0!==this._callbacks.length;){let cb=this._callbacks.pop();clearTimeout(cb.timeoutId),cb.doneCb()}}));else{let pending=this.getPendingTasks();this._callbacks=this._callbacks.filter((cb=>!cb.updateCb||!cb.updateCb(pending)||(clearTimeout(cb.timeoutId),!1)))}}getPendingTasks(){return this.taskTrackingZone?this.taskTrackingZone.macroTasks.map((t=>({source:t.source,creationLocation:t.creationLocation,data:t.data}))):[]}addCallback(cb,timeout,updateCb){let timeoutId=-1;timeout&&timeout>0&&(timeoutId=setTimeout((()=>{this._callbacks=this._callbacks.filter((cb=>cb.timeoutId!==timeoutId)),cb()}),timeout)),this._callbacks.push({doneCb:cb,timeoutId,updateCb})}whenStable(doneCb,timeout,updateCb){if(updateCb&&!this.taskTrackingZone)throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?');this.addCallback(doneCb,timeout,updateCb),this._runCallbacksIfReady()}getPendingRequestCount(){return this._pendingCount}registerApplication(token){this.registry.registerApplication(token,this)}unregisterApplication(token){this.registry.unregisterApplication(token)}findProviders(using,provider,exactMatch){return[]}static#_=this.ɵfac=function Testability_Factory(t){return new(t||Testability)(ɵɵinject(NgZone),ɵɵinject(TestabilityRegistry),ɵɵinject(TESTABILITY_GETTER))};static#_2=this.ɵprov=ɵɵdefineInjectable({token:Testability,factory:Testability.ɵfac})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(Testability,[{type:Injectable}],(()=>[{type:NgZone},{type:TestabilityRegistry},{type:void 0,decorators:[{type:Inject,args:[TESTABILITY_GETTER]}]}]),null);class TestabilityRegistry{constructor(){this._applications=new Map}registerApplication(token,testability){this._applications.set(token,testability)}unregisterApplication(token){this._applications.delete(token)}unregisterAllApplications(){this._applications.clear()}getTestability(elem){return this._applications.get(elem)||null}getAllTestabilities(){return Array.from(this._applications.values())}getAllRootElements(){return Array.from(this._applications.keys())}findTestabilityInTree(elem,findInAncestors=!0){return _testabilityGetter?.findTestabilityInTree(this,elem,findInAncestors)??null}static#_=this.ɵfac=function TestabilityRegistry_Factory(t){return new(t||TestabilityRegistry)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:TestabilityRegistry,factory:TestabilityRegistry.ɵfac,providedIn:"platform"})}let _testabilityGetter;function isPromise(obj){return!!obj&&"function"==typeof obj.then}function isSubscribable(obj){return!!obj&&"function"==typeof obj.subscribe}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(TestabilityRegistry,[{type:Injectable,args:[{providedIn:"platform"}]}],null,null);const APP_INITIALIZER=new InjectionToken(ngDevMode?"Application Initializer":"");class ApplicationInitStatus{constructor(){if(this.initialized=!1,this.done=!1,this.donePromise=new Promise(((res,rej)=>{this.resolve=res,this.reject=rej})),this.appInits=inject(APP_INITIALIZER,{optional:!0})??[],("undefined"==typeof ngDevMode||ngDevMode)&&!Array.isArray(this.appInits))throw new RuntimeError(-209,`Unexpected type of the \`APP_INITIALIZER\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \`APP_INITIALIZER\` token is configured as a \`multi: true\` provider.`)}runInitializers(){if(this.initialized)return;const asyncInitPromises=[];for(const appInits of this.appInits){const initResult=appInits();if(isPromise(initResult))asyncInitPromises.push(initResult);else if(isSubscribable(initResult)){const observableAsPromise=new Promise(((resolve,reject)=>{initResult.subscribe({complete:resolve,error:reject})}));asyncInitPromises.push(observableAsPromise)}}const complete=()=>{this.done=!0,this.resolve()};Promise.all(asyncInitPromises).then((()=>{complete()})).catch((e=>{this.reject(e)})),0===asyncInitPromises.length&&complete(),this.initialized=!0}static#_=this.ɵfac=function ApplicationInitStatus_Factory(t){return new(t||ApplicationInitStatus)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:ApplicationInitStatus,factory:ApplicationInitStatus.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ApplicationInitStatus,[{type:Injectable,args:[{providedIn:"root"}]}],(()=>[]),null);const APP_BOOTSTRAP_LISTENER=new InjectionToken(ngDevMode?"appBootstrapListener":"");function publishDefaultGlobalUtils(){ngDevMode&&function publishDefaultGlobalUtils$1(){if(!_published){_published=!0,"undefined"!=typeof window&&setupFrameworkInjectorProfiler();for(const[methodName,method]of Object.entries(globalUtilsFunctions))publishGlobalUtil(methodName,method)}}()}function publishSignalConfiguration(){!function setThrowInvalidWriteToSignalError(fn){throwInvalidWriteToSignalErrorFn=fn}((()=>{throw new RuntimeError(600,ngDevMode&&"Writing to signals is not allowed in a `computed` or an `effect` by default. Use `allowSignalWrites` in the `CreateEffectOptions` to enable this inside effects.")}))}function _callAndReportToErrorHandler(errorHandler,ngZone,callback){try{const result=callback();return isPromise(result)?result.catch((e=>{throw ngZone.runOutsideAngular((()=>errorHandler.handleError(e))),e})):result}catch(e){throw ngZone.runOutsideAngular((()=>errorHandler.handleError(e))),e}}function optionsReducer(dst,objs){return Array.isArray(objs)?objs.reduce(optionsReducer,dst):{...dst,...objs}}class ApplicationRef{constructor(){this._bootstrapListeners=[],this._runningTick=!1,this._destroyed=!1,this._destroyListeners=[],this._views=[],this.internalErrorHandler=inject(INTERNAL_APPLICATION_ERROR_HANDLER),this.afterRenderEffectManager=inject(AfterRenderEventManager),this.externalTestViews=new Set,this.beforeRender=new Subject.B,this.afterTick=new Subject.B,this.componentTypes=[],this.components=[],this.isStable=inject(PendingTasks).hasPendingTasks.pipe((0,map.T)((pending=>!pending))),this._injector=inject(EnvironmentInjector)}get destroyed(){return this._destroyed}get injector(){return this._injector}bootstrap(componentOrFactory,rootSelectorOrNode){("undefined"==typeof ngDevMode||ngDevMode)&&this.warnIfDestroyed();const isComponentFactory=componentOrFactory instanceof ComponentFactory$1;if(!this._injector.get(ApplicationInitStatus).done){const standalone=!isComponentFactory&&isStandalone(componentOrFactory),errorMessage=("undefined"==typeof ngDevMode||ngDevMode)&&"Cannot bootstrap as there are still asynchronous initializers running."+(standalone?"":" Bootstrap components in the `ngDoBootstrap` method of the root module.");throw new RuntimeError(405,errorMessage)}let componentFactory;if(isComponentFactory)componentFactory=componentOrFactory;else{componentFactory=this._injector.get(ComponentFactoryResolver$1).resolveComponentFactory(componentOrFactory)}this.componentTypes.push(componentFactory.componentType);const ngModule=function isBoundToModule(cf){return cf.isBoundToModule}(componentFactory)?void 0:this._injector.get(NgModuleRef$1),selectorOrNode=rootSelectorOrNode||componentFactory.selector,compRef=componentFactory.create(Injector.NULL,[],selectorOrNode,ngModule),nativeElement=compRef.location.nativeElement,testability=compRef.injector.get(TESTABILITY,null);if(testability?.registerApplication(nativeElement),compRef.onDestroy((()=>{this.detachView(compRef.hostView),remove(this.components,compRef),testability?.unregisterApplication(nativeElement)})),this._loadComponent(compRef),"undefined"==typeof ngDevMode||ngDevMode){this._injector.get(Console).log("Angular is running in development mode.")}return compRef}tick(){this._tick(!0)}_tick(refreshViews){if(("undefined"==typeof ngDevMode||ngDevMode)&&this.warnIfDestroyed(),this._runningTick)throw new RuntimeError(101,ngDevMode&&"ApplicationRef.tick is called recursively");const prevConsumer=setActiveConsumer(null);try{if(this._runningTick=!0,this.detectChangesInAttachedViews(refreshViews),"undefined"==typeof ngDevMode||ngDevMode)for(let view of this._views)view.checkNoChanges()}catch(e){this.internalErrorHandler(e)}finally{this.afterTick.next(),this._runningTick=!1,setActiveConsumer(prevConsumer)}}detectChangesInAttachedViews(refreshViews){let runs=0;const afterRenderEffectManager=this.afterRenderEffectManager;for(;;){if(runs===MAXIMUM_REFRESH_RERUNS)throw new RuntimeError(103,ngDevMode&&"Infinite change detection while refreshing application views. Ensure afterRender or queueStateUpdate hooks are not continuously causing updates.");if(refreshViews){const isFirstPass=0===runs;this.beforeRender.next(isFirstPass);for(let{_lView,notifyErrorHandler}of this._views)detectChangesInViewIfRequired(_lView,isFirstPass,notifyErrorHandler)}if(runs++,afterRenderEffectManager.executeInternalCallbacks(),![...this.externalTestViews.keys(),...this._views].some((({_lView})=>shouldRecheckView(_lView)))&&(afterRenderEffectManager.execute(),![...this.externalTestViews.keys(),...this._views].some((({_lView})=>shouldRecheckView(_lView)))))break}}attachView(viewRef){("undefined"==typeof ngDevMode||ngDevMode)&&this.warnIfDestroyed();const view=viewRef;this._views.push(view),view.attachToAppRef(this)}detachView(viewRef){("undefined"==typeof ngDevMode||ngDevMode)&&this.warnIfDestroyed();const view=viewRef;remove(this._views,view),view.detachFromAppRef()}_loadComponent(componentRef){this.attachView(componentRef.hostView),this.tick(),this.components.push(componentRef);const listeners=this._injector.get(APP_BOOTSTRAP_LISTENER,[]);if(ngDevMode&&!Array.isArray(listeners))throw new RuntimeError(-209,`Unexpected type of the \`APP_BOOTSTRAP_LISTENER\` token value (expected an array, but got ${typeof listeners}). Please check that the \`APP_BOOTSTRAP_LISTENER\` token is configured as a \`multi: true\` provider.`);[...this._bootstrapListeners,...listeners].forEach((listener=>listener(componentRef)))}ngOnDestroy(){if(!this._destroyed)try{this._destroyListeners.forEach((listener=>listener())),this._views.slice().forEach((view=>view.destroy()))}finally{this._destroyed=!0,this._views=[],this._bootstrapListeners=[],this._destroyListeners=[]}}onDestroy(callback){return("undefined"==typeof ngDevMode||ngDevMode)&&this.warnIfDestroyed(),this._destroyListeners.push(callback),()=>remove(this._destroyListeners,callback)}destroy(){if(this._destroyed)throw new RuntimeError(406,ngDevMode&&"This instance of the `ApplicationRef` has already been destroyed.");const injector=this._injector;injector.destroy&&!injector.destroyed&&injector.destroy()}get viewCount(){return this._views.length}warnIfDestroyed(){("undefined"==typeof ngDevMode||ngDevMode)&&this._destroyed&&console.warn(formatRuntimeError(406,"This instance of the `ApplicationRef` has already been destroyed."))}static#_=this.ɵfac=function ApplicationRef_Factory(t){return new(t||ApplicationRef)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:ApplicationRef,factory:ApplicationRef.ɵfac,providedIn:"root"})}function remove(list,el){const index=list.indexOf(el);index>-1&&list.splice(index,1)}function detectChangesInViewIfRequired(lView,isFirstPass,notifyErrorHandler){(isFirstPass||shouldRecheckView(lView))&&function detectChangesInView(lView,notifyErrorHandler,isFirstPass){let mode;isFirstPass?(mode=0,lView[FLAGS]|=1024):mode=64&lView[FLAGS]?0:1;detectChangesInternal(lView,notifyErrorHandler,mode)}(lView,notifyErrorHandler,isFirstPass)}function shouldRecheckView(view){return requiresRefreshOrTraversal(view)}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ApplicationRef,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);class ModuleWithComponentFactories{constructor(ngModuleFactory,componentFactories){this.ngModuleFactory=ngModuleFactory,this.componentFactories=componentFactories}}class Compiler{compileModuleSync(moduleType){return new NgModuleFactory(moduleType)}compileModuleAsync(moduleType){return Promise.resolve(this.compileModuleSync(moduleType))}compileModuleAndAllComponentsSync(moduleType){const ngModuleFactory=this.compileModuleSync(moduleType),componentFactories=maybeUnwrapFn(getNgModuleDef(moduleType).declarations).reduce(((factories,declaration)=>{const componentDef=getComponentDef(declaration);return componentDef&&factories.push(new ComponentFactory(componentDef)),factories}),[]);return new ModuleWithComponentFactories(ngModuleFactory,componentFactories)}compileModuleAndAllComponentsAsync(moduleType){return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType))}clearCache(){}clearCacheFor(type){}getModuleId(moduleType){}static#_=this.ɵfac=function Compiler_Factory(t){return new(t||Compiler)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:Compiler,factory:Compiler.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(Compiler,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const COMPILER_OPTIONS=new InjectionToken(ngDevMode?"compilerOptions":"");function compileNgModuleFactory(injector,options,moduleType){ngDevMode&&function assertNgModuleType(actual,msg="Type passed in is not NgModuleType, it does not have 'ɵmod' property."){getNgModuleDef(actual)||throwError(msg)}(moduleType);const moduleFactory=new NgModuleFactory(moduleType);if("undefined"!=typeof ngJitMode&&!ngJitMode)return Promise.resolve(moduleFactory);const compilerOptions=injector.get(COMPILER_OPTIONS,[]).concat(options);if(function setJitOptions(options){if(null!==jitOptions){if(options.defaultEncapsulation!==jitOptions.defaultEncapsulation)return void(ngDevMode&&console.error("Provided value for `defaultEncapsulation` can not be changed once it has been set."));if(options.preserveWhitespaces!==jitOptions.preserveWhitespaces)return void(ngDevMode&&console.error("Provided value for `preserveWhitespaces` can not be changed once it has been set."))}jitOptions=options}({defaultEncapsulation:_lastDefined(compilerOptions.map((opts=>opts.defaultEncapsulation))),preserveWhitespaces:_lastDefined(compilerOptions.map((opts=>opts.preserveWhitespaces)))}),function isComponentResourceResolutionQueueEmpty(){return 0===componentResourceResolutionQueue.size}())return Promise.resolve(moduleFactory);const compilerProviders=compilerOptions.flatMap((option=>option.providers??[]));if(0===compilerProviders.length)return Promise.resolve(moduleFactory);const compiler=getCompilerFacade({usage:0,kind:"NgModule",type:moduleType}),resourceLoader=Injector.create({providers:compilerProviders}).get(compiler.ResourceLoader);return resolveComponentResources((url=>Promise.resolve(resourceLoader.get(url)))).then((()=>moduleFactory))}function _lastDefined(args){for(let i=args.length-1;i>=0;i--)if(void 0!==args[i])return args[i]}class NgZoneChangeDetectionScheduler{constructor(){this.zone=inject(NgZone),this.applicationRef=inject(ApplicationRef)}initialize(){this._onMicrotaskEmptySubscription||(this._onMicrotaskEmptySubscription=this.zone.onMicrotaskEmpty.subscribe({next:()=>{this.zone.run((()=>{this.applicationRef.tick()}))}}))}ngOnDestroy(){this._onMicrotaskEmptySubscription?.unsubscribe()}static#_=this.ɵfac=function NgZoneChangeDetectionScheduler_Factory(t){return new(t||NgZoneChangeDetectionScheduler)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:NgZoneChangeDetectionScheduler,factory:NgZoneChangeDetectionScheduler.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(NgZoneChangeDetectionScheduler,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const PROVIDED_NG_ZONE=new InjectionToken("undefined"==typeof ngDevMode||ngDevMode?"provideZoneChangeDetection token":"");function internalProvideZoneChangeDetection(ngZoneFactory){return[{provide:NgZone,useFactory:ngZoneFactory},{provide:ENVIRONMENT_INITIALIZER,multi:!0,useFactory:()=>{const ngZoneChangeDetectionScheduler=inject(NgZoneChangeDetectionScheduler,{optional:!0});if(("undefined"==typeof ngDevMode||ngDevMode)&&null===ngZoneChangeDetectionScheduler)throw new RuntimeError(402,"A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the `BrowserModule` is imported.");return()=>ngZoneChangeDetectionScheduler.initialize()}},{provide:ENVIRONMENT_INITIALIZER,multi:!0,useFactory:()=>{const service=inject(ZoneStablePendingTask);return()=>{service.initialize()}}},{provide:INTERNAL_APPLICATION_ERROR_HANDLER,useFactory:ngZoneApplicationErrorHandlerFactory}]}function ngZoneApplicationErrorHandlerFactory(){const zone=inject(NgZone),userErrorHandler=inject(ErrorHandler);return e=>zone.runOutsideAngular((()=>userErrorHandler.handleError(e)))}function getNgZoneOptions(options){return{enableLongStackTrace:"undefined"!=typeof ngDevMode&&!!ngDevMode,shouldCoalesceEventChangeDetection:options?.eventCoalescing??!1,shouldCoalesceRunChangeDetection:options?.runCoalescing??!1}}class ZoneStablePendingTask{constructor(){this.subscription=new Subscription.yU,this.initialized=!1,this.zone=inject(NgZone),this.pendingTasks=inject(PendingTasks)}initialize(){if(this.initialized)return;this.initialized=!0;let task=null;this.zone.isStable||this.zone.hasPendingMacrotasks||this.zone.hasPendingMicrotasks||(task=this.pendingTasks.add()),this.zone.runOutsideAngular((()=>{this.subscription.add(this.zone.onStable.subscribe((()=>{NgZone.assertNotInAngularZone(),queueMicrotask((()=>{null===task||this.zone.hasPendingMacrotasks||this.zone.hasPendingMicrotasks||(this.pendingTasks.remove(task),task=null)}))})))})),this.subscription.add(this.zone.onUnstable.subscribe((()=>{NgZone.assertInAngularZone(),task??=this.pendingTasks.add()})))}ngOnDestroy(){this.subscription.unsubscribe()}static#_=this.ɵfac=function ZoneStablePendingTask_Factory(t){return new(t||ZoneStablePendingTask)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:ZoneStablePendingTask,factory:ZoneStablePendingTask.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ZoneStablePendingTask,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);const LOCALE_ID=new InjectionToken(ngDevMode?"LocaleId":"",{providedIn:"root",factory:()=>inject(LOCALE_ID,InjectFlags.Optional|InjectFlags.SkipSelf)||function getGlobalLocale(){return"undefined"!=typeof ngI18nClosureMode&&ngI18nClosureMode&&"undefined"!=typeof goog&&"en"!==goog.LOCALE?goog.LOCALE:"undefined"!=typeof $localize&&$localize.locale||"en-US"}()}),DEFAULT_CURRENCY_CODE=new InjectionToken(ngDevMode?"DefaultCurrencyCode":"",{providedIn:"root",factory:()=>"USD"});new InjectionToken(ngDevMode?"Translations":""),new InjectionToken(ngDevMode?"TranslationsFormat":"");var MissingTranslationStrategy;!function(MissingTranslationStrategy){MissingTranslationStrategy[MissingTranslationStrategy.Error=0]="Error",MissingTranslationStrategy[MissingTranslationStrategy.Warning=1]="Warning",MissingTranslationStrategy[MissingTranslationStrategy.Ignore=2]="Ignore"}(MissingTranslationStrategy||(MissingTranslationStrategy={}));const PLATFORM_DESTROY_LISTENERS=new InjectionToken(ngDevMode?"PlatformDestroyListeners":"");class PlatformRef{constructor(_injector){this._injector=_injector,this._modules=[],this._destroyListeners=[],this._destroyed=!1}bootstrapModuleFactory(moduleFactory,options){const ngZone=function getNgZone(ngZoneToUse="zone.js",options){return"noop"===ngZoneToUse?new NoopNgZone:"zone.js"===ngZoneToUse?new NgZone(options):ngZoneToUse}(options?.ngZone,getNgZoneOptions({eventCoalescing:options?.ngZoneEventCoalescing,runCoalescing:options?.ngZoneRunCoalescing}));return ngZone.run((()=>{const moduleRef=function createNgModuleRefWithProviders(moduleType,parentInjector,additionalProviders){return new NgModuleRef(moduleType,parentInjector,additionalProviders)}(moduleFactory.moduleType,this.injector,internalProvideZoneChangeDetection((()=>ngZone)));if(("undefined"==typeof ngDevMode||ngDevMode)&&null!==moduleRef.injector.get(PROVIDED_NG_ZONE,null))throw new RuntimeError(207,"`bootstrapModule` does not support `provideZoneChangeDetection`. Use `BootstrapOptions` instead.");const exceptionHandler=moduleRef.injector.get(ErrorHandler,null);if(("undefined"==typeof ngDevMode||ngDevMode)&&null===exceptionHandler)throw new RuntimeError(402,"No ErrorHandler. Is platform module (BrowserModule) included?");return ngZone.runOutsideAngular((()=>{const subscription=ngZone.onError.subscribe({next:error=>{exceptionHandler.handleError(error)}});moduleRef.onDestroy((()=>{remove(this._modules,moduleRef),subscription.unsubscribe()}))})),_callAndReportToErrorHandler(exceptionHandler,ngZone,(()=>{const initStatus=moduleRef.injector.get(ApplicationInitStatus);return initStatus.runInitializers(),initStatus.donePromise.then((()=>(setLocaleId(moduleRef.injector.get(LOCALE_ID,"en-US")||"en-US"),this._moduleDoBootstrap(moduleRef),moduleRef)))}))}))}bootstrapModule(moduleType,compilerOptions=[]){const options=optionsReducer({},compilerOptions);return compileNgModuleFactory(this.injector,options,moduleType).then((moduleFactory=>this.bootstrapModuleFactory(moduleFactory,options)))}_moduleDoBootstrap(moduleRef){const appRef=moduleRef.injector.get(ApplicationRef);if(moduleRef._bootstrapComponents.length>0)moduleRef._bootstrapComponents.forEach((f=>appRef.bootstrap(f)));else{if(!moduleRef.instance.ngDoBootstrap)throw new RuntimeError(-403,ngDevMode&&`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);moduleRef.instance.ngDoBootstrap(appRef)}this._modules.push(moduleRef)}onDestroy(callback){this._destroyListeners.push(callback)}get injector(){return this._injector}destroy(){if(this._destroyed)throw new RuntimeError(404,ngDevMode&&"The platform has already been destroyed!");this._modules.slice().forEach((module=>module.destroy())),this._destroyListeners.forEach((listener=>listener()));const destroyListeners=this._injector.get(PLATFORM_DESTROY_LISTENERS,null);destroyListeners&&(destroyListeners.forEach((listener=>listener())),destroyListeners.clear()),this._destroyed=!0}get destroyed(){return this._destroyed}static#_=this.ɵfac=function PlatformRef_Factory(t){return new(t||PlatformRef)(ɵɵinject(Injector))};static#_2=this.ɵprov=ɵɵdefineInjectable({token:PlatformRef,factory:PlatformRef.ɵfac,providedIn:"platform"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(PlatformRef,[{type:Injectable,args:[{providedIn:"platform"}]}],(()=>[{type:Injector}]),null);let _platformInjector=null;const ALLOW_MULTIPLE_PLATFORMS=new InjectionToken(ngDevMode?"AllowMultipleToken":"");function createPlatformInjector(providers=[],name){return Injector.create({name,providers:[{provide:INJECTOR_SCOPE,useValue:"platform"},{provide:PLATFORM_DESTROY_LISTENERS,useValue:new Set([()=>_platformInjector=null])},...providers]})}function getPlatform(){return _platformInjector?.get(PlatformRef)??null}function runPlatformInitializers(injector){const inits=injector.get(PLATFORM_INITIALIZER,null);inits?.forEach((init=>init()))}class ChangeDetectorRef{static#_=this.__NG_ELEMENT_ID__=injectChangeDetectorRef}function injectChangeDetectorRef(flags){return function createViewRef(tNode,lView,isPipe){if(isComponentHost(tNode)&&!isPipe){const componentView=getComponentLViewByIndex(tNode.index,lView);return new ViewRef$1(componentView,componentView)}if(47&tNode.type){const hostComponentView=lView[DECLARATION_COMPONENT_VIEW];return new ViewRef$1(hostComponentView,lView)}return null}(getCurrentTNode(),getLView(),!(16&~flags))}new Map;class DefaultIterableDifferFactory{constructor(){}supports(obj){return isListLikeIterable(obj)}create(trackByFn){return new DefaultIterableDiffer(trackByFn)}}const trackByIdentity=(index,item)=>item;class DefaultIterableDiffer{constructor(trackByFn){this.length=0,this._linkedRecords=null,this._unlinkedRecords=null,this._previousItHead=null,this._itHead=null,this._itTail=null,this._additionsHead=null,this._additionsTail=null,this._movesHead=null,this._movesTail=null,this._removalsHead=null,this._removalsTail=null,this._identityChangesHead=null,this._identityChangesTail=null,this._trackByFn=trackByFn||trackByIdentity}forEachItem(fn){let record;for(record=this._itHead;null!==record;record=record._next)fn(record)}forEachOperation(fn){let nextIt=this._itHead,nextRemove=this._removalsHead,addRemoveOffset=0,moveOffsets=null;for(;nextIt||nextRemove;){const record=!nextRemove||nextIt&&nextIt.currentIndex<getPreviousIndex(nextRemove,addRemoveOffset,moveOffsets)?nextIt:nextRemove,adjPreviousIndex=getPreviousIndex(record,addRemoveOffset,moveOffsets),currentIndex=record.currentIndex;if(record===nextRemove)addRemoveOffset--,nextRemove=nextRemove._nextRemoved;else if(nextIt=nextIt._next,null==record.previousIndex)addRemoveOffset++;else{moveOffsets||(moveOffsets=[]);const localMovePreviousIndex=adjPreviousIndex-addRemoveOffset,localCurrentIndex=currentIndex-addRemoveOffset;if(localMovePreviousIndex!=localCurrentIndex){for(let i=0;i<localMovePreviousIndex;i++){const offset=i<moveOffsets.length?moveOffsets[i]:moveOffsets[i]=0,index=offset+i;localCurrentIndex<=index&&index<localMovePreviousIndex&&(moveOffsets[i]=offset+1)}moveOffsets[record.previousIndex]=localCurrentIndex-localMovePreviousIndex}}adjPreviousIndex!==currentIndex&&fn(record,adjPreviousIndex,currentIndex)}}forEachPreviousItem(fn){let record;for(record=this._previousItHead;null!==record;record=record._nextPrevious)fn(record)}forEachAddedItem(fn){let record;for(record=this._additionsHead;null!==record;record=record._nextAdded)fn(record)}forEachMovedItem(fn){let record;for(record=this._movesHead;null!==record;record=record._nextMoved)fn(record)}forEachRemovedItem(fn){let record;for(record=this._removalsHead;null!==record;record=record._nextRemoved)fn(record)}forEachIdentityChange(fn){let record;for(record=this._identityChangesHead;null!==record;record=record._nextIdentityChange)fn(record)}diff(collection){if(null==collection&&(collection=[]),!isListLikeIterable(collection))throw new RuntimeError(900,ngDevMode&&`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);return this.check(collection)?this:null}onDestroy(){}check(collection){this._reset();let index,item,itemTrackBy,record=this._itHead,mayBeDirty=!1;if(Array.isArray(collection)){this.length=collection.length;for(let index=0;index<this.length;index++)item=collection[index],itemTrackBy=this._trackByFn(index,item),null!==record&&Object.is(record.trackById,itemTrackBy)?(mayBeDirty&&(record=this._verifyReinsertion(record,item,itemTrackBy,index)),Object.is(record.item,item)||this._addIdentityChange(record,item)):(record=this._mismatch(record,item,itemTrackBy,index),mayBeDirty=!0),record=record._next}else index=0,function iterateListLike(obj,fn){if(Array.isArray(obj))for(let i=0;i<obj.length;i++)fn(obj[i]);else{const iterator=obj[Symbol.iterator]();let item;for(;!(item=iterator.next()).done;)fn(item.value)}}(collection,(item=>{itemTrackBy=this._trackByFn(index,item),null!==record&&Object.is(record.trackById,itemTrackBy)?(mayBeDirty&&(record=this._verifyReinsertion(record,item,itemTrackBy,index)),Object.is(record.item,item)||this._addIdentityChange(record,item)):(record=this._mismatch(record,item,itemTrackBy,index),mayBeDirty=!0),record=record._next,index++})),this.length=index;return this._truncate(record),this.collection=collection,this.isDirty}get isDirty(){return null!==this._additionsHead||null!==this._movesHead||null!==this._removalsHead||null!==this._identityChangesHead}_reset(){if(this.isDirty){let record;for(record=this._previousItHead=this._itHead;null!==record;record=record._next)record._nextPrevious=record._next;for(record=this._additionsHead;null!==record;record=record._nextAdded)record.previousIndex=record.currentIndex;for(this._additionsHead=this._additionsTail=null,record=this._movesHead;null!==record;record=record._nextMoved)record.previousIndex=record.currentIndex;this._movesHead=this._movesTail=null,this._removalsHead=this._removalsTail=null,this._identityChangesHead=this._identityChangesTail=null}}_mismatch(record,item,itemTrackBy,index){let previousRecord;return null===record?previousRecord=this._itTail:(previousRecord=record._prev,this._remove(record)),null!==(record=null===this._unlinkedRecords?null:this._unlinkedRecords.get(itemTrackBy,null))?(Object.is(record.item,item)||this._addIdentityChange(record,item),this._reinsertAfter(record,previousRecord,index)):null!==(record=null===this._linkedRecords?null:this._linkedRecords.get(itemTrackBy,index))?(Object.is(record.item,item)||this._addIdentityChange(record,item),this._moveAfter(record,previousRecord,index)):record=this._addAfter(new IterableChangeRecord_(item,itemTrackBy),previousRecord,index),record}_verifyReinsertion(record,item,itemTrackBy,index){let reinsertRecord=null===this._unlinkedRecords?null:this._unlinkedRecords.get(itemTrackBy,null);return null!==reinsertRecord?record=this._reinsertAfter(reinsertRecord,record._prev,index):record.currentIndex!=index&&(record.currentIndex=index,this._addToMoves(record,index)),record}_truncate(record){for(;null!==record;){const nextRecord=record._next;this._addToRemovals(this._unlink(record)),record=nextRecord}null!==this._unlinkedRecords&&this._unlinkedRecords.clear(),null!==this._additionsTail&&(this._additionsTail._nextAdded=null),null!==this._movesTail&&(this._movesTail._nextMoved=null),null!==this._itTail&&(this._itTail._next=null),null!==this._removalsTail&&(this._removalsTail._nextRemoved=null),null!==this._identityChangesTail&&(this._identityChangesTail._nextIdentityChange=null)}_reinsertAfter(record,prevRecord,index){null!==this._unlinkedRecords&&this._unlinkedRecords.remove(record);const prev=record._prevRemoved,next=record._nextRemoved;return null===prev?this._removalsHead=next:prev._nextRemoved=next,null===next?this._removalsTail=prev:next._prevRemoved=prev,this._insertAfter(record,prevRecord,index),this._addToMoves(record,index),record}_moveAfter(record,prevRecord,index){return this._unlink(record),this._insertAfter(record,prevRecord,index),this._addToMoves(record,index),record}_addAfter(record,prevRecord,index){return this._insertAfter(record,prevRecord,index),null===this._additionsTail?this._additionsTail=this._additionsHead=record:this._additionsTail=this._additionsTail._nextAdded=record,record}_insertAfter(record,prevRecord,index){const next=null===prevRecord?this._itHead:prevRecord._next;return record._next=next,record._prev=prevRecord,null===next?this._itTail=record:next._prev=record,null===prevRecord?this._itHead=record:prevRecord._next=record,null===this._linkedRecords&&(this._linkedRecords=new _DuplicateMap),this._linkedRecords.put(record),record.currentIndex=index,record}_remove(record){return this._addToRemovals(this._unlink(record))}_unlink(record){null!==this._linkedRecords&&this._linkedRecords.remove(record);const prev=record._prev,next=record._next;return null===prev?this._itHead=next:prev._next=next,null===next?this._itTail=prev:next._prev=prev,record}_addToMoves(record,toIndex){return record.previousIndex===toIndex||(null===this._movesTail?this._movesTail=this._movesHead=record:this._movesTail=this._movesTail._nextMoved=record),record}_addToRemovals(record){return null===this._unlinkedRecords&&(this._unlinkedRecords=new _DuplicateMap),this._unlinkedRecords.put(record),record.currentIndex=null,record._nextRemoved=null,null===this._removalsTail?(this._removalsTail=this._removalsHead=record,record._prevRemoved=null):(record._prevRemoved=this._removalsTail,this._removalsTail=this._removalsTail._nextRemoved=record),record}_addIdentityChange(record,item){return record.item=item,null===this._identityChangesTail?this._identityChangesTail=this._identityChangesHead=record:this._identityChangesTail=this._identityChangesTail._nextIdentityChange=record,record}}class IterableChangeRecord_{constructor(item,trackById){this.item=item,this.trackById=trackById,this.currentIndex=null,this.previousIndex=null,this._nextPrevious=null,this._prev=null,this._next=null,this._prevDup=null,this._nextDup=null,this._prevRemoved=null,this._nextRemoved=null,this._nextAdded=null,this._nextMoved=null,this._nextIdentityChange=null}}class _DuplicateItemRecordList{constructor(){this._head=null,this._tail=null}add(record){null===this._head?(this._head=this._tail=record,record._nextDup=null,record._prevDup=null):(this._tail._nextDup=record,record._prevDup=this._tail,record._nextDup=null,this._tail=record)}get(trackById,atOrAfterIndex){let record;for(record=this._head;null!==record;record=record._nextDup)if((null===atOrAfterIndex||atOrAfterIndex<=record.currentIndex)&&Object.is(record.trackById,trackById))return record;return null}remove(record){const prev=record._prevDup,next=record._nextDup;return null===prev?this._head=next:prev._nextDup=next,null===next?this._tail=prev:next._prevDup=prev,null===this._head}}class _DuplicateMap{constructor(){this.map=new Map}put(record){const key=record.trackById;let duplicates=this.map.get(key);duplicates||(duplicates=new _DuplicateItemRecordList,this.map.set(key,duplicates)),duplicates.add(record)}get(trackById,atOrAfterIndex){const key=trackById,recordList=this.map.get(key);return recordList?recordList.get(trackById,atOrAfterIndex):null}remove(record){const key=record.trackById;return this.map.get(key).remove(record)&&this.map.delete(key),record}get isEmpty(){return 0===this.map.size}clear(){this.map.clear()}}function getPreviousIndex(item,addRemoveOffset,moveOffsets){const previousIndex=item.previousIndex;if(null===previousIndex)return previousIndex;let moveOffset=0;return moveOffsets&&previousIndex<moveOffsets.length&&(moveOffset=moveOffsets[previousIndex]),previousIndex+addRemoveOffset+moveOffset}class DefaultKeyValueDifferFactory{constructor(){}supports(obj){return obj instanceof Map||isJsObject(obj)}create(){return new DefaultKeyValueDiffer}}class DefaultKeyValueDiffer{constructor(){this._records=new Map,this._mapHead=null,this._appendAfter=null,this._previousMapHead=null,this._changesHead=null,this._changesTail=null,this._additionsHead=null,this._additionsTail=null,this._removalsHead=null,this._removalsTail=null}get isDirty(){return null!==this._additionsHead||null!==this._changesHead||null!==this._removalsHead}forEachItem(fn){let record;for(record=this._mapHead;null!==record;record=record._next)fn(record)}forEachPreviousItem(fn){let record;for(record=this._previousMapHead;null!==record;record=record._nextPrevious)fn(record)}forEachChangedItem(fn){let record;for(record=this._changesHead;null!==record;record=record._nextChanged)fn(record)}forEachAddedItem(fn){let record;for(record=this._additionsHead;null!==record;record=record._nextAdded)fn(record)}forEachRemovedItem(fn){let record;for(record=this._removalsHead;null!==record;record=record._nextRemoved)fn(record)}diff(map){if(map){if(!(map instanceof Map||isJsObject(map)))throw new RuntimeError(900,ngDevMode&&`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`)}else map=new Map;return this.check(map)?this:null}onDestroy(){}check(map){this._reset();let insertBefore=this._mapHead;if(this._appendAfter=null,this._forEach(map,((value,key)=>{if(insertBefore&&insertBefore.key===key)this._maybeAddToChanges(insertBefore,value),this._appendAfter=insertBefore,insertBefore=insertBefore._next;else{const record=this._getOrCreateRecordForKey(key,value);insertBefore=this._insertBeforeOrAppend(insertBefore,record)}})),insertBefore){insertBefore._prev&&(insertBefore._prev._next=null),this._removalsHead=insertBefore;for(let record=insertBefore;null!==record;record=record._nextRemoved)record===this._mapHead&&(this._mapHead=null),this._records.delete(record.key),record._nextRemoved=record._next,record.previousValue=record.currentValue,record.currentValue=null,record._prev=null,record._next=null}return this._changesTail&&(this._changesTail._nextChanged=null),this._additionsTail&&(this._additionsTail._nextAdded=null),this.isDirty}_insertBeforeOrAppend(before,record){if(before){const prev=before._prev;return record._next=before,record._prev=prev,before._prev=record,prev&&(prev._next=record),before===this._mapHead&&(this._mapHead=record),this._appendAfter=before,before}return this._appendAfter?(this._appendAfter._next=record,record._prev=this._appendAfter):this._mapHead=record,this._appendAfter=record,null}_getOrCreateRecordForKey(key,value){if(this._records.has(key)){const record=this._records.get(key);this._maybeAddToChanges(record,value);const prev=record._prev,next=record._next;return prev&&(prev._next=next),next&&(next._prev=prev),record._next=null,record._prev=null,record}const record=new KeyValueChangeRecord_(key);return this._records.set(key,record),record.currentValue=value,this._addToAdditions(record),record}_reset(){if(this.isDirty){let record;for(this._previousMapHead=this._mapHead,record=this._previousMapHead;null!==record;record=record._next)record._nextPrevious=record._next;for(record=this._changesHead;null!==record;record=record._nextChanged)record.previousValue=record.currentValue;for(record=this._additionsHead;null!=record;record=record._nextAdded)record.previousValue=record.currentValue;this._changesHead=this._changesTail=null,this._additionsHead=this._additionsTail=null,this._removalsHead=null}}_maybeAddToChanges(record,newValue){Object.is(newValue,record.currentValue)||(record.previousValue=record.currentValue,record.currentValue=newValue,this._addToChanges(record))}_addToAdditions(record){null===this._additionsHead?this._additionsHead=this._additionsTail=record:(this._additionsTail._nextAdded=record,this._additionsTail=record)}_addToChanges(record){null===this._changesHead?this._changesHead=this._changesTail=record:(this._changesTail._nextChanged=record,this._changesTail=record)}_forEach(obj,fn){obj instanceof Map?obj.forEach(fn):Object.keys(obj).forEach((k=>fn(obj[k],k)))}}class KeyValueChangeRecord_{constructor(key){this.key=key,this.previousValue=null,this.currentValue=null,this._nextPrevious=null,this._next=null,this._prev=null,this._nextAdded=null,this._nextRemoved=null,this._nextChanged=null}}function defaultIterableDiffersFactory(){return new IterableDiffers([new DefaultIterableDifferFactory])}class IterableDiffers{static#_=this.ɵprov=ɵɵdefineInjectable({token:IterableDiffers,providedIn:"root",factory:defaultIterableDiffersFactory});constructor(factories){this.factories=factories}static create(factories,parent){if(null!=parent){const copied=parent.factories.slice();factories=factories.concat(copied)}return new IterableDiffers(factories)}static extend(factories){return{provide:IterableDiffers,useFactory:parent=>IterableDiffers.create(factories,parent||defaultIterableDiffersFactory()),deps:[[IterableDiffers,new SkipSelf,new Optional]]}}find(iterable){const factory=this.factories.find((f=>f.supports(iterable)));if(null!=factory)return factory;throw new RuntimeError(901,ngDevMode&&`Cannot find a differ supporting object '${iterable}' of type '${function getTypeNameForDebugging(type){return type.name||typeof type}(iterable)}'`)}}function defaultKeyValueDiffersFactory(){return new KeyValueDiffers([new DefaultKeyValueDifferFactory])}class KeyValueDiffers{static#_=this.ɵprov=ɵɵdefineInjectable({token:KeyValueDiffers,providedIn:"root",factory:defaultKeyValueDiffersFactory});constructor(factories){this.factories=factories}static create(factories,parent){if(parent){const copied=parent.factories.slice();factories=factories.concat(copied)}return new KeyValueDiffers(factories)}static extend(factories){return{provide:KeyValueDiffers,useFactory:parent=>KeyValueDiffers.create(factories,parent||defaultKeyValueDiffersFactory()),deps:[[KeyValueDiffers,new SkipSelf,new Optional]]}}find(kv){const factory=this.factories.find((f=>f.supports(kv)));if(factory)return factory;throw new RuntimeError(901,ngDevMode&&`Cannot find a differ supporting object '${kv}'`)}}const keyValDiff=[new DefaultKeyValueDifferFactory],iterableDiff=[new DefaultIterableDifferFactory];new IterableDiffers(iterableDiff),new KeyValueDiffers(keyValDiff),function createPlatformFactory(parentPlatformFactory,name,providers=[]){const desc=`Platform: ${name}`,marker=new InjectionToken(desc);return(extraProviders=[])=>{let platform=getPlatform();if(!platform||platform.injector.get(ALLOW_MULTIPLE_PLATFORMS,!1)){const platformProviders=[...providers,...extraProviders,{provide:marker,useValue:!0}];parentPlatformFactory?parentPlatformFactory(platformProviders):function createPlatform(injector){if(_platformInjector&&!_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS,!1))throw new RuntimeError(400,ngDevMode&&"There can be only one platform. Destroy the previous one to create a new one.");publishDefaultGlobalUtils(),publishSignalConfiguration(),_platformInjector=injector;const platform=injector.get(PlatformRef);return runPlatformInitializers(injector),platform}(createPlatformInjector(platformProviders,desc))}return function assertPlatform(requiredToken){const platform=getPlatform();if(!platform)throw new RuntimeError(401,ngDevMode&&"No platform exists!");if(("undefined"==typeof ngDevMode||ngDevMode)&&!platform.injector.get(requiredToken,null))throw new RuntimeError(400,"A platform with a different configuration has been created. Please destroy it first.");return platform}(marker)}}(null,"core",[]);class ApplicationModule{constructor(appRef){}static#_=this.ɵfac=function ApplicationModule_Factory(t){return new(t||ApplicationModule)(ɵɵinject(ApplicationRef))};static#_2=this.ɵmod=ɵɵdefineNgModule({type:ApplicationModule});static#_3=this.ɵinj=ɵɵdefineInjector({})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ApplicationModule,[{type:NgModule}],(()=>[{type:ApplicationRef}]),null);class ImagePerformanceWarning{constructor(){this.window=null,this.observer=null,this.options=inject(IMAGE_CONFIG),this.ngZone=inject(NgZone)}start(){if("undefined"==typeof PerformanceObserver||this.options?.disableImageSizeWarning&&this.options?.disableImageLazyLoadWarning)return;this.observer=this.initPerformanceObserver();const doc=getDocument(),win=doc.defaultView;if(void 0!==win){this.window=win;const waitToScan=()=>{setTimeout(this.scanImages.bind(this),200)};this.ngZone.runOutsideAngular((()=>{"complete"===doc.readyState?waitToScan():this.window?.addEventListener("load",waitToScan,{once:!0})}))}}ngOnDestroy(){this.observer?.disconnect()}initPerformanceObserver(){if("undefined"==typeof PerformanceObserver)return null;const observer=new PerformanceObserver((entryList=>{const entries=entryList.getEntries();if(0===entries.length)return;const lcpElement=entries[entries.length-1],imgSrc=lcpElement.element?.src??"";imgSrc.startsWith("data:")||imgSrc.startsWith("blob:")||(this.lcpImageUrl=imgSrc)}));return observer.observe({type:"largest-contentful-paint",buffered:!0}),observer}scanImages(){const images=getDocument().querySelectorAll("img");let lcpElementFound,lcpElementLoadedCorrectly=!1;images.forEach((image=>{if(!this.options?.disableImageSizeWarning)for(const image of images)!image.getAttribute("ng-img")&&this.isOversized(image)&&(src=image.src,console.warn(formatRuntimeError(-913,`An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.io/errors/NG0913`)));var src;!this.options?.disableImageLazyLoadWarning&&this.lcpImageUrl&&image.src===this.lcpImageUrl&&(lcpElementFound=!0,("lazy"!==image.loading||image.getAttribute("ng-img"))&&(lcpElementLoadedCorrectly=!0))})),lcpElementFound&&!lcpElementLoadedCorrectly&&this.lcpImageUrl&&!this.options?.disableImageLazyLoadWarning&&function logLazyLCPWarning(src){console.warn(formatRuntimeError(-913,`An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a "loading" value of "lazy", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to "eager", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.io/errors/NG0913`))}(this.lcpImageUrl)}isOversized(image){if(!this.window)return!1;const computedStyle=this.window.getComputedStyle(image);let renderedWidth=parseFloat(computedStyle.getPropertyValue("width")),renderedHeight=parseFloat(computedStyle.getPropertyValue("height"));const boxSizing=computedStyle.getPropertyValue("box-sizing");if("cover"===computedStyle.getPropertyValue("object-fit"))return!1;if("border-box"===boxSizing){const paddingTop=computedStyle.getPropertyValue("padding-top"),paddingRight=computedStyle.getPropertyValue("padding-right"),paddingBottom=computedStyle.getPropertyValue("padding-bottom"),paddingLeft=computedStyle.getPropertyValue("padding-left");renderedWidth-=parseFloat(paddingRight)+parseFloat(paddingLeft),renderedHeight-=parseFloat(paddingTop)+parseFloat(paddingBottom)}const intrinsicWidth=image.naturalWidth,intrinsicHeight=image.naturalHeight,recommendedWidth=this.window.devicePixelRatio*renderedWidth,recommendedHeight=this.window.devicePixelRatio*renderedHeight;return intrinsicWidth-recommendedWidth>=1200||intrinsicHeight-recommendedHeight>=1200}static#_=this.ɵfac=function ImagePerformanceWarning_Factory(t){return new(t||ImagePerformanceWarning)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:ImagePerformanceWarning,factory:ImagePerformanceWarning.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ImagePerformanceWarning,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);class ChangeDetectionSchedulerImpl{constructor(){this.appRef=inject(ApplicationRef),this.taskService=inject(PendingTasks),this.pendingRenderTaskId=null,this.shouldRefreshViews=!1}notify(type=0){this.shouldRefreshViews||=0===type,null===this.pendingRenderTaskId&&(this.pendingRenderTaskId=this.taskService.add(),this.raceTimeoutAndRequestAnimationFrame())}raceTimeoutAndRequestAnimationFrame(){var _this=this;return(0,asyncToGenerator.A)((function*(){const timeout=new Promise((resolve=>setTimeout(resolve))),rAF="function"==typeof _global.requestAnimationFrame?new Promise((resolve=>requestAnimationFrame((()=>resolve())))):null;yield Promise.race([timeout,rAF]),_this.tick()}))()}tick(){try{this.appRef.destroyed||this.appRef._tick(this.shouldRefreshViews)}finally{this.shouldRefreshViews=!1;const taskId=this.pendingRenderTaskId;this.pendingRenderTaskId=null,this.taskService.remove(taskId)}}static#_=this.ɵfac=function ChangeDetectionSchedulerImpl_Factory(t){return new(t||ChangeDetectionSchedulerImpl)};static#_2=this.ɵprov=ɵɵdefineInjectable({token:ChangeDetectionSchedulerImpl,factory:ChangeDetectionSchedulerImpl.ɵfac,providedIn:"root"})}("undefined"==typeof ngDevMode||ngDevMode)&&setClassMetadata(ChangeDetectionSchedulerImpl,[{type:Injectable,args:[{providedIn:"root"}]}],null,null);function booleanAttribute(value){return"boolean"==typeof value?value:null!=value&&"false"!==value}function numberAttribute(value,fallbackValue=NaN){return!isNaN(parseFloat(value))&&!isNaN(Number(value))?Number(value):fallbackValue}function computed(computation,options){performanceMarkFeature("NgSignals");const getter=createComputed(computation);return options?.equal&&(getter[SIGNAL].equal=options.equal),ngDevMode&&(getter.toString=()=>`[Computed: ${getter()}]`),getter}function untracked(nonReactiveReadsFn){const prevConsumer=setActiveConsumer(null);try{return nonReactiveReadsFn()}finally{setActiveConsumer(prevConsumer)}}const APP_EFFECT_SCHEDULER=new InjectionToken("",{providedIn:"root",factory:()=>inject(EffectScheduler)});class EffectScheduler{static#_=this.ɵprov=ɵɵdefineInjectable({token:EffectScheduler,providedIn:"root",factory:()=>new ZoneAwareEffectScheduler})}class ZoneAwareEffectScheduler{constructor(){this.queuedEffectCount=0,this.queues=new Map,this.pendingTasks=inject(PendingTasks),this.taskId=null}scheduleEffect(handle){if(this.enqueue(handle),null===this.taskId){const taskId=this.taskId=this.pendingTasks.add();queueMicrotask((()=>{this.flush(),this.pendingTasks.remove(taskId),this.taskId=null}))}}enqueue(handle){const zone=handle.creationZone;this.queues.has(zone)||this.queues.set(zone,new Set);const queue=this.queues.get(zone);queue.has(handle)||(this.queuedEffectCount++,queue.add(handle))}flush(){for(;this.queuedEffectCount>0;)for(const[zone,queue]of this.queues)null===zone?this.flushQueue(queue):zone.run((()=>this.flushQueue(queue)))}flushQueue(queue){for(const handle of queue)queue.delete(handle),this.queuedEffectCount--,handle.run()}}class EffectHandle{constructor(scheduler,effectFn,creationZone,destroyRef,injector,allowSignalWrites){this.scheduler=scheduler,this.effectFn=effectFn,this.creationZone=creationZone,this.injector=injector,this.watcher=createWatch((onCleanup=>this.runEffect(onCleanup)),(()=>this.schedule()),allowSignalWrites),this.unregisterOnDestroy=destroyRef?.onDestroy((()=>this.destroy()))}runEffect(onCleanup){try{this.effectFn(onCleanup)}catch(err){const errorHandler=this.injector.get(ErrorHandler,null,{optional:!0});errorHandler?.handleError(err)}}run(){this.watcher.run()}schedule(){this.scheduler.scheduleEffect(this)}destroy(){this.watcher.destroy(),this.unregisterOnDestroy?.()}}function effect(effectFn,options){performanceMarkFeature("NgSignals"),ngDevMode&&assertNotInReactiveContext(effect,"Call `effect` outside of a reactive context. For example, schedule the effect inside the component constructor."),!options?.injector&&assertInInjectionContext(effect);const injector=options?.injector??inject(Injector),destroyRef=!0!==options?.manualCleanup?injector.get(DestroyRef):null,handle=new EffectHandle(injector.get(APP_EFFECT_SCHEDULER),effectFn,"undefined"==typeof Zone?null:Zone.current,destroyRef,injector,options?.allowSignalWrites??!1),cdr=injector.get(ChangeDetectorRef,null,{optional:!0});return cdr&&8&cdr._lView[FLAGS]?(cdr._lView[EFFECTS_TO_SCHEDULE]??=[]).push(handle.watcher.notify):handle.watcher.notify(),handle}"undefined"!=typeof ngDevMode&&ngDevMode&&(_global.$localize??=function(){throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)")})},"./node_modules/.pnpm/css-loader@7.1.1_webpack@5.91.0_@swc+core@1.5.7_@swc+helpers@0.5.11__esbuild@0.21.3_/node_modules/css-loader/dist/runtime/api.js":module=>{module.exports=function(cssWithMappingToString){var list=[];return list.toString=function toString(){return this.map((function(item){var content="",needLayer=void 0!==item[5];return item[4]&&(content+="@supports (".concat(item[4],") {")),item[2]&&(content+="@media ".concat(item[2]," {")),needLayer&&(content+="@layer".concat(item[5].length>0?" ".concat(item[5]):""," {")),content+=cssWithMappingToString(item),needLayer&&(content+="}"),item[2]&&(content+="}"),item[4]&&(content+="}"),content})).join("")},list.i=function i(modules,media,dedupe,supports,layer){"string"==typeof modules&&(modules=[[null,modules,void 0]]);var alreadyImportedModules={};if(dedupe)for(var k=0;k<this.length;k++){var id=this[k][0];null!=id&&(alreadyImportedModules[id]=!0)}for(var _k=0;_k<modules.length;_k++){var item=[].concat(modules[_k]);dedupe&&alreadyImportedModules[item[0]]||(void 0!==layer&&(void 0===item[5]||(item[1]="@layer".concat(item[5].length>0?" ".concat(item[5]):""," {").concat(item[1],"}")),item[5]=layer),media&&(item[2]?(item[1]="@media ".concat(item[2]," {").concat(item[1],"}"),item[2]=media):item[2]=media),supports&&(item[4]?(item[1]="@supports (".concat(item[4],") {").concat(item[1],"}"),item[4]=supports):item[4]="".concat(supports)),list.push(item))}},list}},"./node_modules/.pnpm/css-loader@7.1.1_webpack@5.91.0_@swc+core@1.5.7_@swc+helpers@0.5.11__esbuild@0.21.3_/node_modules/css-loader/dist/runtime/noSourceMaps.js":module=>{module.exports=function(i){return i[1]}}}]);